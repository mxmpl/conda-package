//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/sgmm2/am-sgmm2.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "itf/options-itf-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/sp-matrix-clifwrap.h"
#include "base/iostream-clifwrap.h"
#include "gmm/full-gmm-clifwrap.h"
#include "gmm/diag-gmm-clifwrap.h"
#include "am-sgmm2-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __am__sgmm2_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pySgmm2SplitSubstatesConfig {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2SplitSubstatesConfig> cpp;
};
static ::kaldi::Sgmm2SplitSubstatesConfig* ThisPtr(PyObject*);

static PyObject* get_split_substates(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->split_substates, {});
}

static int set_split_substates(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the split_substates attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->split_substates)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for split_substates:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_perturb_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->perturb_factor, {});
}

static int set_perturb_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the perturb_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->perturb_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for perturb_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_power(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->power, {});
}

static int set_power(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the power attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->power)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for power:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_cond(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_cond, {});
}

static int set_max_cond(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_cond attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_cond)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_cond:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_min_count(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->min_count, {});
}

static int set_min_count(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the min_count attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->min_count)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for min_count:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::Sgmm2SplitSubstatesConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("split_substates"), get_split_substates, set_split_substates, C("C++ ::int32 Sgmm2SplitSubstatesConfig.split_substates")},
  {C("perturb_factor"), get_perturb_factor, set_perturb_factor, C("C++ ::kaldi::BaseFloat Sgmm2SplitSubstatesConfig.perturb_factor")},
  {C("power"), get_power, set_power, C("C++ ::kaldi::BaseFloat Sgmm2SplitSubstatesConfig.power")},
  {C("max_cond"), get_max_cond, set_max_cond, C("C++ ::kaldi::BaseFloat Sgmm2SplitSubstatesConfig.max_cond")},
  {C("min_count"), get_min_count, set_min_count, C("C++ ::kaldi::BaseFloat Sgmm2SplitSubstatesConfig.min_count")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::Sgmm2SplitSubstatesConfig::Register(::kaldi::OptionsItf *)")},
  {}
};

// Sgmm2SplitSubstatesConfig __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2SplitSubstatesConfig __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2SplitSubstatesConfig __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2SplitSubstatesConfig", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2SplitSubstatesConfig", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Sgmm2SplitSubstatesConfig takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2SplitSubstatesConfig>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2SplitSubstatesConfig* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2SplitSubstatesConfig"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2SplitSubstatesConfig"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2SplitSubstatesConfig* c = static_cast<::kaldi::Sgmm2SplitSubstatesConfig*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2SplitSubstatesConfig*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2SplitSubstatesConfig

namespace pySgmm2GselectConfig {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2GselectConfig> cpp;
};
static ::kaldi::Sgmm2GselectConfig* ThisPtr(PyObject*);

static PyObject* get_full_gmm_nbest(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->full_gmm_nbest, {});
}

static int set_full_gmm_nbest(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the full_gmm_nbest attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->full_gmm_nbest)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for full_gmm_nbest:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_diag_gmm_nbest(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->diag_gmm_nbest, {});
}

static int set_diag_gmm_nbest(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the diag_gmm_nbest attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->diag_gmm_nbest)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for diag_gmm_nbest:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::Sgmm2GselectConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("full_gmm_nbest"), get_full_gmm_nbest, set_full_gmm_nbest, C("C++ ::int32 Sgmm2GselectConfig.full_gmm_nbest")},
  {C("diag_gmm_nbest"), get_diag_gmm_nbest, set_diag_gmm_nbest, C("C++ ::int32 Sgmm2GselectConfig.diag_gmm_nbest")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::Sgmm2GselectConfig::Register(::kaldi::OptionsItf *)")},
  {}
};

// Sgmm2GselectConfig __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2GselectConfig __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2GselectConfig __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2GselectConfig",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2GselectConfig", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Sgmm2GselectConfig takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2GselectConfig>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2GselectConfig* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2GselectConfig"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2GselectConfig"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2GselectConfig* c = static_cast<::kaldi::Sgmm2GselectConfig*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2GselectConfig*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2GselectConfig

namespace pySgmm2PerFrameDerivedVars {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2PerFrameDerivedVars> cpp;
};
static ::kaldi::Sgmm2PerFrameDerivedVars* ThisPtr(PyObject*);

static PyObject* get_gselect(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->gselect, {});
}

static int set_gselect(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the gselect attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->gselect)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for gselect:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_xt(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->xt), {});
}

static int set_xt(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the xt attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->xt)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for xt:Vector", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_xti(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->xti), {});
}

static int set_xti(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the xti attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->xti)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for xti:Matrix", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_zti(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->zti), {});
}

static int set_zti(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the zti attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->zti)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for zti:Matrix", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nti(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->nti), {});
}

static int set_nti(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nti attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nti)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nti:Vector", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// resize(ngauss:int, feat_dim:int, phn_dim:int)
static PyObject* wrapResize_as_resize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("ngauss"),
      C("feat_dim"),
      C("phn_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:resize", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize", names[2], "int", a[2]);
  // Call actual C++ method.
  ::kaldi::Sgmm2PerFrameDerivedVars* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("gselect"), get_gselect, set_gselect, C("C++ ::std::vector< ::int32> Sgmm2PerFrameDerivedVars.gselect")},
  {C("xt"), get_xt, set_xt, C("C++ ::kaldi::Vector< ::kaldi::BaseFloat> Sgmm2PerFrameDerivedVars.xt")},
  {C("xti"), get_xti, set_xti, C("C++ ::kaldi::Matrix< ::kaldi::BaseFloat> Sgmm2PerFrameDerivedVars.xti")},
  {C("zti"), get_zti, set_zti, C("C++ ::kaldi::Matrix< ::kaldi::BaseFloat> Sgmm2PerFrameDerivedVars.zti")},
  {C("nti"), get_nti, set_nti, C("C++ ::kaldi::Vector< ::kaldi::BaseFloat> Sgmm2PerFrameDerivedVars.nti")},
  {}
};

static PyMethodDef Methods[] = {
  {C("resize"), (PyCFunction)wrapResize_as_resize, METH_VARARGS | METH_KEYWORDS, C("resize(ngauss:int, feat_dim:int, phn_dim:int)\n  Calls C++ function\n  void ::kaldi::Sgmm2PerFrameDerivedVars::Resize(int, int, int)")},
  {}
};

// Sgmm2PerFrameDerivedVars __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2PerFrameDerivedVars __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2PerFrameDerivedVars __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2PerFrameDerivedVars", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2PerFrameDerivedVars", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Sgmm2PerFrameDerivedVars takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2PerFrameDerivedVars>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2PerFrameDerivedVars* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2PerFrameDerivedVars"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2PerFrameDerivedVars"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2PerFrameDerivedVars* c = static_cast<::kaldi::Sgmm2PerFrameDerivedVars*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2PerFrameDerivedVars*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2PerFrameDerivedVars

namespace pySgmm2PerSpkDerivedVars {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2PerSpkDerivedVars> cpp;
};
static ::kaldi::Sgmm2PerSpkDerivedVars* ThisPtr(PyObject*);

// clear()
static PyObject* wrapClear_as_clear(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Sgmm2PerSpkDerivedVars* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Clear();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// empty() -> bool
static PyObject* wrapEmpty_as_empty(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Sgmm2PerSpkDerivedVars* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Empty();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_speaker_vector() -> Vector
static PyObject* wrapGetSpeakerVector_as_get_speaker_vector(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Sgmm2PerSpkDerivedVars* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetSpeakerVector();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_speaker_vector(v_s_in:Vector)
static PyObject* wrapSetSpeakerVector_as_set_speaker_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v_s_in"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_speaker_vector", names, &a[0])) return nullptr;
  ::kaldi::Vector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_speaker_vector", names[0], "::kaldi::Vector<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::Sgmm2PerSpkDerivedVars* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetSpeakerVector(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("clear"), (PyCFunction)wrapClear_as_clear, METH_NOARGS, C("clear()\n  Calls C++ function\n  void ::kaldi::Sgmm2PerSpkDerivedVars::Clear()")},
  {C("empty"), (PyCFunction)wrapEmpty_as_empty, METH_NOARGS, C("empty() -> bool\n  Calls C++ function\n  bool ::kaldi::Sgmm2PerSpkDerivedVars::Empty()")},
  {C("get_speaker_vector"), (PyCFunction)wrapGetSpeakerVector_as_get_speaker_vector, METH_NOARGS, C("get_speaker_vector() -> Vector\n  Calls C++ function\n  ::kaldi::Vector<float> ::kaldi::Sgmm2PerSpkDerivedVars::GetSpeakerVector()")},
  {C("set_speaker_vector"), (PyCFunction)wrapSetSpeakerVector_as_set_speaker_vector, METH_VARARGS | METH_KEYWORDS, C("set_speaker_vector(v_s_in:Vector)\n  Calls C++ function\n  void ::kaldi::Sgmm2PerSpkDerivedVars::SetSpeakerVector(::kaldi::Vector<float>)")},
  {}
};

// Sgmm2PerSpkDerivedVars __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2PerSpkDerivedVars __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2PerSpkDerivedVars __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2PerSpkDerivedVars",  // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2PerSpkDerivedVars", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Sgmm2PerSpkDerivedVars takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2PerSpkDerivedVars>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2PerSpkDerivedVars* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2PerSpkDerivedVars"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2PerSpkDerivedVars"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2PerSpkDerivedVars* c = static_cast<::kaldi::Sgmm2PerSpkDerivedVars*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2PerSpkDerivedVars*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2PerSpkDerivedVars

namespace pySgmm2LikelihoodCache {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2LikelihoodCache> cpp;
};
static ::kaldi::Sgmm2LikelihoodCache* ThisPtr(PyObject*);

// __init__(num_groups:int, num_pdfs:int)
static PyObject* wrapSgmm2LikelihoodCache_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("num_groups"),
      C("num_pdfs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pySubstateCacheElement {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement> cpp;
};
static ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* ThisPtr(PyObject*);

static PyObject* get_likes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->likes), {});
}

static int set_likes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the likes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->likes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for likes:Vector", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_remaining_log_like(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->remaining_log_like, {});
}

static int set_remaining_log_like(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the remaining_log_like attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->remaining_log_like)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for remaining_log_like:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_t(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->t, {});
}

static int set_t(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the t attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->t)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for t:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("likes"), get_likes, set_likes, C("C++ ::kaldi::Vector< ::kaldi::BaseFloat> Sgmm2LikelihoodCache::SubstateCacheElement.likes")},
  {C("remaining_log_like"), get_remaining_log_like, set_remaining_log_like, C("C++ ::kaldi::BaseFloat Sgmm2LikelihoodCache::SubstateCacheElement.remaining_log_like")},
  {C("t"), get_t, set_t, C("C++ ::int32 Sgmm2LikelihoodCache::SubstateCacheElement.t")},
  {}
};

// SubstateCacheElement __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SubstateCacheElement __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SubstateCacheElement __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2LikelihoodCache.SubstateCacheElement", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SubstateCacheElement takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2LikelihoodCache_SubstateCacheElement"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* c = static_cast<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySubstateCacheElement

namespace pyPdfCacheElement {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement> cpp;
};
static ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* ThisPtr(PyObject*);

static PyObject* get_log_like(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->log_like, {});
}

static int set_log_like(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the log_like attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->log_like)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for log_like:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_t(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->t, {});
}

static int set_t(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the t attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->t)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for t:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("log_like"), get_log_like, set_log_like, C("C++ ::kaldi::BaseFloat Sgmm2LikelihoodCache::PdfCacheElement.log_like")},
  {C("t"), get_t, set_t, C("C++ ::int32 Sgmm2LikelihoodCache::PdfCacheElement.t")},
  {}
};

// PdfCacheElement __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PdfCacheElement __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PdfCacheElement __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2LikelihoodCache.PdfCacheElement", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PdfCacheElement takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2LikelihoodCache_PdfCacheElement"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2LikelihoodCache::PdfCacheElement"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* c = static_cast<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPdfCacheElement

// next_frame()
static PyObject* wrapNextFrame_as_next_frame(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Sgmm2LikelihoodCache* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->NextFrame();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyObject* get_substate_cache(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->substate_cache, {});
}

static int set_substate_cache(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the substate_cache attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->substate_cache)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for substate_cache:list<SubstateCacheElement>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_pdf_cache(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->pdf_cache, {});
}

static int set_pdf_cache(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the pdf_cache attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->pdf_cache)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for pdf_cache:list<PdfCacheElement>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_t(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->t, {});
}

static int set_t(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the t attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->t)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for t:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("substate_cache"), get_substate_cache, set_substate_cache, C("C++ ::std::vector< ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement> Sgmm2LikelihoodCache.substate_cache")},
  {C("pdf_cache"), get_pdf_cache, set_pdf_cache, C("C++ ::std::vector< ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement> Sgmm2LikelihoodCache.pdf_cache")},
  {C("t"), get_t, set_t, C("C++ ::int32 Sgmm2LikelihoodCache.t")},
  {}
};

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSgmm2LikelihoodCache_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(num_groups:int, num_pdfs:int)\n  Calls C++ function\n  void ::kaldi::Sgmm2LikelihoodCache::Sgmm2LikelihoodCache(int, int)")},
  {C("next_frame"), (PyCFunction)wrapNextFrame_as_next_frame, METH_NOARGS, C("next_frame()\n\nIncrements t")},
  {}
};

// Sgmm2LikelihoodCache __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2LikelihoodCache __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2LikelihoodCache __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2LikelihoodCache",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2LikelihoodCache", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSgmm2LikelihoodCache_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2LikelihoodCache* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2LikelihoodCache"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2LikelihoodCache"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2LikelihoodCache* c = static_cast<::kaldi::Sgmm2LikelihoodCache*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2LikelihoodCache*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2LikelihoodCache

namespace pyAmSgmm2 {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::AmSgmm2> cpp;
};
static ::kaldi::AmSgmm2* ThisPtr(PyObject*);

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool, write_params:int)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("binary"),
      C("write_params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  unsigned short arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write", names[2], "unsigned short", a[2]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// check(show_properties:bool=default)
static PyObject* wrapCheck_as_check(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("show_properties"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:check", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!a[0]) arg1 = (bool)true;
    else if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("check", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    c->Check(); break;
  case 1:
    c->Check(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// initialize_from_full_gmm(gmm:FullGmm, pdf2group:list<int>, phn_subspace_dim:int, spk_subspace_dim:int, speaker_dependent_weights:bool, self_weight:float)
static PyObject* wrapInitializeFromFullGmm_as_initialize_from_full_gmm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("gmm"),
      C("pdf2group"),
      C("phn_subspace_dim"),
      C("spk_subspace_dim"),
      C("speaker_dependent_weights"),
      C("self_weight"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:initialize_from_full_gmm", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::FullGmm* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("initialize_from_full_gmm", names[0], "::kaldi::FullGmm", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("initialize_from_full_gmm", names[1], "::std::vector< ::int32>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("initialize_from_full_gmm", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("initialize_from_full_gmm", names[3], "int", a[3]);
  bool arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("initialize_from_full_gmm", names[4], "bool", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("initialize_from_full_gmm", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitializeFromFullGmm(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_globals_init_vecs(other:AmSgmm2, pdf2group:list<int>, self_weight:float)
static PyObject* wrapCopyGlobalsInitVecs_as_copy_globals_init_vecs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("other"),
      C("pdf2group"),
      C("self_weight"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:copy_globals_init_vecs", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::AmSgmm2* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_globals_init_vecs", names[0], "::kaldi::AmSgmm2", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_globals_init_vecs", names[1], "::std::vector< ::int32>", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("copy_globals_init_vecs", names[2], "float", a[2]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyGlobalsInitVecs(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_sgmm2(other:AmSgmm2, copy_normalizers:bool, copy_weights:bool)
static PyObject* wrapCopyFromSgmm2_as_copy_from_sgmm2(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("other"),
      C("copy_normalizers"),
      C("copy_weights"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:copy_from_sgmm2", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::AmSgmm2* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_sgmm2", names[0], "::kaldi::AmSgmm2", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_sgmm2", names[1], "bool", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("copy_from_sgmm2", names[2], "bool", a[2]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSgmm2(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// computer_per_frame_vars(data:Vector, gselect:list<int>, spk_vars:Sgmm2PerSpkDerivedVars) -> Sgmm2PerFrameDerivedVars
static PyObject* wrapComputePerFrameVars_as_computer_per_frame_vars(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("data"),
      C("gselect"),
      C("spk_vars"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:computer_per_frame_vars", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::Vector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("computer_per_frame_vars", names[0], "::kaldi::Vector<float>", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("computer_per_frame_vars", names[1], "::std::vector< ::int32>", a[1]);
  ::kaldi::Sgmm2PerSpkDerivedVars* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("computer_per_frame_vars", names[2], "::kaldi::Sgmm2PerSpkDerivedVars", a[2]);
  ::kaldi::Sgmm2PerFrameDerivedVars ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputePerFrameVars(*arg1, std::move(arg2), *arg3, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compute_per_spk_derived_vars(vars:Sgmm2PerSpkDerivedVars)
static PyObject* wrapComputePerSpkDerivedVars_as_compute_per_spk_derived_vars(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("vars"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compute_per_spk_derived_vars", names, &a[0])) return nullptr;
  ::kaldi::Sgmm2PerSpkDerivedVars * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_per_spk_derived_vars", names[0], "::kaldi::Sgmm2PerSpkDerivedVars *", a[0]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputePerSpkDerivedVars(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// loglikelihood(per_frame_vars:Sgmm2PerFrameDerivedVars, j2:int, cache:Sgmm2LikelihoodCache, spk_vars:Sgmm2PerSpkDerivedVars, log_prune:float=default) -> float
static PyObject* wrapLogLikelihood_as_loglikelihood(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("per_frame_vars"),
      C("j2"),
      C("cache"),
      C("spk_vars"),
      C("log_prune"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:loglikelihood", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::Sgmm2PerFrameDerivedVars* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("loglikelihood", names[0], "::kaldi::Sgmm2PerFrameDerivedVars", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("loglikelihood", names[1], "int", a[1]);
  ::kaldi::Sgmm2LikelihoodCache * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("loglikelihood", names[2], "::kaldi::Sgmm2LikelihoodCache *", a[2]);
  ::kaldi::Sgmm2PerSpkDerivedVars * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("loglikelihood", names[3], "::kaldi::Sgmm2PerSpkDerivedVars *", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!a[4]) arg5 = (float)0.000000e+00;
    else if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("loglikelihood", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    ret0 = c->LogLikelihood(*arg1, std::move(arg2), arg3, arg4); break;
  case 5:
    ret0 = c->LogLikelihood(*arg1, std::move(arg2), arg3, arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// component_posteriors(per_frame_vars:Sgmm2PerFrameDerivedVars, j2:int, spk_vars:Sgmm2PerSpkDerivedVars) -> (loglike:float, post:Matrix)
static PyObject* wrapComponentPosteriors_as_component_posteriors(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("per_frame_vars"),
      C("j2"),
      C("spk_vars"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:component_posteriors", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::Sgmm2PerFrameDerivedVars* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("component_posteriors", names[0], "::kaldi::Sgmm2PerFrameDerivedVars", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("component_posteriors", names[1], "int", a[1]);
  ::kaldi::Sgmm2PerSpkDerivedVars * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("component_posteriors", names[2], "::kaldi::Sgmm2PerSpkDerivedVars *", a[2]);
  ::kaldi::Matrix<float> ret1{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ComponentPosteriors(*arg1, std::move(arg2), arg3, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// split_substates(state_occupancies:Vector, config:Sgmm2SplitSubstatesConfig)
static PyObject* wrapSplitSubstates_as_split_substates(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("state_occupancies"),
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:split_substates", names, &a[0], &a[1])) return nullptr;
  ::kaldi::Vector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("split_substates", names[0], "::kaldi::Vector<float>", a[0]);
  ::kaldi::Sgmm2SplitSubstatesConfig* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("split_substates", names[1], "::kaldi::Sgmm2SplitSubstatesConfig", a[1]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SplitSubstates(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// increase_phone_space_dim(target_dim:int, norm_xform:Matrix)
static PyObject* wrapIncreasePhoneSpaceDim_as_increase_phone_space_dim(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("target_dim"),
      C("norm_xform"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:increase_phone_space_dim", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("increase_phone_space_dim", names[0], "int", a[0]);
  ::kaldi::Matrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("increase_phone_space_dim", names[1], "::kaldi::Matrix<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->IncreasePhoneSpaceDim(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// increase_spk_space_dim(target_dim:int, norm_xform:Matrix, speaker_dependent_weights:bool)
static PyObject* wrapIncreaseSpkSpaceDim_as_increase_spk_space_dim(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("target_dim"),
      C("norm_xform"),
      C("speaker_dependent_weights"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:increase_spk_space_dim", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("increase_spk_space_dim", names[0], "int", a[0]);
  ::kaldi::Matrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("increase_spk_space_dim", names[1], "::kaldi::Matrix<float>", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("increase_spk_space_dim", names[2], "bool", a[2]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->IncreaseSpkSpaceDim(std::move(arg1), *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compute_derived_vars()
static PyObject* wrapComputeDerivedVars_as_compute_derived_vars(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeDerivedVars();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compute_normalizers()
static PyObject* wrapComputeNormalizers_as_compute_normalizers(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeNormalizers();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compute_weights()
static PyObject* wrapComputeWeights_as_compute_weights(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeWeights();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compute_fmllr_pre_xform(pdf_occs:Vector) -> (xform:Matrix, inv_xform:Matrix, diag_mean_scatter:Vector)
static PyObject* wrapComputeFmllrPreXform_as_compute_fmllr_pre_xform(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("pdf_occs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compute_fmllr_pre_xform", names, &a[0])) return nullptr;
  ::kaldi::Vector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_fmllr_pre_xform", names[0], "::kaldi::Vector<float>", a[0]);
  ::kaldi::Matrix<float> ret0{};
  ::kaldi::Matrix<float> ret1{};
  ::kaldi::Vector<float> ret2{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeFmllrPreXform(*arg1, &ret0, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

// num_pdfs() -> int
static PyObject* wrapNumPdfs_as_num_pdfs(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumPdfs();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_groups() -> int
static PyObject* wrapNumGroups_as_num_groups(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumGroups();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// pdf2group(j2:int) -> int
static PyObject* wrapPdf2Group_as_pdf2group(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("j2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:pdf2group", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("pdf2group", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Pdf2Group(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_substates_for_pdf(j2:int) -> int
static PyObject* wrapNumSubstatesForPdf_as_num_substates_for_pdf(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("j2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:num_substates_for_pdf", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("num_substates_for_pdf", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumSubstatesForPdf(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_substates_for_group(j1:int) -> int
static PyObject* wrapNumSubstatesForGroup_as_num_substates_for_group(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("j1"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:num_substates_for_group", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("num_substates_for_group", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumSubstatesForGroup(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_gauss() -> int
static PyObject* wrapNumGauss_as_num_gauss(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumGauss();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// phone_space_dim() -> int
static PyObject* wrapPhoneSpaceDim_as_phone_space_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->PhoneSpaceDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// spk_space_dim() -> int
static PyObject* wrapSpkSpaceDim_as_spk_space_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SpkSpaceDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// feature_dim() -> int
static PyObject* wrapFeatureDim_as_feature_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FeatureDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_speaker_dependent_weights() -> bool
static PyObject* wrapHasSpeakerDependentWeights_as_has_speaker_dependent_weights(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasSpeakerDependentWeights();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_speaker_space() -> bool
static PyObject* wrapHasSpeakerSpace_as_has_speaker_space(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasSpeakerSpace();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// remove_speaker_space()
static PyObject* wrapRemoveSpeakerSpace_as_remove_speaker_space(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->RemoveSpeakerSpace();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_djms(j1:int, m:int, spk_vars:Sgmm2PerSpkDerivedVars) -> float
static PyObject* wrapGetDjms_as_get_djms(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("j1"),
      C("m"),
      C("spk_vars"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_djms", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_djms", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_djms", names[1], "int", a[1]);
  ::kaldi::Sgmm2PerSpkDerivedVars * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_djms", names[2], "::kaldi::Sgmm2PerSpkDerivedVars *", a[2]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetDjms(std::move(arg1), std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_inv_covars(gauss_index:int) -> SpMatrix
static PyObject* wrapGetInvCovars_as_get_inv_covars(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("gauss_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_inv_covars", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_inv_covars", names[0], "int", a[0]);
  ::kaldi::SpMatrix<float> ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetInvCovars(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_inv_covars_double(gauss_index:int) -> DoubleSpMatrix
static PyObject* wrapGetInvCovars_as_get_inv_covars_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("gauss_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_inv_covars_double", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_inv_covars_double", names[0], "int", a[0]);
  ::kaldi::SpMatrix<double> ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetInvCovars(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_substate_mean(j1:int, m:int, i:int, mean_out:VectorBase)
static PyObject* wrapGetSubstateMean_as_get_substate_mean(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("j1"),
      C("m"),
      C("i"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:get_substate_mean", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_substate_mean", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_substate_mean", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_substate_mean", names[2], "int", a[2]);
  ::kaldi::VectorBase<float> * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_substate_mean", names[3], "::kaldi::VectorBase<float> *", a[3]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSubstateMean(std::move(arg1), std::move(arg2), std::move(arg3), arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_substate_mean_double(j1:int, m:int, i:int, mean_out:DoubleVectorBase)
static PyObject* wrapGetSubstateMean_as_get_substate_mean_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("j1"),
      C("m"),
      C("i"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:get_substate_mean_double", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_substate_mean_double", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_substate_mean_double", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_substate_mean_double", names[2], "int", a[2]);
  ::kaldi::VectorBase<double> * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_substate_mean_double", names[3], "::kaldi::VectorBase<double> *", a[3]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSubstateMean(std::move(arg1), std::move(arg2), std::move(arg3), arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_ntrans_sigma_inv() -> list<Matrix>
static PyObject* wrapGetNtransSigmaInv_as_get_ntrans_sigma_inv(PyObject* self) {
  ::std::vector< ::kaldi::Matrix<float> > ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNtransSigmaInv(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_ntrans_sigma_inv_double() -> list<DoubleMatrix>
static PyObject* wrapGetNtransSigmaInv_as_get_ntrans_sigma_inv_double(PyObject* self) {
  ::std::vector< ::kaldi::Matrix<double> > ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNtransSigmaInv(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_substate_speaker_mean(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:VectorBase)
static PyObject* wrapGetSubstateSpeakerMean_as_get_substate_speaker_mean(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("j1"),
      C("substate"),
      C("gauss"),
      C("spk"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:get_substate_speaker_mean", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_substate_speaker_mean", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_substate_speaker_mean", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_substate_speaker_mean", names[2], "int", a[2]);
  ::kaldi::Sgmm2PerSpkDerivedVars* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_substate_speaker_mean", names[3], "::kaldi::Sgmm2PerSpkDerivedVars", a[3]);
  ::kaldi::VectorBase<float> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("get_substate_speaker_mean", names[4], "::kaldi::VectorBase<float> *", a[4]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSubstateSpeakerMean(std::move(arg1), std::move(arg2), std::move(arg3), *arg4, arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_substate_speaker_mean_double(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:DoubleVectorBase)
static PyObject* wrapGetSubstateSpeakerMean_as_get_substate_speaker_mean_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("j1"),
      C("substate"),
      C("gauss"),
      C("spk"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:get_substate_speaker_mean_double", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_substate_speaker_mean_double", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_substate_speaker_mean_double", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_substate_speaker_mean_double", names[2], "int", a[2]);
  ::kaldi::Sgmm2PerSpkDerivedVars* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_substate_speaker_mean_double", names[3], "::kaldi::Sgmm2PerSpkDerivedVars", a[3]);
  ::kaldi::VectorBase<double> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("get_substate_speaker_mean_double", names[4], "::kaldi::VectorBase<double> *", a[4]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSubstateSpeakerMean(std::move(arg1), std::move(arg2), std::move(arg3), *arg4, arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_var_scaled_substate_speaker_mean(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:VectorBase)
static PyObject* wrapGetVarScaledSubstateSpeakerMean_as_get_var_scaled_substate_speaker_mean(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("j1"),
      C("substate"),
      C("gauss"),
      C("spk"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:get_var_scaled_substate_speaker_mean", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_var_scaled_substate_speaker_mean", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_var_scaled_substate_speaker_mean", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_var_scaled_substate_speaker_mean", names[2], "int", a[2]);
  ::kaldi::Sgmm2PerSpkDerivedVars* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_var_scaled_substate_speaker_mean", names[3], "::kaldi::Sgmm2PerSpkDerivedVars", a[3]);
  ::kaldi::VectorBase<float> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("get_var_scaled_substate_speaker_mean", names[4], "::kaldi::VectorBase<float> *", a[4]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetVarScaledSubstateSpeakerMean(std::move(arg1), std::move(arg2), std::move(arg3), *arg4, arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_var_scaled_substate_speaker_mean_double(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:DoubleVectorBase)
static PyObject* wrapGetVarScaledSubstateSpeakerMean_as_get_var_scaled_substate_speaker_mean_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("j1"),
      C("substate"),
      C("gauss"),
      C("spk"),
      C("mean_out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:get_var_scaled_substate_speaker_mean_double", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_var_scaled_substate_speaker_mean_double", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_var_scaled_substate_speaker_mean_double", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_var_scaled_substate_speaker_mean_double", names[2], "int", a[2]);
  ::kaldi::Sgmm2PerSpkDerivedVars* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_var_scaled_substate_speaker_mean_double", names[3], "::kaldi::Sgmm2PerSpkDerivedVars", a[3]);
  ::kaldi::VectorBase<double> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("get_var_scaled_substate_speaker_mean_double", names[4], "::kaldi::VectorBase<double> *", a[4]);
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetVarScaledSubstateSpeakerMean(std::move(arg1), std::move(arg2), std::move(arg3), *arg4, arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compute_h() -> list<SpMatrix>
static PyObject* wrapComputeH_as_compute_h(PyObject* self) {
  ::std::vector< ::kaldi::SpMatrix<float> > ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeH(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compute_h_double() -> list<DoubleSpMatrix>
static PyObject* wrapComputeH_as_compute_h_double(PyObject* self) {
  ::std::vector< ::kaldi::SpMatrix<double> > ret0{};
  // Call actual C++ method.
  ::kaldi::AmSgmm2* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeH(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool, write_params:int)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool, unsigned short)")},
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_VARARGS | METH_KEYWORDS, C("check(show_properties:bool=default)\n\nChecks the various components for correct sizes. When the argument is set to true, dimensions of the various components is printed")},
  {C("initialize_from_full_gmm"), (PyCFunction)wrapInitializeFromFullGmm_as_initialize_from_full_gmm, METH_VARARGS | METH_KEYWORDS, C("initialize_from_full_gmm(gmm:FullGmm, pdf2group:list<int>, phn_subspace_dim:int, spk_subspace_dim:int, speaker_dependent_weights:bool, self_weight:float)\n\nInitializes the SGMM parameters from a full-covariance UBM. The state2group vector maps from a state to the corresponding cluster of states [i.e., j2 to j1]. For conventionally structured systems (no 2-level tree), this can just be [0 1 ... n-1 ]")},
  {C("copy_globals_init_vecs"), (PyCFunction)wrapCopyGlobalsInitVecs_as_copy_globals_init_vecs, METH_VARARGS | METH_KEYWORDS, C("copy_globals_init_vecs(other:AmSgmm2, pdf2group:list<int>, self_weight:float)\n\nCopies the global parameters from the supplied model, but sets the state vectors to zero.")},
  {C("copy_from_sgmm2"), (PyCFunction)wrapCopyFromSgmm2_as_copy_from_sgmm2, METH_VARARGS | METH_KEYWORDS, C("copy_from_sgmm2(other:AmSgmm2, copy_normalizers:bool, copy_weights:bool)\n\nCopies models")},
  {C("computer_per_frame_vars"), (PyCFunction)wrapComputePerFrameVars_as_computer_per_frame_vars, METH_VARARGS | METH_KEYWORDS, C("computer_per_frame_vars(data:Vector, gselect:list<int>, spk_vars:Sgmm2PerSpkDerivedVars) -> Sgmm2PerFrameDerivedVars\n  Calls C++ function\n  void ::kaldi::AmSgmm2::ComputePerFrameVars(::kaldi::Vector<float>, ::std::vector< ::int32>, ::kaldi::Sgmm2PerSpkDerivedVars, ::kaldi::Sgmm2PerFrameDerivedVars*)")},
  {C("compute_per_spk_derived_vars"), (PyCFunction)wrapComputePerSpkDerivedVars_as_compute_per_spk_derived_vars, METH_VARARGS | METH_KEYWORDS, C("compute_per_spk_derived_vars(vars:Sgmm2PerSpkDerivedVars)\n\nComputes the per-speaker derived vars; assumes vars->v_s is already set up.")},
  {C("loglikelihood"), (PyCFunction)wrapLogLikelihood_as_loglikelihood, METH_VARARGS | METH_KEYWORDS, C("loglikelihood(per_frame_vars:Sgmm2PerFrameDerivedVars, j2:int, cache:Sgmm2LikelihoodCache, spk_vars:Sgmm2PerSpkDerivedVars, log_prune:float=default) -> float\n\nThis does a log-likelihood computation for a given state using the pre-selected Gaussian components (in per_frame_vars). If the log_prune parameter is non-zero, the LogSumExp stage is prunes, which is a significant speedup")},
  {C("component_posteriors"), (PyCFunction)wrapComponentPosteriors_as_component_posteriors, METH_VARARGS | METH_KEYWORDS, C("component_posteriors(per_frame_vars:Sgmm2PerFrameDerivedVars, j2:int, spk_vars:Sgmm2PerSpkDerivedVars) -> (loglike:float, post:Matrix)\n\nSimilar to :meth:`loglikelihood` but also computes the posterior probabilities for the pre-selected Gaussian components and all substates.")},
  {C("split_substates"), (PyCFunction)wrapSplitSubstates_as_split_substates, METH_VARARGS | METH_KEYWORDS, C("split_substates(state_occupancies:Vector, config:Sgmm2SplitSubstatesConfig)\n\nIncreases the total number of substates based on the state occupancies")},
  {C("increase_phone_space_dim"), (PyCFunction)wrapIncreasePhoneSpaceDim_as_increase_phone_space_dim, METH_VARARGS | METH_KEYWORDS, C("increase_phone_space_dim(target_dim:int, norm_xform:Matrix)\n\nFunctions for increasing the phonetic and speaker space dimensions")},
  {C("increase_spk_space_dim"), (PyCFunction)wrapIncreaseSpkSpaceDim_as_increase_spk_space_dim, METH_VARARGS | METH_KEYWORDS, C("increase_spk_space_dim(target_dim:int, norm_xform:Matrix, speaker_dependent_weights:bool)\n\nIncrease the subspace dimensions for speakers. speaker_dependent_weights only makes a difference if increasing the subspace dimension from zero")},
  {C("compute_derived_vars"), (PyCFunction)wrapComputeDerivedVars_as_compute_derived_vars, METH_NOARGS, C("compute_derived_vars()\n\nComputes (and initializes if neccesary) derived vars")},
  {C("compute_normalizers"), (PyCFunction)wrapComputeNormalizers_as_compute_normalizers, METH_NOARGS, C("compute_normalizers()\n\nComputes the data-independent terms in the log-likelihood computation for each Gaussian component and all substates")},
  {C("compute_weights"), (PyCFunction)wrapComputeWeights_as_compute_weights, METH_NOARGS, C("compute_weights()\n\nComputes the weights w_jmi_, which is needed for loglikelihood evaluation")},
  {C("compute_fmllr_pre_xform"), (PyCFunction)wrapComputeFmllrPreXform_as_compute_fmllr_pre_xform, METH_VARARGS | METH_KEYWORDS, C("compute_fmllr_pre_xform(pdf_occs:Vector) -> (xform:Matrix, inv_xform:Matrix, diag_mean_scatter:Vector)\n\nComputes the LDA-like pre-transform and its inverse as well as the eigenvalues of the scatter of the means used in FMLLR estimation")},
  {C("num_pdfs"), (PyCFunction)wrapNumPdfs_as_num_pdfs, METH_NOARGS, C("num_pdfs() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::NumPdfs()")},
  {C("num_groups"), (PyCFunction)wrapNumGroups_as_num_groups, METH_NOARGS, C("num_groups() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::NumGroups()")},
  {C("pdf2group"), (PyCFunction)wrapPdf2Group_as_pdf2group, METH_VARARGS | METH_KEYWORDS, C("pdf2group(j2:int) -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::Pdf2Group(int)")},
  {C("num_substates_for_pdf"), (PyCFunction)wrapNumSubstatesForPdf_as_num_substates_for_pdf, METH_VARARGS | METH_KEYWORDS, C("num_substates_for_pdf(j2:int) -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::NumSubstatesForPdf(int)")},
  {C("num_substates_for_group"), (PyCFunction)wrapNumSubstatesForGroup_as_num_substates_for_group, METH_VARARGS | METH_KEYWORDS, C("num_substates_for_group(j1:int) -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::NumSubstatesForGroup(int)")},
  {C("num_gauss"), (PyCFunction)wrapNumGauss_as_num_gauss, METH_NOARGS, C("num_gauss() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::NumGauss()")},
  {C("phone_space_dim"), (PyCFunction)wrapPhoneSpaceDim_as_phone_space_dim, METH_NOARGS, C("phone_space_dim() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::PhoneSpaceDim()")},
  {C("spk_space_dim"), (PyCFunction)wrapSpkSpaceDim_as_spk_space_dim, METH_NOARGS, C("spk_space_dim() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::SpkSpaceDim()")},
  {C("feature_dim"), (PyCFunction)wrapFeatureDim_as_feature_dim, METH_NOARGS, C("feature_dim() -> int\n  Calls C++ function\n  int ::kaldi::AmSgmm2::FeatureDim()")},
  {C("has_speaker_dependent_weights"), (PyCFunction)wrapHasSpeakerDependentWeights_as_has_speaker_dependent_weights, METH_NOARGS, C("has_speaker_dependent_weights() -> bool\n\nTrue if doing SSGMM")},
  {C("has_speaker_space"), (PyCFunction)wrapHasSpeakerSpace_as_has_speaker_space, METH_NOARGS, C("has_speaker_space() -> bool\n  Calls C++ function\n  bool ::kaldi::AmSgmm2::HasSpeakerSpace()")},
  {C("remove_speaker_space"), (PyCFunction)wrapRemoveSpeakerSpace_as_remove_speaker_space, METH_NOARGS, C("remove_speaker_space()\n  Calls C++ function\n  void ::kaldi::AmSgmm2::RemoveSpeakerSpace()")},
  {C("get_djms"), (PyCFunction)wrapGetDjms_as_get_djms, METH_VARARGS | METH_KEYWORDS, C("get_djms(j1:int, m:int, spk_vars:Sgmm2PerSpkDerivedVars) -> float\n  Calls C++ function\n  float ::kaldi::AmSgmm2::GetDjms(int, int, ::kaldi::Sgmm2PerSpkDerivedVars *)")},
  {C("get_inv_covars"), (PyCFunction)wrapGetInvCovars_as_get_inv_covars, METH_VARARGS | METH_KEYWORDS, C("get_inv_covars(gauss_index:int) -> SpMatrix\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetInvCovars(int, ::kaldi::SpMatrix<float>*)")},
  {C("get_inv_covars_double"), (PyCFunction)wrapGetInvCovars_as_get_inv_covars_double, METH_VARARGS | METH_KEYWORDS, C("get_inv_covars_double(gauss_index:int) -> DoubleSpMatrix\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetInvCovars(int, ::kaldi::SpMatrix<double>*)")},
  {C("get_substate_mean"), (PyCFunction)wrapGetSubstateMean_as_get_substate_mean, METH_VARARGS | METH_KEYWORDS, C("get_substate_mean(j1:int, m:int, i:int, mean_out:VectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetSubstateMean(int, int, int, ::kaldi::VectorBase<float> *)")},
  {C("get_substate_mean_double"), (PyCFunction)wrapGetSubstateMean_as_get_substate_mean_double, METH_VARARGS | METH_KEYWORDS, C("get_substate_mean_double(j1:int, m:int, i:int, mean_out:DoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetSubstateMean(int, int, int, ::kaldi::VectorBase<double> *)")},
  {C("get_ntrans_sigma_inv"), (PyCFunction)wrapGetNtransSigmaInv_as_get_ntrans_sigma_inv, METH_NOARGS, C("get_ntrans_sigma_inv() -> list<Matrix>\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetNtransSigmaInv(::std::vector< ::kaldi::Matrix<float> >*)")},
  {C("get_ntrans_sigma_inv_double"), (PyCFunction)wrapGetNtransSigmaInv_as_get_ntrans_sigma_inv_double, METH_NOARGS, C("get_ntrans_sigma_inv_double() -> list<DoubleMatrix>\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetNtransSigmaInv(::std::vector< ::kaldi::Matrix<double> >*)")},
  {C("get_substate_speaker_mean"), (PyCFunction)wrapGetSubstateSpeakerMean_as_get_substate_speaker_mean, METH_VARARGS | METH_KEYWORDS, C("get_substate_speaker_mean(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:VectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetSubstateSpeakerMean(int, int, int, ::kaldi::Sgmm2PerSpkDerivedVars, ::kaldi::VectorBase<float> *)")},
  {C("get_substate_speaker_mean_double"), (PyCFunction)wrapGetSubstateSpeakerMean_as_get_substate_speaker_mean_double, METH_VARARGS | METH_KEYWORDS, C("get_substate_speaker_mean_double(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:DoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetSubstateSpeakerMean(int, int, int, ::kaldi::Sgmm2PerSpkDerivedVars, ::kaldi::VectorBase<double> *)")},
  {C("get_var_scaled_substate_speaker_mean"), (PyCFunction)wrapGetVarScaledSubstateSpeakerMean_as_get_var_scaled_substate_speaker_mean, METH_VARARGS | METH_KEYWORDS, C("get_var_scaled_substate_speaker_mean(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:VectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetVarScaledSubstateSpeakerMean(int, int, int, ::kaldi::Sgmm2PerSpkDerivedVars, ::kaldi::VectorBase<float> *)")},
  {C("get_var_scaled_substate_speaker_mean_double"), (PyCFunction)wrapGetVarScaledSubstateSpeakerMean_as_get_var_scaled_substate_speaker_mean_double, METH_VARARGS | METH_KEYWORDS, C("get_var_scaled_substate_speaker_mean_double(j1:int, substate:int, gauss:int, spk:Sgmm2PerSpkDerivedVars, mean_out:DoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::AmSgmm2::GetVarScaledSubstateSpeakerMean(int, int, int, ::kaldi::Sgmm2PerSpkDerivedVars, ::kaldi::VectorBase<double> *)")},
  {C("compute_h"), (PyCFunction)wrapComputeH_as_compute_h, METH_NOARGS, C("compute_h() -> list<SpMatrix>\n\nComputes :math:`M_i \\Sigma_i^{-1} M_i^T`")},
  {C("compute_h_double"), (PyCFunction)wrapComputeH_as_compute_h_double, METH_NOARGS, C("compute_h_double() -> list<DoubleSpMatrix>\n\nComputes :math:`M_i \\Sigma_i^{-1} M_i^T`")},
  {}
};

// AmSgmm2 __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// AmSgmm2 __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// AmSgmm2 __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.AmSgmm2",                 // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Class for definition of subspace Gmm acoustic model", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "AmSgmm2 takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::AmSgmm2>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::AmSgmm2* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_AmSgmm2"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::AmSgmm2"));
      if (!PyErr_Occurred()) {
        ::kaldi::AmSgmm2* c = static_cast<::kaldi::AmSgmm2*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::AmSgmm2*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyAmSgmm2

// compute_feature_normalizing_transform(gmm:FullGmm) -> Matrix
static PyObject* wrapComputeFeatureNormalizingTransform_as_compute_feature_normalizing_transform(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("gmm"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compute_feature_normalizing_transform", names, &a[0])) return nullptr;
  ::kaldi::FullGmm* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_feature_normalizing_transform", names[0], "::kaldi::FullGmm", a[0]);
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ComputeFeatureNormalizingTransform(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pySgmm2GauPostElement {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Sgmm2GauPostElement> cpp;
};
static ::kaldi::Sgmm2GauPostElement* ThisPtr(PyObject*);

static PyObject* get_gselect(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->gselect, {});
}

static int set_gselect(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the gselect attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->gselect)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for gselect:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_tids(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->tids, {});
}

static int set_tids(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the tids attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->tids)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for tids:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_posteriors(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->posteriors, {});
}

static int set_posteriors(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the posteriors attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->posteriors)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for posteriors:list<Matrix>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("gselect"), get_gselect, set_gselect, C("C++ ::std::vector< ::int32> Sgmm2GauPostElement.gselect")},
  {C("tids"), get_tids, set_tids, C("C++ ::std::vector< ::int32> Sgmm2GauPostElement.tids")},
  {C("posteriors"), get_posteriors, set_posteriors, C("C++ ::std::vector< ::kaldi::Matrix< ::kaldi::BaseFloat> > Sgmm2GauPostElement.posteriors")},
  {}
};

// Sgmm2GauPostElement __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Sgmm2GauPostElement __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Sgmm2GauPostElement __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_am_sgmm2.Sgmm2GauPostElement",     // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::Sgmm2GauPostElement", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Sgmm2GauPostElement takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Sgmm2GauPostElement>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Sgmm2GauPostElement* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Sgmm2GauPostElement"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Sgmm2GauPostElement"));
      if (!PyErr_Occurred()) {
        ::kaldi::Sgmm2GauPostElement* c = static_cast<::kaldi::Sgmm2GauPostElement*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Sgmm2GauPostElement*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySgmm2GauPostElement


// Initialize module

static PyMethodDef Methods[] = {
  {C("compute_feature_normalizing_transform"), (PyCFunction)wrapComputeFeatureNormalizingTransform_as_compute_feature_normalizing_transform, METH_VARARGS | METH_KEYWORDS, C("compute_feature_normalizing_transform(gmm:FullGmm) -> Matrix\n  Calls C++ function\n  void ::kaldi::ComputeFeatureNormalizingTransform(::kaldi::FullGmm, ::kaldi::Matrix<float>*)")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pySgmm2SplitSubstatesConfig::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2SplitSubstatesConfig::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2GselectConfig::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2GselectConfig::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2PerFrameDerivedVars::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2PerFrameDerivedVars::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2PerSpkDerivedVars::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2PerSpkDerivedVars::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2LikelihoodCache::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2LikelihoodCache::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyAmSgmm2::wrapper_Type) < 0) return false;
  Py_INCREF(&pyAmSgmm2::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySgmm2GauPostElement::wrapper_Type) < 0) return false;
  Py_INCREF(&pySgmm2GauPostElement::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_am_sgmm2",  // module name
  "CLIF-generated module for sgmm2/am-sgmm2.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sp_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_full_gmm")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_diag_gmm")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyDict_SetItemString(pySgmm2LikelihoodCache::wrapper_Type.tp_dict, "SubstateCacheElement", reinterpret_cast<PyObject*>(&pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pySgmm2LikelihoodCache::wrapper_Type.tp_dict, "PdfCacheElement", reinterpret_cast<PyObject*>(&pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2SplitSubstatesConfig", reinterpret_cast<PyObject*>(&pySgmm2SplitSubstatesConfig::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2GselectConfig", reinterpret_cast<PyObject*>(&pySgmm2GselectConfig::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2PerFrameDerivedVars", reinterpret_cast<PyObject*>(&pySgmm2PerFrameDerivedVars::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2PerSpkDerivedVars", reinterpret_cast<PyObject*>(&pySgmm2PerSpkDerivedVars::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2LikelihoodCache", reinterpret_cast<PyObject*>(&pySgmm2LikelihoodCache::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "AmSgmm2", reinterpret_cast<PyObject*>(&pyAmSgmm2::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Sgmm2GauPostElement", reinterpret_cast<PyObject*>(&pySgmm2GauPostElement::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __am__sgmm2_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// AmSgmm2 to/from ::kaldi::AmSgmm2 conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::AmSgmm2** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::AmSgmm2* cpp = __am__sgmm2_clifwrap::pyAmSgmm2::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::AmSgmm2>* c) {
  assert(c != nullptr);
  ::kaldi::AmSgmm2* cpp = __am__sgmm2_clifwrap::pyAmSgmm2::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pyAmSgmm2::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::AmSgmm2>* c) {
  assert(c != nullptr);
  ::kaldi::AmSgmm2* cpp = __am__sgmm2_clifwrap::pyAmSgmm2::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pyAmSgmm2::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert AmSgmm2 instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::AmSgmm2* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pyAmSgmm2::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pyAmSgmm2::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::AmSgmm2>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::AmSgmm2> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pyAmSgmm2::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pyAmSgmm2::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::AmSgmm2>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::AmSgmm2> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pyAmSgmm2::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pyAmSgmm2::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::AmSgmm2>(std::move(c));
  return py;
}

// Sgmm2GauPostElement to/from ::kaldi::Sgmm2GauPostElement conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2GauPostElement** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2GauPostElement* cpp = __am__sgmm2_clifwrap::pySgmm2GauPostElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2GauPostElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GauPostElement* cpp = __am__sgmm2_clifwrap::pySgmm2GauPostElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2GauPostElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GauPostElement* cpp = __am__sgmm2_clifwrap::pySgmm2GauPostElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2GauPostElement instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2GauPostElement* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GauPostElement* cpp = __am__sgmm2_clifwrap::pySgmm2GauPostElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2GauPostElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GauPostElement* cpp = __am__sgmm2_clifwrap::pySgmm2GauPostElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2GauPostElement* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GauPostElement>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2GauPostElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GauPostElement>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2GauPostElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GauPostElement>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2GauPostElement& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GauPostElement::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2GauPostElement>(c);
  return py;
}

// Sgmm2GselectConfig to/from ::kaldi::Sgmm2GselectConfig conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2GselectConfig** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2GselectConfig* cpp = __am__sgmm2_clifwrap::pySgmm2GselectConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2GselectConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GselectConfig* cpp = __am__sgmm2_clifwrap::pySgmm2GselectConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2GselectConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GselectConfig* cpp = __am__sgmm2_clifwrap::pySgmm2GselectConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2GselectConfig instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2GselectConfig* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GselectConfig* cpp = __am__sgmm2_clifwrap::pySgmm2GselectConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2GselectConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2GselectConfig* cpp = __am__sgmm2_clifwrap::pySgmm2GselectConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2GselectConfig* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GselectConfig>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2GselectConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GselectConfig>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2GselectConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2GselectConfig>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2GselectConfig& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2GselectConfig::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2GselectConfig>(c);
  return py;
}

// Sgmm2LikelihoodCache to/from ::kaldi::Sgmm2LikelihoodCache conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2LikelihoodCache* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2LikelihoodCache>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2LikelihoodCache>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2LikelihoodCache instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2LikelihoodCache>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2LikelihoodCache* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2LikelihoodCache> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2LikelihoodCache> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2LikelihoodCache& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache>(c);
  return py;
}

// Sgmm2LikelihoodCache.PdfCacheElement to/from ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2LikelihoodCache.PdfCacheElement instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2LikelihoodCache::PdfCacheElement* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2LikelihoodCache::PdfCacheElement& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pyPdfCacheElement::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache::PdfCacheElement>(c);
  return py;
}

// Sgmm2LikelihoodCache.SubstateCacheElement to/from ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2LikelihoodCache.SubstateCacheElement instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* cpp = __am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2LikelihoodCache::pySubstateCacheElement::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2LikelihoodCache::SubstateCacheElement>(c);
  return py;
}

// Sgmm2PerFrameDerivedVars to/from ::kaldi::Sgmm2PerFrameDerivedVars conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2PerFrameDerivedVars** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2PerFrameDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2PerFrameDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerFrameDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2PerFrameDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerFrameDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2PerFrameDerivedVars instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2PerFrameDerivedVars* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerFrameDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2PerFrameDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerFrameDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2PerFrameDerivedVars* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerFrameDerivedVars>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2PerFrameDerivedVars> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerFrameDerivedVars>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2PerFrameDerivedVars> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerFrameDerivedVars>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2PerFrameDerivedVars& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerFrameDerivedVars::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2PerFrameDerivedVars>(c);
  return py;
}

// Sgmm2PerSpkDerivedVars to/from ::kaldi::Sgmm2PerSpkDerivedVars conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2PerSpkDerivedVars** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2PerSpkDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2PerSpkDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerSpkDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2PerSpkDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerSpkDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2PerSpkDerivedVars instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2PerSpkDerivedVars* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerSpkDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2PerSpkDerivedVars>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2PerSpkDerivedVars* cpp = __am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2PerSpkDerivedVars* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerSpkDerivedVars>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2PerSpkDerivedVars> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerSpkDerivedVars>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2PerSpkDerivedVars> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2PerSpkDerivedVars>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2PerSpkDerivedVars& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2PerSpkDerivedVars::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2PerSpkDerivedVars>(c);
  return py;
}

// Sgmm2SplitSubstatesConfig to/from ::kaldi::Sgmm2SplitSubstatesConfig conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2SplitSubstatesConfig** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Sgmm2SplitSubstatesConfig* cpp = __am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Sgmm2SplitSubstatesConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2SplitSubstatesConfig* cpp = __am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Sgmm2SplitSubstatesConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2SplitSubstatesConfig* cpp = __am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Sgmm2SplitSubstatesConfig instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Sgmm2SplitSubstatesConfig* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2SplitSubstatesConfig* cpp = __am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Sgmm2SplitSubstatesConfig>* c) {
  assert(c != nullptr);
  ::kaldi::Sgmm2SplitSubstatesConfig* cpp = __am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Sgmm2SplitSubstatesConfig* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2SplitSubstatesConfig>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Sgmm2SplitSubstatesConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2SplitSubstatesConfig>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Sgmm2SplitSubstatesConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Sgmm2SplitSubstatesConfig>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Sgmm2SplitSubstatesConfig& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__am__sgmm2_clifwrap::pySgmm2SplitSubstatesConfig::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Sgmm2SplitSubstatesConfig>(c);
  return py;
}

}  // namespace kaldi
