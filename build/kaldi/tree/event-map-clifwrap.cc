//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/tree/event-map.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "event-map-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __event__map_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// make_event_pair(k:int, v:int) -> tuple<int, int>
static PyObject* wrapMakeEventPair_as_make_event_pair(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("k"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:make_event_pair", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("make_event_pair", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("make_event_pair", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::pair< ::kaldi::EventKeyType, ::kaldi::EventValueType> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::MakeEventPair(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_event_type(os:ostream, binary:bool, vec:list<tuple<int, int>>)
static PyObject* wrapWriteEventType_as_write_event_type(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("binary"),
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write_event_type", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_event_type", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_event_type", names[1], "bool", a[1]);
  ::kaldi::EventType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write_event_type", names[2], "::kaldi::EventType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::WriteEventType(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_event_type(is:istream, binary:bool) -> list<tuple<int, int>>
static PyObject* wrapReadEventType_as_read_event_type(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_event_type", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_event_type", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_event_type", names[1], "bool", a[1]);
  ::kaldi::EventType ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ReadEventType(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyEventMap {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::EventMap> cpp;
};
static ::kaldi::EventMap* ThisPtr(PyObject*);

// @classmethod check(event:list<tuple<int, int>>)
static PyObject* wrapCheck_as_check(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:check", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("check", names[0], "::kaldi::EventType", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::EventMap::Check(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod lookup(event:list<tuple<int, int>>, key:int) -> (success:bool, ans:int)
static PyObject* wrapLookup_as_lookup(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("event"),
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:lookup", names, &a[0], &a[1])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lookup", names[0], "::kaldi::EventType", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("lookup", names[1], "int", a[1]);
  int ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::EventMap::Lookup(std::move(arg1), std::move(arg2), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// map(event:list<tuple<int, int>>) -> (success:bool, ans:int)
static PyObject* wrapMap_as_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map", names[0], "::kaldi::EventType", a[0]);
  int ret1{};
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Map(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// multi_map(event:list<tuple<int, int>>) -> list<int>
static PyObject* wrapMultiMap_as_multi_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:multi_map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("multi_map", names[0], "::kaldi::EventType", a[0]);
  ::std::vector< ::kaldi::EventAnswerType> ret0{};
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MultiMap(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_children() -> list<EventMap>
static PyObject* wrapGetChildren_as_get_children(PyObject* self) {
  ::std::vector< ::kaldi::EventMap *> ret0{};
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetChildren(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap
static PyObject* wrapCopy_as_copy_with_new_leaves(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("new_leaves"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_with_new_leaves", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::EventMap *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_with_new_leaves", names[0], "::std::vector< ::kaldi::EventMap *>", a[0]);
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> EventMap
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap
static PyObject* wrapMapValues_as_map_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("keys_to_map"),
      C("value_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:map_values", names, &a[0], &a[1])) return nullptr;
  ::std::unordered_set< ::kaldi::EventKeyType> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_values", names[0], "::std::unordered_set< ::kaldi::EventKeyType>", a[0]);
  ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map_values", names[1], "::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>", a[1]);
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapValues(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prune() -> EventMap
static PyObject* wrapPrune_as_prune(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Prune();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max_result() -> int
static PyObject* wrapMaxResult_as_max_result(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MaxResult();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_to_stream(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write_to_stream(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_to_stream", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_to_stream", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_to_stream", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::EventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod write_event_map(os:ostream, binary:bool, emap:EventMap)
static PyObject* wrapWrite_as_write_event_map(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("binary"),
      C("emap"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write_event_map", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_event_map", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_event_map", names[1], "bool", a[1]);
  ::kaldi::EventMap * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write_event_map", names[2], "::kaldi::EventMap *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::EventMap::Write(*arg1, std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod read_event_map(is:istream, binary:bool) -> EventMap
static PyObject* wrapRead_as_read_event_map(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_event_map", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_event_map", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_event_map", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::EventMap::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("check(event:list<tuple<int, int>>)\n  Calls C++ function\n  void ::kaldi::EventMap::Check(::kaldi::EventType)")},
  {C("lookup"), (PyCFunction)wrapLookup_as_lookup, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("lookup(event:list<tuple<int, int>>, key:int) -> (success:bool, ans:int)\n  Calls C++ function\n  bool ::kaldi::EventMap::Lookup(::kaldi::EventType, int, int*)")},
  {C("map"), (PyCFunction)wrapMap_as_map, METH_VARARGS | METH_KEYWORDS, C("map(event:list<tuple<int, int>>) -> (success:bool, ans:int)\n  Calls C++ function\n  bool ::kaldi::EventMap::Map(::kaldi::EventType, int*)")},
  {C("multi_map"), (PyCFunction)wrapMultiMap_as_multi_map, METH_VARARGS | METH_KEYWORDS, C("multi_map(event:list<tuple<int, int>>) -> list<int>\n  Calls C++ function\n  void ::kaldi::EventMap::MultiMap(::kaldi::EventType, ::std::vector< ::kaldi::EventAnswerType>*)")},
  {C("get_children"), (PyCFunction)wrapGetChildren_as_get_children, METH_NOARGS, C("get_children() -> list<EventMap>\n  Calls C++ function\n  void ::kaldi::EventMap::GetChildren(::std::vector< ::kaldi::EventMap *>*)")},
  {C("copy_with_new_leaves"), (PyCFunction)wrapCopy_as_copy_with_new_leaves, METH_VARARGS | METH_KEYWORDS, C("copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::EventMap::Copy(::std::vector< ::kaldi::EventMap *>)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::EventMap::Copy()")},
  {C("map_values"), (PyCFunction)wrapMapValues_as_map_values, METH_VARARGS | METH_KEYWORDS, C("map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::EventMap::MapValues(::std::unordered_set< ::kaldi::EventKeyType>, ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>)")},
  {C("prune"), (PyCFunction)wrapPrune_as_prune, METH_NOARGS, C("prune() -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::EventMap::Prune()")},
  {C("max_result"), (PyCFunction)wrapMaxResult_as_max_result, METH_NOARGS, C("max_result() -> int\n  Calls C++ function\n  int ::kaldi::EventMap::MaxResult()")},
  {C("write_to_stream"), (PyCFunction)wrapWrite_as_write_to_stream, METH_VARARGS | METH_KEYWORDS, C("write_to_stream(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::EventMap::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("write_event_map"), (PyCFunction)wrapWrite_as_write_event_map, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("write_event_map(os:ostream, binary:bool, emap:EventMap)\n  Calls C++ function\n  void ::kaldi::EventMap::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool, ::kaldi::EventMap *)")},
  {C("read_event_map"), (PyCFunction)wrapRead_as_read_event_map, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read_event_map(is:istream, binary:bool) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::EventMap::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// EventMap __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// EventMap __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_event_map.EventMap",               // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::EventMap", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::EventMap* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_EventMap"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::EventMap"));
      if (!PyErr_Occurred()) {
        ::kaldi::EventMap* c = static_cast<::kaldi::EventMap*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::EventMap*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyEventMap

namespace pyConstantEventMap {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::ConstantEventMap> cpp;
};
static ::kaldi::ConstantEventMap* ThisPtr(PyObject*);

// __init__(answer:int)
static PyObject* wrapConstantEventMap_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("answer"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::ConstantEventMap>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map(event:list<tuple<int, int>>) -> (success:bool, ans:int)
static PyObject* wrapMap_as_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map", names[0], "::kaldi::EventType", a[0]);
  int ret1{};
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Map(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// multi_map(event:list<tuple<int, int>>) -> list<int>
static PyObject* wrapMultiMap_as_multi_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:multi_map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("multi_map", names[0], "::kaldi::EventType", a[0]);
  ::std::vector< ::kaldi::EventAnswerType> ret0{};
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MultiMap(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_children() -> list<EventMap>
static PyObject* wrapGetChildren_as_get_children(PyObject* self) {
  ::std::vector< ::kaldi::EventMap *> ret0{};
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetChildren(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap
static PyObject* wrapCopy_as_copy_with_new_leaves(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("new_leaves"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_with_new_leaves", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::EventMap *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_with_new_leaves", names[0], "::std::vector< ::kaldi::EventMap *>", a[0]);
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap
static PyObject* wrapMapValues_as_map_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("keys_to_map"),
      C("value_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:map_values", names, &a[0], &a[1])) return nullptr;
  ::std::unordered_set< ::kaldi::EventKeyType> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_values", names[0], "::std::unordered_set< ::kaldi::EventKeyType>", a[0]);
  ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map_values", names[1], "::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>", a[1]);
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapValues(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prune() -> EventMap
static PyObject* wrapPrune_as_prune(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Prune();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::ConstantEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod read(is:istream, binary:bool) -> ConstantEventMap
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::kaldi::ConstantEventMap *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ConstantEventMap::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// Implicit cast this as ::kaldi::EventMap*
static PyObject* as_kaldi_EventMap(PyObject* self) {
  ::kaldi::EventMap* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::EventMap"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapConstantEventMap_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(answer:int)\n  Calls C++ function\n  void ::kaldi::ConstantEventMap::ConstantEventMap(int)")},
  {C("map"), (PyCFunction)wrapMap_as_map, METH_VARARGS | METH_KEYWORDS, C("map(event:list<tuple<int, int>>) -> (success:bool, ans:int)\n  Calls C++ function\n  bool ::kaldi::ConstantEventMap::Map(::kaldi::EventType, int*)")},
  {C("multi_map"), (PyCFunction)wrapMultiMap_as_multi_map, METH_VARARGS | METH_KEYWORDS, C("multi_map(event:list<tuple<int, int>>) -> list<int>\n  Calls C++ function\n  void ::kaldi::ConstantEventMap::MultiMap(::kaldi::EventType, ::std::vector< ::kaldi::EventAnswerType>*)")},
  {C("get_children"), (PyCFunction)wrapGetChildren_as_get_children, METH_NOARGS, C("get_children() -> list<EventMap>\n  Calls C++ function\n  void ::kaldi::ConstantEventMap::GetChildren(::std::vector< ::kaldi::EventMap *>*)")},
  {C("copy_with_new_leaves"), (PyCFunction)wrapCopy_as_copy_with_new_leaves, METH_VARARGS | METH_KEYWORDS, C("copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::ConstantEventMap::Copy(::std::vector< ::kaldi::EventMap *>)")},
  {C("map_values"), (PyCFunction)wrapMapValues_as_map_values, METH_VARARGS | METH_KEYWORDS, C("map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::ConstantEventMap::MapValues(::std::unordered_set< ::kaldi::EventKeyType>, ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>)")},
  {C("prune"), (PyCFunction)wrapPrune_as_prune, METH_NOARGS, C("prune() -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::ConstantEventMap::Prune()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::ConstantEventMap::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(is:istream, binary:bool) -> ConstantEventMap\n  Calls C++ function\n  ::kaldi::ConstantEventMap * ::kaldi::ConstantEventMap::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_EventMap"), (PyCFunction)as_kaldi_EventMap, METH_NOARGS, C("Upcast to ::kaldi::EventMap*")},
  {}
};

// ConstantEventMap __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ConstantEventMap __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ConstantEventMap __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_event_map.ConstantEventMap",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::ConstantEventMap", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapConstantEventMap_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::ConstantEventMap* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_ConstantEventMap"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::ConstantEventMap"));
      if (!PyErr_Occurred()) {
        ::kaldi::ConstantEventMap* c = static_cast<::kaldi::ConstantEventMap*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::ConstantEventMap*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyConstantEventMap

namespace pyTableEventMap {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableEventMap> cpp;
};
static ::kaldi::TableEventMap* ThisPtr(PyObject*);

// __init__(key:int, table:list<EventMap>)
static PyObject* wrapTableEventMap_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("table"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  ::std::vector< ::kaldi::EventMap *> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::std::vector< ::kaldi::EventMap *>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableEventMap>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_val_map_table(key:int, map_in:dict<int, EventMap>) -> TableEventMap
static PyObject* wrapTableEventMap_as_from_val_map_table(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("map_in"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_val_map_table", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_val_map_table", names[0], "int", a[0]);
  ::std::map< ::kaldi::EventValueType, ::kaldi::EventMap *> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_val_map_table", names[1], "::std::map< ::kaldi::EventValueType, ::kaldi::EventMap *>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::TableEventMap> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::TableEventMap>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_val_answer_table(key:int, map_in:dict<int, int>) -> TableEventMap
static PyObject* wrapTableEventMap_as_from_val_answer_table(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("map_in"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_val_answer_table", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_val_answer_table", names[0], "int", a[0]);
  ::std::map< ::kaldi::EventValueType, ::kaldi::EventAnswerType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_val_answer_table", names[1], "::std::map< ::kaldi::EventValueType, ::kaldi::EventAnswerType>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::TableEventMap> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::TableEventMap>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// map(event:list<tuple<int, int>>) -> (success:bool, ans:int)
static PyObject* wrapMap_as_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map", names[0], "::kaldi::EventType", a[0]);
  int ret1{};
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Map(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// multi_map(event:list<tuple<int, int>>) -> list<int>
static PyObject* wrapMultiMap_as_multi_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:multi_map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("multi_map", names[0], "::kaldi::EventType", a[0]);
  ::std::vector< ::kaldi::EventAnswerType> ret0{};
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MultiMap(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_children() -> list<EventMap>
static PyObject* wrapGetChildren_as_get_children(PyObject* self) {
  ::std::vector< ::kaldi::EventMap *> ret0{};
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetChildren(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap
static PyObject* wrapCopy_as_copy_with_new_leaves(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("new_leaves"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_with_new_leaves", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::EventMap *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_with_new_leaves", names[0], "::std::vector< ::kaldi::EventMap *>", a[0]);
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap
static PyObject* wrapMapValues_as_map_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("keys_to_map"),
      C("value_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:map_values", names, &a[0], &a[1])) return nullptr;
  ::std::unordered_set< ::kaldi::EventKeyType> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_values", names[0], "::std::unordered_set< ::kaldi::EventKeyType>", a[0]);
  ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map_values", names[1], "::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>", a[1]);
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapValues(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prune() -> EventMap
static PyObject* wrapPrune_as_prune(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Prune();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::TableEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod read(is:istream, binary:bool) -> TableEventMap
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::kaldi::TableEventMap *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TableEventMap::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// Implicit cast this as ::kaldi::EventMap*
static PyObject* as_kaldi_EventMap(PyObject* self) {
  ::kaldi::EventMap* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::EventMap"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTableEventMap_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(key:int, table:list<EventMap>)\n  Calls C++ function\n  void ::kaldi::TableEventMap::TableEventMap(int, ::std::vector< ::kaldi::EventMap *>)")},
  {C("from_val_map_table"), (PyCFunction)wrapTableEventMap_as_from_val_map_table, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_val_map_table(key:int, map_in:dict<int, EventMap>) -> TableEventMap\n  Calls C++ function\n  std::unique_ptr<::kaldi::TableEventMap> ::kaldi::TableEventMap::TableEventMap(int, ::std::map< ::kaldi::EventValueType, ::kaldi::EventMap *>)")},
  {C("from_val_answer_table"), (PyCFunction)wrapTableEventMap_as_from_val_answer_table, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_val_answer_table(key:int, map_in:dict<int, int>) -> TableEventMap\n  Calls C++ function\n  std::unique_ptr<::kaldi::TableEventMap> ::kaldi::TableEventMap::TableEventMap(int, ::std::map< ::kaldi::EventValueType, ::kaldi::EventAnswerType>)")},
  {C("map"), (PyCFunction)wrapMap_as_map, METH_VARARGS | METH_KEYWORDS, C("map(event:list<tuple<int, int>>) -> (success:bool, ans:int)\n  Calls C++ function\n  bool ::kaldi::TableEventMap::Map(::kaldi::EventType, int*)")},
  {C("multi_map"), (PyCFunction)wrapMultiMap_as_multi_map, METH_VARARGS | METH_KEYWORDS, C("multi_map(event:list<tuple<int, int>>) -> list<int>\n  Calls C++ function\n  void ::kaldi::TableEventMap::MultiMap(::kaldi::EventType, ::std::vector< ::kaldi::EventAnswerType>*)")},
  {C("get_children"), (PyCFunction)wrapGetChildren_as_get_children, METH_NOARGS, C("get_children() -> list<EventMap>\n  Calls C++ function\n  void ::kaldi::TableEventMap::GetChildren(::std::vector< ::kaldi::EventMap *>*)")},
  {C("copy_with_new_leaves"), (PyCFunction)wrapCopy_as_copy_with_new_leaves, METH_VARARGS | METH_KEYWORDS, C("copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::TableEventMap::Copy(::std::vector< ::kaldi::EventMap *>)")},
  {C("map_values"), (PyCFunction)wrapMapValues_as_map_values, METH_VARARGS | METH_KEYWORDS, C("map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::TableEventMap::MapValues(::std::unordered_set< ::kaldi::EventKeyType>, ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>)")},
  {C("prune"), (PyCFunction)wrapPrune_as_prune, METH_NOARGS, C("prune() -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::TableEventMap::Prune()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::TableEventMap::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(is:istream, binary:bool) -> TableEventMap\n  Calls C++ function\n  ::kaldi::TableEventMap * ::kaldi::TableEventMap::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_EventMap"), (PyCFunction)as_kaldi_EventMap, METH_NOARGS, C("Upcast to ::kaldi::EventMap*")},
  {}
};

// TableEventMap __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// TableEventMap __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// TableEventMap __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_event_map.TableEventMap",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableEventMap", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTableEventMap_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableEventMap* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableEventMap"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableEventMap"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableEventMap* c = static_cast<::kaldi::TableEventMap*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableEventMap*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTableEventMap

namespace pySplitEventMap {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SplitEventMap> cpp;
};
static ::kaldi::SplitEventMap* ThisPtr(PyObject*);

// __init__(key:int, yes_set:list<int>, yes:EventMap, no:EventMap)
static PyObject* wrapSplitEventMap_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("key"),
      C("yes_set"),
      C("yes"),
      C("no"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:__init__", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  ::std::vector< ::kaldi::EventValueType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::std::vector< ::kaldi::EventValueType>", a[1]);
  ::kaldi::EventMap * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "::kaldi::EventMap *", a[2]);
  ::kaldi::EventMap * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("__init__", names[3], "::kaldi::EventMap *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SplitEventMap>(std::move(arg1), std::move(arg2), arg3, arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map(event:list<tuple<int, int>>) -> (success:bool, ans:int)
static PyObject* wrapMap_as_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map", names[0], "::kaldi::EventType", a[0]);
  int ret1{};
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Map(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// multi_map(event:list<tuple<int, int>>) -> list<int>
static PyObject* wrapMultiMap_as_multi_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("event"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:multi_map", names, &a[0])) return nullptr;
  ::kaldi::EventType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("multi_map", names[0], "::kaldi::EventType", a[0]);
  ::std::vector< ::kaldi::EventAnswerType> ret0{};
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MultiMap(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_children() -> list<EventMap>
static PyObject* wrapGetChildren_as_get_children(PyObject* self) {
  ::std::vector< ::kaldi::EventMap *> ret0{};
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetChildren(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap
static PyObject* wrapCopy_as_copy_with_new_leaves(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("new_leaves"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_with_new_leaves", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::EventMap *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_with_new_leaves", names[0], "::std::vector< ::kaldi::EventMap *>", a[0]);
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap
static PyObject* wrapMapValues_as_map_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("keys_to_map"),
      C("value_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:map_values", names, &a[0], &a[1])) return nullptr;
  ::std::unordered_set< ::kaldi::EventKeyType> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_values", names[0], "::std::unordered_set< ::kaldi::EventKeyType>", a[0]);
  ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map_values", names[1], "::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>", a[1]);
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapValues(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prune() -> EventMap
static PyObject* wrapPrune_as_prune(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Prune();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SplitEventMap* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod read(is:istream, binary:bool) -> SplitEventMap
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::kaldi::SplitEventMap *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SplitEventMap::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// Implicit cast this as ::kaldi::EventMap*
static PyObject* as_kaldi_EventMap(PyObject* self) {
  ::kaldi::EventMap* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::EventMap"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSplitEventMap_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(key:int, yes_set:list<int>, yes:EventMap, no:EventMap)\n  Calls C++ function\n  void ::kaldi::SplitEventMap::SplitEventMap(int, ::std::vector< ::kaldi::EventValueType>, ::kaldi::EventMap *, ::kaldi::EventMap *)")},
  {C("map"), (PyCFunction)wrapMap_as_map, METH_VARARGS | METH_KEYWORDS, C("map(event:list<tuple<int, int>>) -> (success:bool, ans:int)\n  Calls C++ function\n  bool ::kaldi::SplitEventMap::Map(::kaldi::EventType, int*)")},
  {C("multi_map"), (PyCFunction)wrapMultiMap_as_multi_map, METH_VARARGS | METH_KEYWORDS, C("multi_map(event:list<tuple<int, int>>) -> list<int>\n  Calls C++ function\n  void ::kaldi::SplitEventMap::MultiMap(::kaldi::EventType, ::std::vector< ::kaldi::EventAnswerType>*)")},
  {C("get_children"), (PyCFunction)wrapGetChildren_as_get_children, METH_NOARGS, C("get_children() -> list<EventMap>\n  Calls C++ function\n  void ::kaldi::SplitEventMap::GetChildren(::std::vector< ::kaldi::EventMap *>*)")},
  {C("copy_with_new_leaves"), (PyCFunction)wrapCopy_as_copy_with_new_leaves, METH_VARARGS | METH_KEYWORDS, C("copy_with_new_leaves(new_leaves:list<EventMap>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::SplitEventMap::Copy(::std::vector< ::kaldi::EventMap *>)")},
  {C("map_values"), (PyCFunction)wrapMapValues_as_map_values, METH_VARARGS | METH_KEYWORDS, C("map_values(keys_to_map:set<int>, value_map:dict<int, int>) -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::SplitEventMap::MapValues(::std::unordered_set< ::kaldi::EventKeyType>, ::std::unordered_map< ::kaldi::EventValueType, ::kaldi::EventValueType>)")},
  {C("prune"), (PyCFunction)wrapPrune_as_prune, METH_NOARGS, C("prune() -> EventMap\n  Calls C++ function\n  ::kaldi::EventMap * ::kaldi::SplitEventMap::Prune()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::SplitEventMap::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(is:istream, binary:bool) -> SplitEventMap\n  Calls C++ function\n  ::kaldi::SplitEventMap * ::kaldi::SplitEventMap::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_EventMap"), (PyCFunction)as_kaldi_EventMap, METH_NOARGS, C("Upcast to ::kaldi::EventMap*")},
  {}
};

// SplitEventMap __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SplitEventMap __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SplitEventMap __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_event_map.SplitEventMap",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SplitEventMap", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSplitEventMap_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SplitEventMap* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SplitEventMap"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SplitEventMap"));
      if (!PyErr_Occurred()) {
        ::kaldi::SplitEventMap* c = static_cast<::kaldi::SplitEventMap*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SplitEventMap*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySplitEventMap

// get_tree_structure(map:EventMap) -> (has_tree_structure:bool, num_leaves:int, parents:list<int>)
static PyObject* wrapGetTreeStructure_as_get_tree_structure(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_tree_structure", names, &a[0])) return nullptr;
  ::kaldi::EventMap* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_tree_structure", names[0], "::kaldi::EventMap", a[0]);
  int ret1{};
  ::std::vector< ::int32> ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::GetTreeStructure(*arg1, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("make_event_pair"), (PyCFunction)wrapMakeEventPair_as_make_event_pair, METH_VARARGS | METH_KEYWORDS, C("make_event_pair(k:int, v:int) -> tuple<int, int>\n  Calls C++ function\n  ::std::pair< ::kaldi::EventKeyType, ::kaldi::EventValueType> ::kaldi::MakeEventPair(int, int)")},
  {C("write_event_type"), (PyCFunction)wrapWriteEventType_as_write_event_type, METH_VARARGS | METH_KEYWORDS, C("write_event_type(os:ostream, binary:bool, vec:list<tuple<int, int>>)\n  Calls C++ function\n  void ::kaldi::WriteEventType(::std::basic_ostream<char, ::std::char_traits<char> >, bool, ::kaldi::EventType)")},
  {C("read_event_type"), (PyCFunction)wrapReadEventType_as_read_event_type, METH_VARARGS | METH_KEYWORDS, C("read_event_type(is:istream, binary:bool) -> list<tuple<int, int>>\n  Calls C++ function\n  void ::kaldi::ReadEventType(::std::basic_istream<char, ::std::char_traits<char> >, bool, ::kaldi::EventType*)")},
  {C("get_tree_structure"), (PyCFunction)wrapGetTreeStructure_as_get_tree_structure, METH_VARARGS | METH_KEYWORDS, C("get_tree_structure(map:EventMap) -> (has_tree_structure:bool, num_leaves:int, parents:list<int>)\n  Calls C++ function\n  bool ::kaldi::GetTreeStructure(::kaldi::EventMap, int*, ::std::vector< ::int32>*)")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyEventMap::wrapper_Type) < 0) return false;
  Py_INCREF(&pyEventMap::wrapper_Type);  // For PyModule_AddObject to steal.
  pyConstantEventMap::wrapper_Type.tp_base = &pyEventMap::wrapper_Type;
  if (PyType_Ready(&pyConstantEventMap::wrapper_Type) < 0) return false;
  Py_INCREF(&pyConstantEventMap::wrapper_Type);  // For PyModule_AddObject to steal.
  pyTableEventMap::wrapper_Type.tp_base = &pyEventMap::wrapper_Type;
  if (PyType_Ready(&pyTableEventMap::wrapper_Type) < 0) return false;
  Py_INCREF(&pyTableEventMap::wrapper_Type);  // For PyModule_AddObject to steal.
  pySplitEventMap::wrapper_Type.tp_base = &pyEventMap::wrapper_Type;
  if (PyType_Ready(&pySplitEventMap::wrapper_Type) < 0) return false;
  Py_INCREF(&pySplitEventMap::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_event_map",  // module name
  "CLIF-generated module for tree/event-map.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "EventMap", reinterpret_cast<PyObject*>(&pyEventMap::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ConstantEventMap", reinterpret_cast<PyObject*>(&pyConstantEventMap::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "TableEventMap", reinterpret_cast<PyObject*>(&pyTableEventMap::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SplitEventMap", reinterpret_cast<PyObject*>(&pySplitEventMap::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __event__map_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// ConstantEventMap to/from ::kaldi::ConstantEventMap conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::ConstantEventMap** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::ConstantEventMap* cpp = __event__map_clifwrap::pyConstantEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::ConstantEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::ConstantEventMap* cpp = __event__map_clifwrap::pyConstantEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__event__map_clifwrap::pyConstantEventMap::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::ConstantEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::ConstantEventMap* cpp = __event__map_clifwrap::pyConstantEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__event__map_clifwrap::pyConstantEventMap::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ConstantEventMap instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::ConstantEventMap* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyConstantEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyConstantEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::ConstantEventMap>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::ConstantEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyConstantEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyConstantEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::ConstantEventMap>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::ConstantEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyConstantEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyConstantEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::ConstantEventMap>(std::move(c));
  return py;
}

// EventMap to/from ::kaldi::EventMap conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::EventMap** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::EventMap* cpp = __event__map_clifwrap::pyEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::EventMap>* c) {
  assert(c != nullptr);
  ::kaldi::EventMap* cpp = __event__map_clifwrap::pyEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__event__map_clifwrap::pyEventMap::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::EventMap>* c) {
  assert(c != nullptr);
  ::kaldi::EventMap* cpp = __event__map_clifwrap::pyEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__event__map_clifwrap::pyEventMap::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert EventMap instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::EventMap* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::EventMap>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::EventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::EventMap>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::EventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::EventMap>(std::move(c));
  return py;
}

// SplitEventMap to/from ::kaldi::SplitEventMap conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SplitEventMap** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SplitEventMap* cpp = __event__map_clifwrap::pySplitEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SplitEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::SplitEventMap* cpp = __event__map_clifwrap::pySplitEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__event__map_clifwrap::pySplitEventMap::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SplitEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::SplitEventMap* cpp = __event__map_clifwrap::pySplitEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__event__map_clifwrap::pySplitEventMap::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SplitEventMap instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SplitEventMap* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pySplitEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pySplitEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SplitEventMap>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SplitEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pySplitEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pySplitEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SplitEventMap>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SplitEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pySplitEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pySplitEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SplitEventMap>(std::move(c));
  return py;
}

// TableEventMap to/from ::kaldi::TableEventMap conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableEventMap** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableEventMap* cpp = __event__map_clifwrap::pyTableEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::TableEventMap* cpp = __event__map_clifwrap::pyTableEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__event__map_clifwrap::pyTableEventMap::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableEventMap>* c) {
  assert(c != nullptr);
  ::kaldi::TableEventMap* cpp = __event__map_clifwrap::pyTableEventMap::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__event__map_clifwrap::pyTableEventMap::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert TableEventMap instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableEventMap* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyTableEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyTableEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableEventMap>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyTableEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyTableEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableEventMap>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableEventMap> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__event__map_clifwrap::pyTableEventMap::wrapper_Type, NULL, NULL);
  reinterpret_cast<__event__map_clifwrap::pyTableEventMap::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableEventMap>(std::move(c));
  return py;
}

}  // namespace kaldi
