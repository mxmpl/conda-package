//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/nnet3/nnet-optimize.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "itf/options-itf-clifwrap.h"
#include "base/iostream-clifwrap.h"
#include "nnet3/nnet-computation-clifwrap.h"
#include "nnet3/nnet-nnet-clifwrap.h"
#include "nnet-optimize-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __nnet__optimize_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyNnetOptimizeOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetOptimizeOptions> cpp;
};
static ::kaldi::nnet3::NnetOptimizeOptions* ThisPtr(PyObject*);

static PyObject* get_optimize(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->optimize, {});
}

static int set_optimize(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the optimize attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->optimize)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for optimize:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_consolidate_model_update(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->consolidate_model_update, {});
}

static int set_consolidate_model_update(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the consolidate_model_update attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->consolidate_model_update)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for consolidate_model_update:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_propagate_in_place(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->propagate_in_place, {});
}

static int set_propagate_in_place(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the propagate_in_place attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->propagate_in_place)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for propagate_in_place:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_backprop_in_place(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->backprop_in_place, {});
}

static int set_backprop_in_place(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the backprop_in_place attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->backprop_in_place)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for backprop_in_place:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_optimize_row_ops(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->optimize_row_ops, {});
}

static int set_optimize_row_ops(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the optimize_row_ops attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->optimize_row_ops)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for optimize_row_ops:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_extend_matrices(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->extend_matrices, {});
}

static int set_extend_matrices(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the extend_matrices attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->extend_matrices)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for extend_matrices:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_convert_addition(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->convert_addition, {});
}

static int set_convert_addition(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the convert_addition attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->convert_addition)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for convert_addition:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_remove_assignments(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->remove_assignments, {});
}

static int set_remove_assignments(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the remove_assignments attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->remove_assignments)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for remove_assignments:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_allow_left_merge(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->allow_left_merge, {});
}

static int set_allow_left_merge(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the allow_left_merge attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->allow_left_merge)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for allow_left_merge:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_allow_right_merge(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->allow_right_merge, {});
}

static int set_allow_right_merge(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the allow_right_merge attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->allow_right_merge)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for allow_right_merge:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_initialize_undefined(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->initialize_undefined, {});
}

static int set_initialize_undefined(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the initialize_undefined attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->initialize_undefined)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for initialize_undefined:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_move_sizing_commands(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->move_sizing_commands, {});
}

static int set_move_sizing_commands(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the move_sizing_commands attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->move_sizing_commands)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for move_sizing_commands:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_allocate_from_other(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->allocate_from_other, {});
}

static int set_allocate_from_other(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the allocate_from_other attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->allocate_from_other)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for allocate_from_other:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_min_deriv_time(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->min_deriv_time, {});
}

static int set_min_deriv_time(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the min_deriv_time attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->min_deriv_time)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for min_deriv_time:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_deriv_time(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_deriv_time, {});
}

static int set_max_deriv_time(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_deriv_time attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_deriv_time)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_deriv_time:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_deriv_time_relative(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_deriv_time_relative, {});
}

static int set_max_deriv_time_relative(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_deriv_time_relative attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_deriv_time_relative)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_deriv_time_relative:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_snip_row_ops(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->snip_row_ops, {});
}

static int set_snip_row_ops(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the snip_row_ops attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->snip_row_ops)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for snip_row_ops:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_memory_compression_level(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->memory_compression_level, {});
}

static int set_memory_compression_level(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the memory_compression_level attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->memory_compression_level)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for memory_compression_level:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_optimize_looped_computation(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->optimize_looped_computation, {});
}

static int set_optimize_looped_computation(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the optimize_looped_computation attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->optimize_looped_computation)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for optimize_looped_computation:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetOptimizeOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetOptimizeOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetOptimizeOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// __eq__(other:NnetOptimizeOptions) -> bool
static PyObject* wrap__eq__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__eq__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NnetOptimizeOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__eq__", names[0], "::kaldi::nnet3::NnetOptimizeOptions", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetOptimizeOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator==(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("optimize"), get_optimize, set_optimize, C("C++ bool NnetOptimizeOptions.optimize")},
  {C("consolidate_model_update"), get_consolidate_model_update, set_consolidate_model_update, C("C++ bool NnetOptimizeOptions.consolidate_model_update")},
  {C("propagate_in_place"), get_propagate_in_place, set_propagate_in_place, C("C++ bool NnetOptimizeOptions.propagate_in_place")},
  {C("backprop_in_place"), get_backprop_in_place, set_backprop_in_place, C("C++ bool NnetOptimizeOptions.backprop_in_place")},
  {C("optimize_row_ops"), get_optimize_row_ops, set_optimize_row_ops, C("C++ bool NnetOptimizeOptions.optimize_row_ops")},
  {C("extend_matrices"), get_extend_matrices, set_extend_matrices, C("C++ bool NnetOptimizeOptions.extend_matrices")},
  {C("convert_addition"), get_convert_addition, set_convert_addition, C("C++ bool NnetOptimizeOptions.convert_addition")},
  {C("remove_assignments"), get_remove_assignments, set_remove_assignments, C("C++ bool NnetOptimizeOptions.remove_assignments")},
  {C("allow_left_merge"), get_allow_left_merge, set_allow_left_merge, C("C++ bool NnetOptimizeOptions.allow_left_merge")},
  {C("allow_right_merge"), get_allow_right_merge, set_allow_right_merge, C("C++ bool NnetOptimizeOptions.allow_right_merge")},
  {C("initialize_undefined"), get_initialize_undefined, set_initialize_undefined, C("C++ bool NnetOptimizeOptions.initialize_undefined")},
  {C("move_sizing_commands"), get_move_sizing_commands, set_move_sizing_commands, C("C++ bool NnetOptimizeOptions.move_sizing_commands")},
  {C("allocate_from_other"), get_allocate_from_other, set_allocate_from_other, C("C++ bool NnetOptimizeOptions.allocate_from_other")},
  {C("min_deriv_time"), get_min_deriv_time, set_min_deriv_time, C("C++ ::int32 NnetOptimizeOptions.min_deriv_time")},
  {C("max_deriv_time"), get_max_deriv_time, set_max_deriv_time, C("C++ ::int32 NnetOptimizeOptions.max_deriv_time")},
  {C("max_deriv_time_relative"), get_max_deriv_time_relative, set_max_deriv_time_relative, C("C++ ::int32 NnetOptimizeOptions.max_deriv_time_relative")},
  {C("snip_row_ops"), get_snip_row_ops, set_snip_row_ops, C("C++ bool NnetOptimizeOptions.snip_row_ops")},
  {C("memory_compression_level"), get_memory_compression_level, set_memory_compression_level, C("C++ ::int32 NnetOptimizeOptions.memory_compression_level")},
  {C("optimize_looped_computation"), get_optimize_looped_computation, set_optimize_looped_computation, C("C++ bool NnetOptimizeOptions.optimize_looped_computation")},
  {}
};

PyObject* slot_richcmp(PyObject* self, PyObject* other, int op) {
  switch (op) {
    case Py_EQ: return slot::adapter<wrap__eq__>(self, other);
    default: Py_RETURN_NOTIMPLEMENTED;
  }
}

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetOptimizeOptions::Register(::kaldi::OptionsItf *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetOptimizeOptions::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetOptimizeOptions::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// NnetOptimizeOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NnetOptimizeOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NnetOptimizeOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_optimize.NnetOptimizeOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetOptimizeOptions", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  slot_richcmp,                        // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NnetOptimizeOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetOptimizeOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetOptimizeOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetOptimizeOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetOptimizeOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetOptimizeOptions* c = static_cast<::kaldi::nnet3::NnetOptimizeOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetOptimizeOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNnetOptimizeOptions

// max_output_time_in_request(request:ComputationRequest) -> int
static PyObject* wrapMaxOutputTimeInRequest_as_max_output_time_in_request(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("request"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:max_output_time_in_request", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ComputationRequest* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("max_output_time_in_request", names[0], "::kaldi::nnet3::ComputationRequest", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::nnet3::MaxOutputTimeInRequest(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// optimize(config:NnetOptimizeOptions, nnet:Nnet, max_output_time_in_request:int, computation:NnetComputation)
static PyObject* wrapOptimize_as_optimize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("config"),
      C("nnet"),
      C("max_output_time_in_request"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:optimize", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::nnet3::NnetOptimizeOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("optimize", names[0], "::kaldi::nnet3::NnetOptimizeOptions", a[0]);
  ::kaldi::nnet3::Nnet* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("optimize", names[1], "::kaldi::nnet3::Nnet", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("optimize", names[2], "int", a[2]);
  ::kaldi::nnet3::NnetComputation * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("optimize", names[3], "::kaldi::nnet3::NnetComputation *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::Optimize(*arg1, *arg2, std::move(arg3), arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyCachingOptimizingCompilerOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompilerOptions> cpp;
};
static ::kaldi::nnet3::CachingOptimizingCompilerOptions* ThisPtr(PyObject*);

static PyObject* get_use_shortcut(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->use_shortcut, {});
}

static int set_use_shortcut(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the use_shortcut attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->use_shortcut)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for use_shortcut:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cache_capacity(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->cache_capacity, {});
}

static int set_cache_capacity(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cache_capacity attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cache_capacity)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cache_capacity:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opt:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("use_shortcut"), get_use_shortcut, set_use_shortcut, C("C++ bool CachingOptimizingCompilerOptions.use_shortcut")},
  {C("cache_capacity"), get_cache_capacity, set_cache_capacity, C("C++ ::int32 CachingOptimizingCompilerOptions.cache_capacity")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opt:OptionsItf)\n  Calls C++ function\n  void ::kaldi::nnet3::CachingOptimizingCompilerOptions::Register(::kaldi::OptionsItf *)")},
  {}
};

// CachingOptimizingCompilerOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CachingOptimizingCompilerOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CachingOptimizingCompilerOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_optimize.CachingOptimizingCompilerOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::CachingOptimizingCompilerOptions", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CachingOptimizingCompilerOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::CachingOptimizingCompilerOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::CachingOptimizingCompilerOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_CachingOptimizingCompilerOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::CachingOptimizingCompilerOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::CachingOptimizingCompilerOptions* c = static_cast<::kaldi::nnet3::CachingOptimizingCompilerOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::CachingOptimizingCompilerOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCachingOptimizingCompilerOptions

namespace pyCachingOptimizingCompiler {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompiler> cpp;
};
static ::kaldi::nnet3::CachingOptimizingCompiler* ThisPtr(PyObject*);

// __init__(nnet:Nnet, config:CachingOptimizingCompilerOptions=default)
static PyObject* wrapCachingOptimizingCompiler_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("nnet"),
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:__init__", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::nnet3::CachingOptimizingCompilerOptions", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::CachingOptimizingCompiler>(*arg1); break;
  case 2:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::CachingOptimizingCompiler>(*arg1, *arg2); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod new_with_optimize_opts(nnet:Nnet, opt_config:NnetOptimizeOptions, config:CachingOptimizingCompilerOptions=default) -> CachingOptimizingCompiler
static PyObject* wrapCachingOptimizingCompiler_as_new_with_optimize_opts(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("nnet"),
      C("opt_config"),
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:new_with_optimize_opts", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_with_optimize_opts", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetOptimizeOptions* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_with_optimize_opts", names[1], "::kaldi::nnet3::NnetOptimizeOptions", a[1]);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("new_with_optimize_opts", names[2], "::kaldi::nnet3::CachingOptimizingCompilerOptions", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompiler> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::CachingOptimizingCompiler>(*arg1, *arg2); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::CachingOptimizingCompiler>(*arg1, *arg2, *arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compile(request:ComputationRequest) -> NnetComputation
static PyObject* wrapCompile_as_compile(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("request"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compile", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ComputationRequest* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compile", names[0], "::kaldi::nnet3::ComputationRequest", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CachingOptimizingCompiler* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::kaldi::nnet3::NnetComputation * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Compile(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_cache(is:istream, binary:bool)
static PyObject* wrapReadCache_as_read_cache(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_cache", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_cache", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_cache", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CachingOptimizingCompiler* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ReadCache(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write_cache(os:ostream, binary:bool)
static PyObject* wrapWriteCache_as_write_cache(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_cache", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_cache", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_cache", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CachingOptimizingCompiler* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteCache(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapCachingOptimizingCompiler_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(nnet:Nnet, config:CachingOptimizingCompilerOptions=default)\n  Calls C++ function\n  void ::kaldi::nnet3::CachingOptimizingCompiler::CachingOptimizingCompiler(::kaldi::nnet3::Nnet, ::kaldi::nnet3::CachingOptimizingCompilerOptions)")},
  {C("new_with_optimize_opts"), (PyCFunction)wrapCachingOptimizingCompiler_as_new_with_optimize_opts, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new_with_optimize_opts(nnet:Nnet, opt_config:NnetOptimizeOptions, config:CachingOptimizingCompilerOptions=default) -> CachingOptimizingCompiler\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompiler> ::kaldi::nnet3::CachingOptimizingCompiler::CachingOptimizingCompiler(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetOptimizeOptions, ::kaldi::nnet3::CachingOptimizingCompilerOptions)")},
  {C("compile"), (PyCFunction)wrapCompile_as_compile, METH_VARARGS | METH_KEYWORDS, C("compile(request:ComputationRequest) -> NnetComputation\n  Calls C++ function\n  const ::kaldi::nnet3::NnetComputation * ::kaldi::nnet3::CachingOptimizingCompiler::Compile(::kaldi::nnet3::ComputationRequest)")},
  {C("read_cache"), (PyCFunction)wrapReadCache_as_read_cache, METH_VARARGS | METH_KEYWORDS, C("read_cache(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::CachingOptimizingCompiler::ReadCache(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write_cache"), (PyCFunction)wrapWriteCache_as_write_cache, METH_VARARGS | METH_KEYWORDS, C("write_cache(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::CachingOptimizingCompiler::WriteCache(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// CachingOptimizingCompiler __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CachingOptimizingCompiler __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CachingOptimizingCompiler __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_optimize.CachingOptimizingCompiler", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::CachingOptimizingCompiler", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapCachingOptimizingCompiler_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::CachingOptimizingCompiler* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_CachingOptimizingCompiler"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::CachingOptimizingCompiler"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::CachingOptimizingCompiler* c = static_cast<::kaldi::nnet3::CachingOptimizingCompiler*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::CachingOptimizingCompiler*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCachingOptimizingCompiler

// convert_addition_to_assignment(nnet:Nnet, computation:NnetComputation)
static PyObject* wrapConvertAdditionToAssignment_as_convert_addition_to_assignment(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:convert_addition_to_assignment", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_addition_to_assignment", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetComputation * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("convert_addition_to_assignment", names[1], "::kaldi::nnet3::NnetComputation *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::ConvertAdditionToAssignment(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// variable_merging_optimization(config:NnetOptimizeOptions, nnet:Nnet, computation:NnetComputation)
static PyObject* wrapVariableMergingOptimization_as_variable_merging_optimization(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("config"),
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:variable_merging_optimization", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::NnetOptimizeOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("variable_merging_optimization", names[0], "::kaldi::nnet3::NnetOptimizeOptions", a[0]);
  ::kaldi::nnet3::Nnet* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("variable_merging_optimization", names[1], "::kaldi::nnet3::Nnet", a[1]);
  ::kaldi::nnet3::NnetComputation * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("variable_merging_optimization", names[2], "::kaldi::nnet3::NnetComputation *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::VariableMergingOptimization(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// remove_unnecessary_zeroing(nnet:Nnet, computation:NnetComputation)
static PyObject* wrapRemoveUnnecessaryZeroing_as_remove_unnecessary_zeroing(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:remove_unnecessary_zeroing", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_unnecessary_zeroing", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetComputation * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("remove_unnecessary_zeroing", names[1], "::kaldi::nnet3::NnetComputation *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::RemoveUnnecessaryZeroing(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// move_sizing_commands(nnet:Nnet, computation:NnetComputation)
static PyObject* wrapMoveSizingCommands_as_move_sizing_commands(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:move_sizing_commands", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("move_sizing_commands", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetComputation * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("move_sizing_commands", names[1], "::kaldi::nnet3::NnetComputation *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::MoveSizingCommands(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// remove_unnecessary_allocation(nnet:Nnet, computation:NnetComputation)
static PyObject* wrapRemoveUnnecessaryAllocation_as_remove_unnecessary_allocation(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:remove_unnecessary_allocation", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_unnecessary_allocation", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetComputation * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("remove_unnecessary_allocation", names[1], "::kaldi::nnet3::NnetComputation *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::RemoveUnnecessaryAllocation(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// consolidate_io_operations(nnet:Nnet, computation:NnetComputation)
static PyObject* wrapConsolidateIoOperations_as_consolidate_io_operations(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("nnet"),
      C("computation"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:consolidate_io_operations", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("consolidate_io_operations", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetComputation * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("consolidate_io_operations", names[1], "::kaldi::nnet3::NnetComputation *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::ConsolidateIoOperations(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("max_output_time_in_request"), (PyCFunction)wrapMaxOutputTimeInRequest_as_max_output_time_in_request, METH_VARARGS | METH_KEYWORDS, C("max_output_time_in_request(request:ComputationRequest) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::MaxOutputTimeInRequest(::kaldi::nnet3::ComputationRequest)")},
  {C("optimize"), (PyCFunction)wrapOptimize_as_optimize, METH_VARARGS | METH_KEYWORDS, C("optimize(config:NnetOptimizeOptions, nnet:Nnet, max_output_time_in_request:int, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::Optimize(::kaldi::nnet3::NnetOptimizeOptions, ::kaldi::nnet3::Nnet, int, ::kaldi::nnet3::NnetComputation *)")},
  {C("convert_addition_to_assignment"), (PyCFunction)wrapConvertAdditionToAssignment_as_convert_addition_to_assignment, METH_VARARGS | METH_KEYWORDS, C("convert_addition_to_assignment(nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::ConvertAdditionToAssignment(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {C("variable_merging_optimization"), (PyCFunction)wrapVariableMergingOptimization_as_variable_merging_optimization, METH_VARARGS | METH_KEYWORDS, C("variable_merging_optimization(config:NnetOptimizeOptions, nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::VariableMergingOptimization(::kaldi::nnet3::NnetOptimizeOptions, ::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {C("remove_unnecessary_zeroing"), (PyCFunction)wrapRemoveUnnecessaryZeroing_as_remove_unnecessary_zeroing, METH_VARARGS | METH_KEYWORDS, C("remove_unnecessary_zeroing(nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::RemoveUnnecessaryZeroing(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {C("move_sizing_commands"), (PyCFunction)wrapMoveSizingCommands_as_move_sizing_commands, METH_VARARGS | METH_KEYWORDS, C("move_sizing_commands(nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::MoveSizingCommands(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {C("remove_unnecessary_allocation"), (PyCFunction)wrapRemoveUnnecessaryAllocation_as_remove_unnecessary_allocation, METH_VARARGS | METH_KEYWORDS, C("remove_unnecessary_allocation(nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::RemoveUnnecessaryAllocation(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {C("consolidate_io_operations"), (PyCFunction)wrapConsolidateIoOperations_as_consolidate_io_operations, METH_VARARGS | METH_KEYWORDS, C("consolidate_io_operations(nnet:Nnet, computation:NnetComputation)\n  Calls C++ function\n  void ::kaldi::nnet3::ConsolidateIoOperations(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetComputation *)")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyNnetOptimizeOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetOptimizeOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCachingOptimizingCompilerOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCachingOptimizingCompilerOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCachingOptimizingCompiler::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCachingOptimizingCompiler::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_nnet_optimize",  // module name
  "CLIF-generated module for nnet3/nnet-optimize.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_computation")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_nnet")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "NnetOptimizeOptions", reinterpret_cast<PyObject*>(&pyNnetOptimizeOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CachingOptimizingCompilerOptions", reinterpret_cast<PyObject*>(&pyCachingOptimizingCompilerOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CachingOptimizingCompiler", reinterpret_cast<PyObject*>(&pyCachingOptimizingCompiler::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __nnet__optimize_clifwrap

namespace kaldi { namespace nnet3 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CachingOptimizingCompiler to/from ::kaldi::nnet3::CachingOptimizingCompiler conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::CachingOptimizingCompiler** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::CachingOptimizingCompiler* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompiler::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::CachingOptimizingCompiler>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompiler* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompiler::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompiler>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompiler* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompiler::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CachingOptimizingCompiler instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::CachingOptimizingCompiler* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompiler>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::CachingOptimizingCompiler> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompiler>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompiler> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompiler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompiler>(std::move(c));
  return py;
}

// CachingOptimizingCompilerOptions to/from ::kaldi::nnet3::CachingOptimizingCompilerOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::CachingOptimizingCompilerOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::CachingOptimizingCompilerOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompilerOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CachingOptimizingCompilerOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::CachingOptimizingCompilerOptions* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::CachingOptimizingCompilerOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CachingOptimizingCompilerOptions* cpp = __nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::CachingOptimizingCompilerOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompilerOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::CachingOptimizingCompilerOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompilerOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::CachingOptimizingCompilerOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CachingOptimizingCompilerOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::CachingOptimizingCompilerOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyCachingOptimizingCompilerOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::CachingOptimizingCompilerOptions>(c);
  return py;
}

// NnetOptimizeOptions to/from ::kaldi::nnet3::NnetOptimizeOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetOptimizeOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetOptimizeOptions* cpp = __nnet__optimize_clifwrap::pyNnetOptimizeOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetOptimizeOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetOptimizeOptions* cpp = __nnet__optimize_clifwrap::pyNnetOptimizeOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetOptimizeOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetOptimizeOptions* cpp = __nnet__optimize_clifwrap::pyNnetOptimizeOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetOptimizeOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetOptimizeOptions* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetOptimizeOptions* cpp = __nnet__optimize_clifwrap::pyNnetOptimizeOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetOptimizeOptions>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetOptimizeOptions* cpp = __nnet__optimize_clifwrap::pyNnetOptimizeOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetOptimizeOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetOptimizeOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetOptimizeOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetOptimizeOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetOptimizeOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetOptimizeOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetOptimizeOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__optimize_clifwrap::pyNnetOptimizeOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetOptimizeOptions>(c);
  return py;
}

} }  // namespace kaldi::nnet3
