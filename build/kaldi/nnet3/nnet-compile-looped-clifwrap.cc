//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/nnet3/nnet-compile-looped.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "nnet3/nnet-computation-clifwrap.h"
#include "nnet3/nnet-nnet-clifwrap.h"
#include "nnet3/nnet-optimize-clifwrap.h"
#include "nnet-compile-looped-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __nnet__compile__looped_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// compile_looped(nnet:Nnet, optimize_opts:NnetOptimizeOptions, request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest) -> NnetComputation
static PyObject* wrapCompileLooped_as_compile_looped(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("nnet"),
      C("optimize_opts"),
      C("request1"),
      C("request2"),
      C("request3"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:compile_looped", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compile_looped", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::kaldi::nnet3::NnetOptimizeOptions* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compile_looped", names[1], "::kaldi::nnet3::NnetOptimizeOptions", a[1]);
  ::kaldi::nnet3::ComputationRequest* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("compile_looped", names[2], "::kaldi::nnet3::ComputationRequest", a[2]);
  ::kaldi::nnet3::ComputationRequest* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("compile_looped", names[3], "::kaldi::nnet3::ComputationRequest", a[3]);
  ::kaldi::nnet3::ComputationRequest* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("compile_looped", names[4], "::kaldi::nnet3::ComputationRequest", a[4]);
  ::kaldi::nnet3::NnetComputation ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::CompileLooped(*arg1, *arg2, *arg3, *arg4, *arg5, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_chunk_size(nnet:Nnet, frame_subsampling_factor:int, advised_chunk_size:int) -> int
static PyObject* wrapGetChunkSize_as_get_chunk_size(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("nnet"),
      C("frame_subsampling_factor"),
      C("advised_chunk_size"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_chunk_size", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_chunk_size", names[0], "::kaldi::nnet3::Nnet", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_chunk_size", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_chunk_size", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::nnet3::GetChunkSize(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modify_nnet_ivector_period(ivector_period:int, nnet:Nnet)
static PyObject* wrapModifyNnetIvectorPeriod_as_modify_nnet_ivector_period(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ivector_period"),
      C("nnet"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:modify_nnet_ivector_period", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("modify_nnet_ivector_period", names[0], "int", a[0]);
  ::kaldi::nnet3::Nnet * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("modify_nnet_ivector_period", names[1], "::kaldi::nnet3::Nnet *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::ModifyNnetIvectorPeriod(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// create_looped_computation_request(nnet:Nnet, chunk_size:int, frame_subsampling_factor:int, ivector_period:int, left_context_begin:int, right_context:int, num_sequences:int) -> (request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest)
static PyObject* wrapCreateLoopedComputationRequest_as_create_looped_computation_request(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("nnet"),
      C("chunk_size"),
      C("frame_subsampling_factor"),
      C("ivector_period"),
      C("left_context_begin"),
      C("right_context"),
      C("num_sequences"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:create_looped_computation_request", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("create_looped_computation_request", names[0], "::kaldi::nnet3::Nnet", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("create_looped_computation_request", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("create_looped_computation_request", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("create_looped_computation_request", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("create_looped_computation_request", names[4], "int", a[4]);
  int arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("create_looped_computation_request", names[5], "int", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("create_looped_computation_request", names[6], "int", a[6]);
  ::kaldi::nnet3::ComputationRequest ret0{};
  ::kaldi::nnet3::ComputationRequest ret1{};
  ::kaldi::nnet3::ComputationRequest ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::CreateLoopedComputationRequest(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), &ret0, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

// create_looped_computation_request_simple(nnet:Nnet, chunk_size:int, frame_subsampling_factor:int, ivector_period:int, extra_left_context_begin:int, extra_right_context:int, num_sequences:int) -> (request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest)
static PyObject* wrapCreateLoopedComputationRequestSimple_as_create_looped_computation_request_simple(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("nnet"),
      C("chunk_size"),
      C("frame_subsampling_factor"),
      C("ivector_period"),
      C("extra_left_context_begin"),
      C("extra_right_context"),
      C("num_sequences"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:create_looped_computation_request_simple", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("create_looped_computation_request_simple", names[0], "::kaldi::nnet3::Nnet", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("create_looped_computation_request_simple", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("create_looped_computation_request_simple", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("create_looped_computation_request_simple", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("create_looped_computation_request_simple", names[4], "int", a[4]);
  int arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("create_looped_computation_request_simple", names[5], "int", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("create_looped_computation_request_simple", names[6], "int", a[6]);
  ::kaldi::nnet3::ComputationRequest ret0{};
  ::kaldi::nnet3::ComputationRequest ret1{};
  ::kaldi::nnet3::ComputationRequest ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::nnet3::CreateLoopedComputationRequestSimple(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), &ret0, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("compile_looped"), (PyCFunction)wrapCompileLooped_as_compile_looped, METH_VARARGS | METH_KEYWORDS, C("compile_looped(nnet:Nnet, optimize_opts:NnetOptimizeOptions, request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest) -> NnetComputation\n  Calls C++ function\n  void ::kaldi::nnet3::CompileLooped(::kaldi::nnet3::Nnet, ::kaldi::nnet3::NnetOptimizeOptions, ::kaldi::nnet3::ComputationRequest, ::kaldi::nnet3::ComputationRequest, ::kaldi::nnet3::ComputationRequest, ::kaldi::nnet3::NnetComputation*)")},
  {C("get_chunk_size"), (PyCFunction)wrapGetChunkSize_as_get_chunk_size, METH_VARARGS | METH_KEYWORDS, C("get_chunk_size(nnet:Nnet, frame_subsampling_factor:int, advised_chunk_size:int) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::GetChunkSize(::kaldi::nnet3::Nnet, int, int)")},
  {C("modify_nnet_ivector_period"), (PyCFunction)wrapModifyNnetIvectorPeriod_as_modify_nnet_ivector_period, METH_VARARGS | METH_KEYWORDS, C("modify_nnet_ivector_period(ivector_period:int, nnet:Nnet)\n  Calls C++ function\n  void ::kaldi::nnet3::ModifyNnetIvectorPeriod(int, ::kaldi::nnet3::Nnet *)")},
  {C("create_looped_computation_request"), (PyCFunction)wrapCreateLoopedComputationRequest_as_create_looped_computation_request, METH_VARARGS | METH_KEYWORDS, C("create_looped_computation_request(nnet:Nnet, chunk_size:int, frame_subsampling_factor:int, ivector_period:int, left_context_begin:int, right_context:int, num_sequences:int) -> (request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest)\n  Calls C++ function\n  void ::kaldi::nnet3::CreateLoopedComputationRequest(::kaldi::nnet3::Nnet, int, int, int, int, int, int, ::kaldi::nnet3::ComputationRequest*, ::kaldi::nnet3::ComputationRequest*, ::kaldi::nnet3::ComputationRequest*)")},
  {C("create_looped_computation_request_simple"), (PyCFunction)wrapCreateLoopedComputationRequestSimple_as_create_looped_computation_request_simple, METH_VARARGS | METH_KEYWORDS, C("create_looped_computation_request_simple(nnet:Nnet, chunk_size:int, frame_subsampling_factor:int, ivector_period:int, extra_left_context_begin:int, extra_right_context:int, num_sequences:int) -> (request1:ComputationRequest, request2:ComputationRequest, request3:ComputationRequest)\n  Calls C++ function\n  void ::kaldi::nnet3::CreateLoopedComputationRequestSimple(::kaldi::nnet3::Nnet, int, int, int, int, int, int, ::kaldi::nnet3::ComputationRequest*, ::kaldi::nnet3::ComputationRequest*, ::kaldi::nnet3::ComputationRequest*)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_nnet_compile_looped",  // module name
  "CLIF-generated module for nnet3/nnet-compile-looped.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_nnet_computation")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_nnet")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_optimize")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __nnet__compile__looped_clifwrap
