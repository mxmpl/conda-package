//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/nnet3/nnet-simple-component.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "cudamatrix/cu-vector-clifwrap.h"
#include "cudamatrix/cu-matrix-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "nnet3/nnet-common-clifwrap.h"
#include "nnet3/nnet-parse-clifwrap.h"
#include "nnet3/nnet-computation-graph-ext-clifwrap.h"
#include "nnet3/nnet-misc-computation-info-clifwrap.h"
#include "nnet3/nnet-component-itf-clifwrap.h"
#include "nnet-simple-component-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __nnet__simple__component_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyPnormComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::PnormComponent> cpp;
};
static ::kaldi::nnet3::PnormComponent* ThisPtr(PyObject*);

// init(input_dim:int, output_dim:int)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:init", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_dims(input_dim:int, output_dim:int) -> PnormComponent
static PyObject* wrapPnormComponent_as_from_dims(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_dims", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_dims", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_dims", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::PnormComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::PnormComponent>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PnormComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(input_dim:int, output_dim:int)\n  Calls C++ function\n  void ::kaldi::nnet3::PnormComponent::Init(int, int)")},
  {C("from_dims"), (PyCFunction)wrapPnormComponent_as_from_dims, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_dims(input_dim:int, output_dim:int) -> PnormComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::PnormComponent> ::kaldi::nnet3::PnormComponent::PnormComponent(int, int)")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PnormComponent::Properties()")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PnormComponent::Type()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::PnormComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PnormComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PnormComponent::OutputDim()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::PnormComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PnormComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::PnormComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PnormComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PnormComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// PnormComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PnormComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PnormComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.PnormComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::PnormComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PnormComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::PnormComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::PnormComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_PnormComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::PnormComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::PnormComponent* c = static_cast<::kaldi::nnet3::PnormComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::PnormComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPnormComponent

namespace pyDropoutComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::DropoutComponent> cpp;
};
static ::kaldi::nnet3::DropoutComponent* ThisPtr(PyObject*);

// init(dim:int, dropout_proportion:float=default, dropout_per_frame:bool=default)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("dim"),
      C("dropout_proportion"),
      C("dropout_per_frame"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:init", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)0.000000e+00;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "float", a[1]);
  }
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (bool)false;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->Init(std::move(arg1)); break;
  case 2:
    c->Init(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_args(dim:int, dropout_proportion:float=default, dropout_per_frame:bool=default) -> DropoutComponent
static PyObject* wrapDropoutComponent_as_from_args(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("dim"),
      C("dropout_proportion"),
      C("dropout_per_frame"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:from_args", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_args", names[0], "int", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)0.000000e+00;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_args", names[1], "float", a[1]);
  }
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (bool)false;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_args", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::DropoutComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::DropoutComponent>(std::move(arg1)); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::DropoutComponent>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::DropoutComponent>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(other:DropoutComponent) -> DropoutComponent
static PyObject* wrapDropoutComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::DropoutComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::DropoutComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::DropoutComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::DropoutComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// set_dropout_proportion(dropout_proportion:float)
static PyObject* wrapSetDropoutProportion_as_set_dropout_proportion(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("dropout_proportion"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_dropout_proportion", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_dropout_proportion", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetDropoutProportion(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dropout_proportion() -> float
static PyObject* wrapDropoutProportion_as_dropout_proportion(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::DropoutComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DropoutProportion();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::RandomComponent*
static PyObject* as_kaldi_nnet3_RandomComponent(PyObject* self) {
  ::kaldi::nnet3::RandomComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::RandomComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(dim:int, dropout_proportion:float=default, dropout_per_frame:bool=default)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::Init(int, float, bool)")},
  {C("from_args"), (PyCFunction)wrapDropoutComponent_as_from_args, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_args(dim:int, dropout_proportion:float=default, dropout_per_frame:bool=default) -> DropoutComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::DropoutComponent> ::kaldi::nnet3::DropoutComponent::DropoutComponent(int, float, bool)")},
  {C("from_other"), (PyCFunction)wrapDropoutComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:DropoutComponent) -> DropoutComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::DropoutComponent> ::kaldi::nnet3::DropoutComponent::DropoutComponent(::kaldi::nnet3::DropoutComponent)")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::DropoutComponent::Properties()")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::DropoutComponent::Type()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::DropoutComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::DropoutComponent::OutputDim()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::DropoutComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::DropoutComponent::Copy()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::DropoutComponent::Info()")},
  {C("set_dropout_proportion"), (PyCFunction)wrapSetDropoutProportion_as_set_dropout_proportion, METH_VARARGS | METH_KEYWORDS, C("set_dropout_proportion(dropout_proportion:float)\n  Calls C++ function\n  void ::kaldi::nnet3::DropoutComponent::SetDropoutProportion(float)")},
  {C("dropout_proportion"), (PyCFunction)wrapDropoutProportion_as_dropout_proportion, METH_NOARGS, C("dropout_proportion() -> float\n  Calls C++ function\n  float ::kaldi::nnet3::DropoutComponent::DropoutProportion()")},
  {C("as_kaldi_nnet3_RandomComponent"), (PyCFunction)as_kaldi_nnet3_RandomComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::RandomComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// DropoutComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DropoutComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DropoutComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.DropoutComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::DropoutComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DropoutComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::DropoutComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::DropoutComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_DropoutComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::DropoutComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::DropoutComponent* c = static_cast<::kaldi::nnet3::DropoutComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::DropoutComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDropoutComponent

namespace pyElementwiseProductComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ElementwiseProductComponent> cpp;
};
static ::kaldi::nnet3::ElementwiseProductComponent* ThisPtr(PyObject*);

// init(input_dim:int, output_dim:int)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:init", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod new(input_dim:int, output_dim:int) -> ElementwiseProductComponent
static PyObject* wrapElementwiseProductComponent_as_new(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:new", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::ElementwiseProductComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::ElementwiseProductComponent>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ElementwiseProductComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(input_dim:int, output_dim:int)\n  Calls C++ function\n  void ::kaldi::nnet3::ElementwiseProductComponent::Init(int, int)")},
  {C("new"), (PyCFunction)wrapElementwiseProductComponent_as_new, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new(input_dim:int, output_dim:int) -> ElementwiseProductComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::ElementwiseProductComponent> ::kaldi::nnet3::ElementwiseProductComponent::ElementwiseProductComponent(int, int)")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ElementwiseProductComponent::Properties()")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ElementwiseProductComponent::Type()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::ElementwiseProductComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ElementwiseProductComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ElementwiseProductComponent::OutputDim()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::ElementwiseProductComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ElementwiseProductComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::ElementwiseProductComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ElementwiseProductComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ElementwiseProductComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// ElementwiseProductComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ElementwiseProductComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ElementwiseProductComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.ElementwiseProductComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ElementwiseProductComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ElementwiseProductComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ElementwiseProductComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ElementwiseProductComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ElementwiseProductComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ElementwiseProductComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ElementwiseProductComponent* c = static_cast<::kaldi::nnet3::ElementwiseProductComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ElementwiseProductComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyElementwiseProductComponent

namespace pySigmoidComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SigmoidComponent> cpp;
};
static ::kaldi::nnet3::SigmoidComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:SigmoidComponent) -> SigmoidComponent
static PyObject* wrapSigmoidComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::SigmoidComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::SigmoidComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::SigmoidComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::SigmoidComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)
static PyObject* wrapStoreStats_as_store_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("memo"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:store_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("store_stats", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("store_stats", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  void * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("store_stats", names[2], "void *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SigmoidComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->StoreStats(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapSigmoidComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:SigmoidComponent) -> SigmoidComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::SigmoidComponent> ::kaldi::nnet3::SigmoidComponent::SigmoidComponent(::kaldi::nnet3::SigmoidComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::SigmoidComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SigmoidComponent::Properties()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::SigmoidComponent::Copy()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::SigmoidComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::SigmoidComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("store_stats"), (PyCFunction)wrapStoreStats_as_store_stats, METH_VARARGS | METH_KEYWORDS, C("store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)\n  Calls C++ function\n  void ::kaldi::nnet3::SigmoidComponent::StoreStats(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *)")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// SigmoidComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SigmoidComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SigmoidComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.SigmoidComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SigmoidComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SigmoidComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SigmoidComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SigmoidComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SigmoidComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SigmoidComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SigmoidComponent* c = static_cast<::kaldi::nnet3::SigmoidComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SigmoidComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySigmoidComponent

namespace pyTanhComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::TanhComponent> cpp;
};
static ::kaldi::nnet3::TanhComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:TanhComponent) -> TanhComponent
static PyObject* wrapTanhComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::TanhComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::TanhComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::TanhComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::TanhComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)
static PyObject* wrapStoreStats_as_store_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("memo"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:store_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("store_stats", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("store_stats", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  void * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("store_stats", names[2], "void *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::TanhComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->StoreStats(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapTanhComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:TanhComponent) -> TanhComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::TanhComponent> ::kaldi::nnet3::TanhComponent::TanhComponent(::kaldi::nnet3::TanhComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::TanhComponent::Type()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::TanhComponent::Copy()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::TanhComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::TanhComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::TanhComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("store_stats"), (PyCFunction)wrapStoreStats_as_store_stats, METH_VARARGS | METH_KEYWORDS, C("store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)\n  Calls C++ function\n  void ::kaldi::nnet3::TanhComponent::StoreStats(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *)")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// TanhComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// TanhComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// TanhComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.TanhComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::TanhComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "TanhComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::TanhComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::TanhComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_TanhComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::TanhComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::TanhComponent* c = static_cast<::kaldi::nnet3::TanhComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::TanhComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTanhComponent

namespace pyRectifiedLinearComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::RectifiedLinearComponent> cpp;
};
static ::kaldi::nnet3::RectifiedLinearComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:RectifiedLinearComponent) -> RectifiedLinearComponent
static PyObject* wrapRectifiedLinearComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::RectifiedLinearComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::RectifiedLinearComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::RectifiedLinearComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::RectifiedLinearComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)
static PyObject* wrapStoreStats_as_store_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("memo"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:store_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("store_stats", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("store_stats", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  void * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("store_stats", names[2], "void *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::RectifiedLinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->StoreStats(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapRectifiedLinearComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:RectifiedLinearComponent) -> RectifiedLinearComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::RectifiedLinearComponent> ::kaldi::nnet3::RectifiedLinearComponent::RectifiedLinearComponent(::kaldi::nnet3::RectifiedLinearComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::RectifiedLinearComponent::Type()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::RectifiedLinearComponent::Copy()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RectifiedLinearComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::RectifiedLinearComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::RectifiedLinearComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("store_stats"), (PyCFunction)wrapStoreStats_as_store_stats, METH_VARARGS | METH_KEYWORDS, C("store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)\n  Calls C++ function\n  void ::kaldi::nnet3::RectifiedLinearComponent::StoreStats(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *)")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// RectifiedLinearComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RectifiedLinearComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RectifiedLinearComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.RectifiedLinearComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::RectifiedLinearComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RectifiedLinearComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::RectifiedLinearComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::RectifiedLinearComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_RectifiedLinearComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::RectifiedLinearComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::RectifiedLinearComponent* c = static_cast<::kaldi::nnet3::RectifiedLinearComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::RectifiedLinearComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRectifiedLinearComponent

namespace pyAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::AffineComponent> cpp;
};
static ::kaldi::nnet3::AffineComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:AffineComponent) -> AffineComponent
static PyObject* wrapAffineComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::AffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::AffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::AffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::AffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_params(linear_params:CuMatrixBase, bias_params:CuVectorBase, learning_rate:float) -> AffineComponent
static PyObject* wrapAffineComponent_as_from_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("linear_params"),
      C("bias_params"),
      C("learning_rate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:from_params", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_params", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_params", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_params", names[2], "float", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::AffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::AffineComponent>(*arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// orthonormal_constraint() -> float
static PyObject* wrapOrthonormalConstraint_as_orthonormal_constraint(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OrthonormalConstraint();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_params(bias:CuVectorBase, linear:CuMatrixBase)
static PyObject* wrapSetParams_as_set_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("bias"),
      C("linear"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:set_params", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_params", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_params", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetParams(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// bias_params() -> CuVector
static PyObject* wrapBiasParams_as_bias_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuVector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->BiasParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// linear_params() -> CuMatrix
static PyObject* wrapLinearParams_as_linear_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuMatrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LinearParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// resize(input_dim:int, output_dim:int)
static PyObject* wrapResize_as_resize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:resize", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Resize(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(input_dim:int, output_dim:int, param_stddev:float, bias_stddev:float)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      C("param_stddev"),
      C("bias_stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:init", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "int", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "float", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("init", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::nnet3::AffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapAffineComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:AffineComponent) -> AffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::AffineComponent> ::kaldi::nnet3::AffineComponent::AffineComponent(::kaldi::nnet3::AffineComponent)")},
  {C("from_params"), (PyCFunction)wrapAffineComponent_as_from_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_params(linear_params:CuMatrixBase, bias_params:CuVectorBase, learning_rate:float) -> AffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::AffineComponent> ::kaldi::nnet3::AffineComponent::AffineComponent(::kaldi::CuMatrixBase<float>, ::kaldi::CuVectorBase<float>, float)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::AffineComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::AffineComponent::OutputDim()")},
  {C("orthonormal_constraint"), (PyCFunction)wrapOrthonormalConstraint_as_orthonormal_constraint, METH_NOARGS, C("orthonormal_constraint() -> float\n  Calls C++ function\n  float ::kaldi::nnet3::AffineComponent::OrthonormalConstraint()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::AffineComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::AffineComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::AffineComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::AffineComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::AffineComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::AffineComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::AffineComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("set_params"), (PyCFunction)wrapSetParams_as_set_params, METH_VARARGS | METH_KEYWORDS, C("set_params(bias:CuVectorBase, linear:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::SetParams(::kaldi::CuVectorBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("bias_params"), (PyCFunction)wrapBiasParams_as_bias_params, METH_NOARGS, C("bias_params() -> CuVector\n  Calls C++ function\n  ::kaldi::CuVector<float> ::kaldi::nnet3::AffineComponent::BiasParams()")},
  {C("linear_params"), (PyCFunction)wrapLinearParams_as_linear_params, METH_NOARGS, C("linear_params() -> CuMatrix\n  Calls C++ function\n  ::kaldi::CuMatrix<float> ::kaldi::nnet3::AffineComponent::LinearParams()")},
  {C("resize"), (PyCFunction)wrapResize_as_resize, METH_VARARGS | METH_KEYWORDS, C("resize(input_dim:int, output_dim:int)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Resize(int, int)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(input_dim:int, output_dim:int, param_stddev:float, bias_stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::AffineComponent::Init(int, int, float, float)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// AffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// AffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// AffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.AffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::AffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "AffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::AffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::AffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_AffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::AffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::AffineComponent* c = static_cast<::kaldi::nnet3::AffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::AffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyAffineComponent

namespace pyRepeatedAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::RepeatedAffineComponent> cpp;
};
static ::kaldi::nnet3::RepeatedAffineComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:RepeatedAffineComponent) -> RepeatedAffineComponent
static PyObject* wrapRepeatedAffineComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::RepeatedAffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::RepeatedAffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::RepeatedAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::RepeatedAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// bias_params() -> CuVector
static PyObject* wrapBiasParams_as_bias_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuVector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->BiasParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// linear_params() -> CuMatrix
static PyObject* wrapLinearParams_as_linear_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuMatrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LinearParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapRepeatedAffineComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:RepeatedAffineComponent) -> RepeatedAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::RepeatedAffineComponent> ::kaldi::nnet3::RepeatedAffineComponent::RepeatedAffineComponent(::kaldi::nnet3::RepeatedAffineComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RepeatedAffineComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RepeatedAffineComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::RepeatedAffineComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::RepeatedAffineComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RepeatedAffineComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::RepeatedAffineComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::RepeatedAffineComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::RepeatedAffineComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RepeatedAffineComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::RepeatedAffineComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("bias_params"), (PyCFunction)wrapBiasParams_as_bias_params, METH_NOARGS, C("bias_params() -> CuVector\n  Calls C++ function\n  ::kaldi::CuVector<float> ::kaldi::nnet3::RepeatedAffineComponent::BiasParams()")},
  {C("linear_params"), (PyCFunction)wrapLinearParams_as_linear_params, METH_NOARGS, C("linear_params() -> CuMatrix\n  Calls C++ function\n  ::kaldi::CuMatrix<float> ::kaldi::nnet3::RepeatedAffineComponent::LinearParams()")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// RepeatedAffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RepeatedAffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RepeatedAffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.RepeatedAffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::RepeatedAffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RepeatedAffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::RepeatedAffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::RepeatedAffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_RepeatedAffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::RepeatedAffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::RepeatedAffineComponent* c = static_cast<::kaldi::nnet3::RepeatedAffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::RepeatedAffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRepeatedAffineComponent

namespace pyBlockAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::BlockAffineComponent> cpp;
};
static ::kaldi::nnet3::BlockAffineComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:BlockAffineComponent) -> BlockAffineComponent
static PyObject* wrapBlockAffineComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::BlockAffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::BlockAffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::BlockAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::BlockAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_rac(other:RepeatedAffineComponent) -> BlockAffineComponent
static PyObject* wrapBlockAffineComponent_as_from_rac(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_rac", names, &a[0])) return nullptr;
  ::kaldi::nnet3::RepeatedAffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_rac", names[0], "::kaldi::nnet3::RepeatedAffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::BlockAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::BlockAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BlockAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapBlockAffineComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:BlockAffineComponent) -> BlockAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::BlockAffineComponent> ::kaldi::nnet3::BlockAffineComponent::BlockAffineComponent(::kaldi::nnet3::BlockAffineComponent)")},
  {C("from_rac"), (PyCFunction)wrapBlockAffineComponent_as_from_rac, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_rac(other:RepeatedAffineComponent) -> BlockAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::BlockAffineComponent> ::kaldi::nnet3::BlockAffineComponent::BlockAffineComponent(::kaldi::nnet3::RepeatedAffineComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::BlockAffineComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::BlockAffineComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::BlockAffineComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::BlockAffineComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::BlockAffineComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::BlockAffineComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::BlockAffineComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::BlockAffineComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::BlockAffineComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::BlockAffineComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// BlockAffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// BlockAffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// BlockAffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.BlockAffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::BlockAffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "BlockAffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::BlockAffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::BlockAffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_BlockAffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::BlockAffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::BlockAffineComponent* c = static_cast<::kaldi::nnet3::BlockAffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::BlockAffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyBlockAffineComponent

namespace pyNaturalGradientRepeatedAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent> cpp;
};
static ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:NaturalGradientRepeatedAffineComponent) -> NaturalGradientRepeatedAffineComponent
static PyObject* wrapNaturalGradientRepeatedAffineComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::NaturalGradientRepeatedAffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::RepeatedAffineComponent*
static PyObject* as_kaldi_nnet3_RepeatedAffineComponent(PyObject* self) {
  ::kaldi::nnet3::RepeatedAffineComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::RepeatedAffineComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapNaturalGradientRepeatedAffineComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:NaturalGradientRepeatedAffineComponent) -> NaturalGradientRepeatedAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent> ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent::NaturalGradientRepeatedAffineComponent(::kaldi::nnet3::NaturalGradientRepeatedAffineComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent::Type()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent::Copy()")},
  {C("as_kaldi_nnet3_RepeatedAffineComponent"), (PyCFunction)as_kaldi_nnet3_RepeatedAffineComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::RepeatedAffineComponent*")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// NaturalGradientRepeatedAffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NaturalGradientRepeatedAffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NaturalGradientRepeatedAffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.NaturalGradientRepeatedAffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NaturalGradientRepeatedAffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NaturalGradientRepeatedAffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NaturalGradientRepeatedAffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* c = static_cast<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNaturalGradientRepeatedAffineComponent

namespace pySoftmaxComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SoftmaxComponent> cpp;
};
static ::kaldi::nnet3::SoftmaxComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:SoftmaxComponent) -> SoftmaxComponent
static PyObject* wrapSoftmaxComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::SoftmaxComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::SoftmaxComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::SoftmaxComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::SoftmaxComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)
static PyObject* wrapStoreStats_as_store_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("memo"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:store_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("store_stats", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("store_stats", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  void * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("store_stats", names[2], "void *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->StoreStats(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapSoftmaxComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:SoftmaxComponent) -> SoftmaxComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::SoftmaxComponent> ::kaldi::nnet3::SoftmaxComponent::SoftmaxComponent(::kaldi::nnet3::SoftmaxComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::SoftmaxComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SoftmaxComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::SoftmaxComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::SoftmaxComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("store_stats"), (PyCFunction)wrapStoreStats_as_store_stats, METH_VARARGS | METH_KEYWORDS, C("store_stats(in_value:CuMatrixBase, out_value:CuMatrixBase, memo:Memo)\n  Calls C++ function\n  void ::kaldi::nnet3::SoftmaxComponent::StoreStats(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::SoftmaxComponent::Copy()")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// SoftmaxComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SoftmaxComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SoftmaxComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.SoftmaxComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SoftmaxComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SoftmaxComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SoftmaxComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SoftmaxComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SoftmaxComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SoftmaxComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SoftmaxComponent* c = static_cast<::kaldi::nnet3::SoftmaxComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SoftmaxComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySoftmaxComponent

namespace pyLogSoftmaxComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::LogSoftmaxComponent> cpp;
};
static ::kaldi::nnet3::LogSoftmaxComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:LogSoftmaxComponent) -> LogSoftmaxComponent
static PyObject* wrapLogSoftmaxComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::LogSoftmaxComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::LogSoftmaxComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::LogSoftmaxComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::LogSoftmaxComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LogSoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LogSoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::LogSoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::LogSoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LogSoftmaxComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapLogSoftmaxComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:LogSoftmaxComponent) -> LogSoftmaxComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::LogSoftmaxComponent> ::kaldi::nnet3::LogSoftmaxComponent::LogSoftmaxComponent(::kaldi::nnet3::LogSoftmaxComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::LogSoftmaxComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LogSoftmaxComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::LogSoftmaxComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LogSoftmaxComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::LogSoftmaxComponent::Copy()")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// LogSoftmaxComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LogSoftmaxComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LogSoftmaxComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.LogSoftmaxComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::LogSoftmaxComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LogSoftmaxComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::LogSoftmaxComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::LogSoftmaxComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_LogSoftmaxComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::LogSoftmaxComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::LogSoftmaxComponent* c = static_cast<::kaldi::nnet3::LogSoftmaxComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::LogSoftmaxComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLogSoftmaxComponent

namespace pyNaturalGradientAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NaturalGradientAffineComponent> cpp;
};
static ::kaldi::nnet3::NaturalGradientAffineComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:NaturalGradientAffineComponent) -> NaturalGradientAffineComponent
static PyObject* wrapNaturalGradientAffineComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NaturalGradientAffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::NaturalGradientAffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NaturalGradientAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_params(linear_params:CuMatrixBase, bias_params:CuVectorBase) -> NaturalGradientAffineComponent
static PyObject* wrapNaturalGradientAffineComponent_as_from_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("linear_params"),
      C("bias_params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_params", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_params", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_params", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NaturalGradientAffineComponent>(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// freeze_natural_gradient(freeze:bool)
static PyObject* wrapFreezeNaturalGradient_as_freeze_natural_gradient(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("freeze"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:freeze_natural_gradient", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("freeze_natural_gradient", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreezeNaturalGradient(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::AffineComponent*
static PyObject* as_kaldi_nnet3_AffineComponent(PyObject* self) {
  ::kaldi::nnet3::AffineComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::AffineComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapNaturalGradientAffineComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:NaturalGradientAffineComponent) -> NaturalGradientAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> ::kaldi::nnet3::NaturalGradientAffineComponent::NaturalGradientAffineComponent(::kaldi::nnet3::NaturalGradientAffineComponent)")},
  {C("from_params"), (PyCFunction)wrapNaturalGradientAffineComponent_as_from_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_params(linear_params:CuMatrixBase, bias_params:CuVectorBase) -> NaturalGradientAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> ::kaldi::nnet3::NaturalGradientAffineComponent::NaturalGradientAffineComponent(::kaldi::CuMatrixBase<float>, ::kaldi::CuVectorBase<float>)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NaturalGradientAffineComponent::Type()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NaturalGradientAffineComponent::Info()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::NaturalGradientAffineComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("freeze_natural_gradient"), (PyCFunction)wrapFreezeNaturalGradient_as_freeze_natural_gradient, METH_VARARGS | METH_KEYWORDS, C("freeze_natural_gradient(freeze:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientAffineComponent::FreezeNaturalGradient(bool)")},
  {C("as_kaldi_nnet3_AffineComponent"), (PyCFunction)as_kaldi_nnet3_AffineComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::AffineComponent*")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// NaturalGradientAffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NaturalGradientAffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NaturalGradientAffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.NaturalGradientAffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NaturalGradientAffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NaturalGradientAffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NaturalGradientAffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NaturalGradientAffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NaturalGradientAffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NaturalGradientAffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NaturalGradientAffineComponent* c = static_cast<::kaldi::nnet3::NaturalGradientAffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NaturalGradientAffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNaturalGradientAffineComponent

namespace pyLinearComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::LinearComponent> cpp;
};
static ::kaldi::nnet3::LinearComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:LinearComponent) -> LinearComponent
static PyObject* wrapLinearComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::LinearComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::LinearComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::LinearComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::LinearComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_params(params:CuMatrix) -> LinearComponent
static PyObject* wrapLinearComponent_as_from_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_params", names, &a[0])) return nullptr;
  ::kaldi::CuMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_params", names[0], "::kaldi::CuMatrix<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::LinearComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::LinearComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// freeze_natural_gradient(freeze:bool)
static PyObject* wrapFreezeNaturalGradient_as_freeze_natural_gradient(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("freeze"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:freeze_natural_gradient", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("freeze_natural_gradient", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreezeNaturalGradient(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// orthonormal_constraint() -> float
static PyObject* wrapOrthonormalConstraint_as_orthonormal_constraint(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LinearComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OrthonormalConstraint();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapLinearComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:LinearComponent) -> LinearComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::LinearComponent> ::kaldi::nnet3::LinearComponent::LinearComponent(::kaldi::nnet3::LinearComponent)")},
  {C("from_params"), (PyCFunction)wrapLinearComponent_as_from_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_params(params:CuMatrix) -> LinearComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::LinearComponent> ::kaldi::nnet3::LinearComponent::LinearComponent(::kaldi::CuMatrix<float>)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LinearComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LinearComponent::OutputDim()")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::LinearComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LinearComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::LinearComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::LinearComponent::Info()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::LinearComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::LinearComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LinearComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("freeze_natural_gradient"), (PyCFunction)wrapFreezeNaturalGradient_as_freeze_natural_gradient, METH_VARARGS | METH_KEYWORDS, C("freeze_natural_gradient(freeze:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LinearComponent::FreezeNaturalGradient(bool)")},
  {C("orthonormal_constraint"), (PyCFunction)wrapOrthonormalConstraint_as_orthonormal_constraint, METH_NOARGS, C("orthonormal_constraint() -> float\n  Calls C++ function\n  float ::kaldi::nnet3::LinearComponent::OrthonormalConstraint()")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// LinearComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LinearComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LinearComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.LinearComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::LinearComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LinearComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::LinearComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::LinearComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_LinearComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::LinearComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::LinearComponent* c = static_cast<::kaldi::nnet3::LinearComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::LinearComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLinearComponent

namespace pyFixedAffineComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::FixedAffineComponent> cpp;
};
static ::kaldi::nnet3::FixedAffineComponent* ThisPtr(PyObject*);

// @classmethod from_affine(c:AffineComponent) -> FixedAffineComponent
static PyObject* wrapFixedAffineComponent_as_from_affine(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("c"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_affine", names, &a[0])) return nullptr;
  ::kaldi::nnet3::AffineComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_affine", names[0], "::kaldi::nnet3::AffineComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::FixedAffineComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::FixedAffineComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init(matrix:CuMatrixBase)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("matrix"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// linear_params() -> CuMatrix
static PyObject* wrapLinearParams_as_linear_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuMatrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LinearParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// bias_params() -> CuVector
static PyObject* wrapBiasParams_as_bias_params(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedAffineComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuVector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->BiasParams();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_affine"), (PyCFunction)wrapFixedAffineComponent_as_from_affine, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_affine(c:AffineComponent) -> FixedAffineComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::FixedAffineComponent> ::kaldi::nnet3::FixedAffineComponent::FixedAffineComponent(::kaldi::nnet3::AffineComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedAffineComponent::Type()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedAffineComponent::Info()")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(matrix:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedAffineComponent::Init(::kaldi::CuMatrixBase<float>)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedAffineComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedAffineComponent::Properties()")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedAffineComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedAffineComponent::OutputDim()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::FixedAffineComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedAffineComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::FixedAffineComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedAffineComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedAffineComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("linear_params"), (PyCFunction)wrapLinearParams_as_linear_params, METH_NOARGS, C("linear_params() -> CuMatrix\n  Calls C++ function\n  ::kaldi::CuMatrix<float> ::kaldi::nnet3::FixedAffineComponent::LinearParams()")},
  {C("bias_params"), (PyCFunction)wrapBiasParams_as_bias_params, METH_NOARGS, C("bias_params() -> CuVector\n  Calls C++ function\n  ::kaldi::CuVector<float> ::kaldi::nnet3::FixedAffineComponent::BiasParams()")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// FixedAffineComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// FixedAffineComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// FixedAffineComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.FixedAffineComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::FixedAffineComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "FixedAffineComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::FixedAffineComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::FixedAffineComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_FixedAffineComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::FixedAffineComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::FixedAffineComponent* c = static_cast<::kaldi::nnet3::FixedAffineComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::FixedAffineComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyFixedAffineComponent

namespace pySumGroupComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SumGroupComponent> cpp;
};
static ::kaldi::nnet3::SumGroupComponent* ThisPtr(PyObject*);

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init_from_sizes(sizes:list<int>)
static PyObject* wrapInit_as_init_from_sizes(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("sizes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_sizes", names, &a[0])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_sizes", names[0], "::std::vector< ::int32>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(input_dim:int, output_dim:int)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input_dim"),
      C("output_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:init", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_sizes() -> list<int>
static PyObject* wrapGetSizes_as_get_sizes(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSizes(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumGroupComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumGroupComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumGroupComponent::OutputDim()")},
  {C("init_from_sizes"), (PyCFunction)wrapInit_as_init_from_sizes, METH_VARARGS | METH_KEYWORDS, C("init_from_sizes(sizes:list<int>)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::Init(::std::vector< ::int32>)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(input_dim:int, output_dim:int)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::Init(int, int)")},
  {C("get_sizes"), (PyCFunction)wrapGetSizes_as_get_sizes, METH_NOARGS, C("get_sizes() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::GetSizes(::std::vector< ::int32>*)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::SumGroupComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumGroupComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::SumGroupComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::SumGroupComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::SumGroupComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// SumGroupComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SumGroupComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SumGroupComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.SumGroupComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SumGroupComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SumGroupComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SumGroupComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SumGroupComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SumGroupComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SumGroupComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SumGroupComponent* c = static_cast<::kaldi::nnet3::SumGroupComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SumGroupComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySumGroupComponent

namespace pyFixedScaleComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::FixedScaleComponent> cpp;
};
static ::kaldi::nnet3::FixedScaleComponent* ThisPtr(PyObject*);

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init(scales:CuVectorBase)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scales"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scales() -> CuVector
static PyObject* wrapScales_as_scales(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CuVector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Scales();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedScaleComponent::Type()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedScaleComponent::Info()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedScaleComponent::Properties()")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(scales:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedScaleComponent::Init(::kaldi::CuVectorBase<float>)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedScaleComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedScaleComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedScaleComponent::OutputDim()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::FixedScaleComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedScaleComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::FixedScaleComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedScaleComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedScaleComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("scales"), (PyCFunction)wrapScales_as_scales, METH_NOARGS, C("scales() -> CuVector\n  Calls C++ function\n  ::kaldi::CuVector<float> ::kaldi::nnet3::FixedScaleComponent::Scales()")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// FixedScaleComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// FixedScaleComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// FixedScaleComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.FixedScaleComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::FixedScaleComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "FixedScaleComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::FixedScaleComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::FixedScaleComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_FixedScaleComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::FixedScaleComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::FixedScaleComponent* c = static_cast<::kaldi::nnet3::FixedScaleComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::FixedScaleComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyFixedScaleComponent

namespace pyFixedBiasComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::FixedBiasComponent> cpp;
};
static ::kaldi::nnet3::FixedBiasComponent* ThisPtr(PyObject*);

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init(scales:CuVectorBase)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scales"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::FixedBiasComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedBiasComponent::Type()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::FixedBiasComponent::Info()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedBiasComponent::Properties()")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(scales:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedBiasComponent::Init(::kaldi::CuVectorBase<float>)")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedBiasComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedBiasComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::FixedBiasComponent::OutputDim()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::FixedBiasComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedBiasComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::FixedBiasComponent::Copy()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedBiasComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::FixedBiasComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// FixedBiasComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// FixedBiasComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// FixedBiasComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.FixedBiasComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::FixedBiasComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "FixedBiasComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::FixedBiasComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::FixedBiasComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_FixedBiasComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::FixedBiasComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::FixedBiasComponent* c = static_cast<::kaldi::nnet3::FixedBiasComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::FixedBiasComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyFixedBiasComponent

namespace pyNoOpComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NoOpComponent> cpp;
};
static ::kaldi::nnet3::NoOpComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:NoOpComponent) -> NoOpComponent
static PyObject* wrapNoOpComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NoOpComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::NoOpComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NoOpComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NoOpComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NoOpComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NoOpComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NoOpComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::NoOpComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::NoOpComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::NonlinearComponent*
static PyObject* as_kaldi_nnet3_NonlinearComponent(PyObject* self) {
  ::kaldi::nnet3::NonlinearComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::NonlinearComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapNoOpComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:NoOpComponent) -> NoOpComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NoOpComponent> ::kaldi::nnet3::NoOpComponent::NoOpComponent(::kaldi::nnet3::NoOpComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NoOpComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::NoOpComponent::Properties()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::NoOpComponent::Copy()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::NoOpComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::NoOpComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("as_kaldi_nnet3_NonlinearComponent"), (PyCFunction)as_kaldi_nnet3_NonlinearComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::NonlinearComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// NoOpComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NoOpComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NoOpComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.NoOpComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NoOpComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NoOpComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NoOpComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NoOpComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NoOpComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NoOpComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NoOpComponent* c = static_cast<::kaldi::nnet3::NoOpComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NoOpComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNoOpComponent

namespace pySumBlockComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SumBlockComponent> cpp;
};
static ::kaldi::nnet3::SumBlockComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:SumBlockComponent) -> SumBlockComponent
static PyObject* wrapSumBlockComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::SumBlockComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::SumBlockComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::SumBlockComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::SumBlockComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::SumBlockComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapSumBlockComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:SumBlockComponent) -> SumBlockComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::SumBlockComponent> ::kaldi::nnet3::SumBlockComponent::SumBlockComponent(::kaldi::nnet3::SumBlockComponent)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::SumBlockComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumBlockComponent::Properties()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::SumBlockComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumBlockComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SumBlockComponent::OutputDim()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::SumBlockComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::SumBlockComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::SumBlockComponent::Info()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::SumBlockComponent::Copy()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::SumBlockComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::SumBlockComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// SumBlockComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SumBlockComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SumBlockComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.SumBlockComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SumBlockComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SumBlockComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SumBlockComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SumBlockComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SumBlockComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SumBlockComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SumBlockComponent* c = static_cast<::kaldi::nnet3::SumBlockComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SumBlockComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySumBlockComponent

namespace pyClipGradientComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ClipGradientComponent> cpp;
};
static ::kaldi::nnet3::ClipGradientComponent* ThisPtr(PyObject*);

// @classmethod from_args(dim:int, clipping_threshold:float, norm_based_clipping:bool, self_repair_clipped_proportion_threshold:float, self_repair_target:float, self_repair_scale:float, num_clipped:int, count:int, num_self_repaired:int, num_backpropped:int) -> ClipGradientComponent
static PyObject* wrapClipGradientComponent_as_from_args(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[10];
  char* names[] = {
      C("dim"),
      C("clipping_threshold"),
      C("norm_based_clipping"),
      C("self_repair_clipped_proportion_threshold"),
      C("self_repair_target"),
      C("self_repair_scale"),
      C("num_clipped"),
      C("count"),
      C("num_self_repaired"),
      C("num_backpropped"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOOOO:from_args", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8], &a[9])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_args", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_args", names[1], "float", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_args", names[2], "bool", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_args", names[3], "float", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("from_args", names[4], "float", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("from_args", names[5], "float", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("from_args", names[6], "int", a[6]);
  int arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("from_args", names[7], "int", a[7]);
  int arg9;
  if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("from_args", names[8], "int", a[8]);
  int arg10;
  if (!Clif_PyObjAs(a[9], &arg10)) return ArgError("from_args", names[9], "int", a[9]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::ClipGradientComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::ClipGradientComponent>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9), std::move(arg10));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(dim:int, clipping_threshold:float, norm_based_clipping:bool, self_repair_clipped_proportion_threshold:float, self_repair_target:float, self_repair_scale:float, num_clipped:int, count:int, num_self_repaired:int, num_backpropped:int)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[10];
  char* names[] = {
      C("dim"),
      C("clipping_threshold"),
      C("norm_based_clipping"),
      C("self_repair_clipped_proportion_threshold"),
      C("self_repair_target"),
      C("self_repair_scale"),
      C("num_clipped"),
      C("count"),
      C("num_self_repaired"),
      C("num_backpropped"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOOOO:init", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8], &a[9])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "float", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "bool", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("init", names[3], "float", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("init", names[4], "float", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("init", names[5], "float", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("init", names[6], "int", a[6]);
  int arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("init", names[7], "int", a[7]);
  int arg9;
  if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("init", names[8], "int", a[8]);
  int arg10;
  if (!Clif_PyObjAs(a[9], &arg10)) return ArgError("init", names[9], "int", a[9]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9), std::move(arg10));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// zero_stats()
static PyObject* wrapZeroStats_as_zero_stats(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ZeroStats();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ClipGradientComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_args"), (PyCFunction)wrapClipGradientComponent_as_from_args, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_args(dim:int, clipping_threshold:float, norm_based_clipping:bool, self_repair_clipped_proportion_threshold:float, self_repair_target:float, self_repair_scale:float, num_clipped:int, count:int, num_self_repaired:int, num_backpropped:int) -> ClipGradientComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::ClipGradientComponent> ::kaldi::nnet3::ClipGradientComponent::ClipGradientComponent(int, float, bool, float, float, float, int, int, int, int)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ClipGradientComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ClipGradientComponent::OutputDim()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(dim:int, clipping_threshold:float, norm_based_clipping:bool, self_repair_clipped_proportion_threshold:float, self_repair_target:float, self_repair_scale:float, num_clipped:int, count:int, num_self_repaired:int, num_backpropped:int)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Init(int, float, bool, float, float, float, int, int, int, int)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ClipGradientComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ClipGradientComponent::Properties()")},
  {C("zero_stats"), (PyCFunction)wrapZeroStats_as_zero_stats, METH_NOARGS, C("zero_stats()\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::ZeroStats()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::ClipGradientComponent::Copy()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::ClipGradientComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ClipGradientComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ClipGradientComponent::Info()")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// ClipGradientComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ClipGradientComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ClipGradientComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.ClipGradientComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ClipGradientComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ClipGradientComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ClipGradientComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ClipGradientComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ClipGradientComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ClipGradientComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ClipGradientComponent* c = static_cast<::kaldi::nnet3::ClipGradientComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ClipGradientComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyClipGradientComponent

namespace pyPermuteComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::PermuteComponent> cpp;
};
static ::kaldi::nnet3::PermuteComponent* ThisPtr(PyObject*);

// @classmethod from_column_map(column_map:list<int>) -> PermuteComponent
static PyObject* wrapPermuteComponent_as_from_column_map(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("column_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_column_map", names, &a[0])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_column_map", names[0], "::std::vector< ::int32>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::PermuteComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::PermuteComponent>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(column_map:list<int>)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("column_map"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init", names, &a[0])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "::std::vector< ::int32>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// zero_stats()
static PyObject* wrapZeroStats_as_zero_stats(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ZeroStats();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PermuteComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_column_map"), (PyCFunction)wrapPermuteComponent_as_from_column_map, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_column_map(column_map:list<int>) -> PermuteComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::PermuteComponent> ::kaldi::nnet3::PermuteComponent::PermuteComponent(::std::vector< ::int32>)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PermuteComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PermuteComponent::OutputDim()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(column_map:list<int>)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Init(::std::vector< ::int32>)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PermuteComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PermuteComponent::Properties()")},
  {C("zero_stats"), (PyCFunction)wrapZeroStats_as_zero_stats, METH_NOARGS, C("zero_stats()\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::ZeroStats()")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::PermuteComponent::Copy()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::PermuteComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PermuteComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PermuteComponent::Info()")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// PermuteComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PermuteComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PermuteComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.PermuteComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::PermuteComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PermuteComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::PermuteComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::PermuteComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_PermuteComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::PermuteComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::PermuteComponent* c = static_cast<::kaldi::nnet3::PermuteComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::PermuteComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPermuteComponent

namespace pyPerElementScaleComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::PerElementScaleComponent> cpp;
};
static ::kaldi::nnet3::PerElementScaleComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:PerElementScaleComponent) -> PerElementScaleComponent
static PyObject* wrapPerElementScaleComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::PerElementScaleComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::PerElementScaleComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::PerElementScaleComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::PerElementScaleComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(dim:int, param_mean:float, param_stddev:float)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("dim"),
      C("param_mean"),
      C("param_stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:init", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "float", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "float", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_vector(vector_filename:str)
static PyObject* wrapInit_as_init_from_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("vector_filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_vector", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_vector", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapPerElementScaleComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:PerElementScaleComponent) -> PerElementScaleComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::PerElementScaleComponent> ::kaldi::nnet3::PerElementScaleComponent::PerElementScaleComponent(::kaldi::nnet3::PerElementScaleComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementScaleComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementScaleComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PerElementScaleComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PerElementScaleComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementScaleComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::PerElementScaleComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::PerElementScaleComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::PerElementScaleComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementScaleComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(dim:int, param_mean:float, param_stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Init(int, float, float)")},
  {C("init_from_vector"), (PyCFunction)wrapInit_as_init_from_vector, METH_VARARGS | METH_KEYWORDS, C("init_from_vector(vector_filename:str)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementScaleComponent::Init(::std::string)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// PerElementScaleComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PerElementScaleComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PerElementScaleComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.PerElementScaleComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::PerElementScaleComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PerElementScaleComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::PerElementScaleComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::PerElementScaleComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_PerElementScaleComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::PerElementScaleComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::PerElementScaleComponent* c = static_cast<::kaldi::nnet3::PerElementScaleComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::PerElementScaleComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPerElementScaleComponent

namespace pyPerElementOffsetComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::PerElementOffsetComponent> cpp;
};
static ::kaldi::nnet3::PerElementOffsetComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:PerElementOffsetComponent) -> PerElementOffsetComponent
static PyObject* wrapPerElementOffsetComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::PerElementOffsetComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::PerElementOffsetComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::PerElementOffsetComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::PerElementOffsetComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::PerElementOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapPerElementOffsetComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:PerElementOffsetComponent) -> PerElementOffsetComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::PerElementOffsetComponent> ::kaldi::nnet3::PerElementOffsetComponent::PerElementOffsetComponent(::kaldi::nnet3::PerElementOffsetComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementOffsetComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementOffsetComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PerElementOffsetComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::PerElementOffsetComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementOffsetComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::PerElementOffsetComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::PerElementOffsetComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::PerElementOffsetComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::PerElementOffsetComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::PerElementOffsetComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// PerElementOffsetComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PerElementOffsetComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PerElementOffsetComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.PerElementOffsetComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::PerElementOffsetComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PerElementOffsetComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::PerElementOffsetComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::PerElementOffsetComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_PerElementOffsetComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::PerElementOffsetComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::PerElementOffsetComponent* c = static_cast<::kaldi::nnet3::PerElementOffsetComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::PerElementOffsetComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPerElementOffsetComponent

namespace pyConstantFunctionComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ConstantFunctionComponent> cpp;
};
static ::kaldi::nnet3::ConstantFunctionComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:ConstantFunctionComponent) -> ConstantFunctionComponent
static PyObject* wrapConstantFunctionComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConstantFunctionComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::ConstantFunctionComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::ConstantFunctionComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::ConstantFunctionComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantFunctionComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapConstantFunctionComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:ConstantFunctionComponent) -> ConstantFunctionComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::ConstantFunctionComponent> ::kaldi::nnet3::ConstantFunctionComponent::ConstantFunctionComponent(::kaldi::nnet3::ConstantFunctionComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ConstantFunctionComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ConstantFunctionComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ConstantFunctionComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ConstantFunctionComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ConstantFunctionComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::ConstantFunctionComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::ConstantFunctionComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::ConstantFunctionComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ConstantFunctionComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantFunctionComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// ConstantFunctionComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ConstantFunctionComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ConstantFunctionComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.ConstantFunctionComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ConstantFunctionComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ConstantFunctionComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ConstantFunctionComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ConstantFunctionComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ConstantFunctionComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ConstantFunctionComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ConstantFunctionComponent* c = static_cast<::kaldi::nnet3::ConstantFunctionComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ConstantFunctionComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyConstantFunctionComponent

namespace pyNaturalGradientPerElementScaleComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NaturalGradientPerElementScaleComponent> cpp;
};
static ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:NaturalGradientPerElementScaleComponent) -> NaturalGradientPerElementScaleComponent
static PyObject* wrapNaturalGradientPerElementScaleComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::NaturalGradientPerElementScaleComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// freeze_natural_gradient(freeze:bool)
static PyObject* wrapFreezeNaturalGradient_as_freeze_natural_gradient(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("freeze"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:freeze_natural_gradient", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("freeze_natural_gradient", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreezeNaturalGradient(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init(dim:int, param_mean:float, param_stddev:float, rank:int, update_period:int, num_samples_history:float, alpha:float)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("dim"),
      C("param_mean"),
      C("param_stddev"),
      C("rank"),
      C("update_period"),
      C("num_samples_history"),
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:init", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "float", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "float", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("init", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("init", names[4], "int", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("init", names[5], "float", a[5]);
  float arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("init", names[6], "float", a[6]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init_from_vector(vector_filename:str, rank:int, update_period:int, num_samples_history:float, alpha:float)
static PyObject* wrapInit_as_init_from_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("vector_filename"),
      C("rank"),
      C("update_period"),
      C("num_samples_history"),
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:init_from_vector", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_vector", names[0], "::std::string", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init_from_vector", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init_from_vector", names[2], "int", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("init_from_vector", names[3], "float", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("init_from_vector", names[4], "float", a[4]);
  // Call actual C++ method.
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::PerElementScaleComponent*
static PyObject* as_kaldi_nnet3_PerElementScaleComponent(PyObject* self) {
  ::kaldi::nnet3::PerElementScaleComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::PerElementScaleComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapNaturalGradientPerElementScaleComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:NaturalGradientPerElementScaleComponent) -> NaturalGradientPerElementScaleComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent> ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::NaturalGradientPerElementScaleComponent(::kaldi::nnet3::NaturalGradientPerElementScaleComponent)")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Type()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("freeze_natural_gradient"), (PyCFunction)wrapFreezeNaturalGradient_as_freeze_natural_gradient, METH_VARARGS | METH_KEYWORDS, C("freeze_natural_gradient(freeze:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::FreezeNaturalGradient(bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Copy()")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(dim:int, param_mean:float, param_stddev:float, rank:int, update_period:int, num_samples_history:float, alpha:float)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Init(int, float, float, int, int, float, float)")},
  {C("init_from_vector"), (PyCFunction)wrapInit_as_init_from_vector, METH_VARARGS | METH_KEYWORDS, C("init_from_vector(vector_filename:str, rank:int, update_period:int, num_samples_history:float, alpha:float)\n  Calls C++ function\n  void ::kaldi::nnet3::NaturalGradientPerElementScaleComponent::Init(::std::string, int, int, float, float)")},
  {C("as_kaldi_nnet3_PerElementScaleComponent"), (PyCFunction)as_kaldi_nnet3_PerElementScaleComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::PerElementScaleComponent*")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// NaturalGradientPerElementScaleComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NaturalGradientPerElementScaleComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NaturalGradientPerElementScaleComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.NaturalGradientPerElementScaleComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NaturalGradientPerElementScaleComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NaturalGradientPerElementScaleComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NaturalGradientPerElementScaleComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NaturalGradientPerElementScaleComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c = static_cast<::kaldi::nnet3::NaturalGradientPerElementScaleComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NaturalGradientPerElementScaleComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNaturalGradientPerElementScaleComponent

namespace pyScaleAndOffsetComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ScaleAndOffsetComponent> cpp;
};
static ::kaldi::nnet3::ScaleAndOffsetComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:ScaleAndOffsetComponent) -> ScaleAndOffsetComponent
static PyObject* wrapScaleAndOffsetComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ScaleAndOffsetComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::ScaleAndOffsetComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::ScaleAndOffsetComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::ScaleAndOffsetComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ScaleAndOffsetComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapScaleAndOffsetComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:ScaleAndOffsetComponent) -> ScaleAndOffsetComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::ScaleAndOffsetComponent> ::kaldi::nnet3::ScaleAndOffsetComponent::ScaleAndOffsetComponent(::kaldi::nnet3::ScaleAndOffsetComponent)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ScaleAndOffsetComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ScaleAndOffsetComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ScaleAndOffsetComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::ScaleAndOffsetComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ScaleAndOffsetComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::ScaleAndOffsetComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::ScaleAndOffsetComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::ScaleAndOffsetComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ScaleAndOffsetComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::ScaleAndOffsetComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// ScaleAndOffsetComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ScaleAndOffsetComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ScaleAndOffsetComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.ScaleAndOffsetComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ScaleAndOffsetComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ScaleAndOffsetComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ScaleAndOffsetComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ScaleAndOffsetComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ScaleAndOffsetComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ScaleAndOffsetComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ScaleAndOffsetComponent* c = static_cast<::kaldi::nnet3::ScaleAndOffsetComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ScaleAndOffsetComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyScaleAndOffsetComponent

namespace pyLstmNonlinearityComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::LstmNonlinearityComponent> cpp;
};
static ::kaldi::nnet3::LstmNonlinearityComponent* ThisPtr(PyObject*);

// @classmethod from_other(other:LstmNonlinearityComponent) -> LstmNonlinearityComponent
static PyObject* wrapLstmNonlinearityComponent_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::LstmNonlinearityComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::LstmNonlinearityComponent", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::LstmNonlinearityComponent> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::LstmNonlinearityComponent>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// init(cell_dim:int, use_dropout:bool, param_stddev:float, tanh_self_repair_threshold:float, sigmoid_self_repair_threshold:float, self_repair_scale:float)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("cell_dim"),
      C("use_dropout"),
      C("param_stddev"),
      C("tanh_self_repair_threshold"),
      C("sigmoid_self_repair_threshold"),
      C("self_repair_scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:init", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "int", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "bool", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("init", names[2], "float", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("init", names[3], "float", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("init", names[4], "float", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("init", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy() -> Component
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// zero_stats()
static PyObject* wrapZeroStats_as_zero_stats(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ZeroStats();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// freeze_natural_gradient(freeze:bool)
static PyObject* wrapFreezeNaturalGradient_as_freeze_natural_gradient(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("freeze"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:freeze_natural_gradient", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("freeze_natural_gradient", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::LstmNonlinearityComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreezeNaturalGradient(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapLstmNonlinearityComponent_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:LstmNonlinearityComponent) -> LstmNonlinearityComponent\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::LstmNonlinearityComponent> ::kaldi::nnet3::LstmNonlinearityComponent::LstmNonlinearityComponent(::kaldi::nnet3::LstmNonlinearityComponent)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(cell_dim:int, use_dropout:bool, param_stddev:float, tanh_self_repair_threshold:float, sigmoid_self_repair_threshold:float, self_repair_scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Init(int, bool, float, float, float, float)")},
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LstmNonlinearityComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LstmNonlinearityComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::LstmNonlinearityComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::LstmNonlinearityComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LstmNonlinearityComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::LstmNonlinearityComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::LstmNonlinearityComponent::Copy()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::LstmNonlinearityComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::LstmNonlinearityComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("zero_stats"), (PyCFunction)wrapZeroStats_as_zero_stats, METH_NOARGS, C("zero_stats()\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::ZeroStats()")},
  {C("freeze_natural_gradient"), (PyCFunction)wrapFreezeNaturalGradient_as_freeze_natural_gradient, METH_VARARGS | METH_KEYWORDS, C("freeze_natural_gradient(freeze:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::LstmNonlinearityComponent::FreezeNaturalGradient(bool)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// LstmNonlinearityComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LstmNonlinearityComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LstmNonlinearityComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.LstmNonlinearityComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::LstmNonlinearityComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LstmNonlinearityComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::LstmNonlinearityComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::LstmNonlinearityComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_LstmNonlinearityComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::LstmNonlinearityComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::LstmNonlinearityComponent* c = static_cast<::kaldi::nnet3::LstmNonlinearityComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::LstmNonlinearityComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLstmNonlinearityComponent

namespace pyCompositeComponent {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::CompositeComponent> cpp;
};
static ::kaldi::nnet3::CompositeComponent* ThisPtr(PyObject*);

// input_dim() -> int
static PyObject* wrapInputDim_as_input_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_dim() -> int
static PyObject* wrapOutputDim_as_output_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// info() -> str
static PyObject* wrapInfo_as_info(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Info();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// init_from_config(cfl:ConfigLine)
static PyObject* wrapInitFromConfig_as_init_from_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cfl"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:init_from_config", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ConfigLine * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_from_config", names[0], "::kaldi::nnet3::ConfigLine *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InitFromConfig(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// init(components:list<Component>, max_rows_process:int)
static PyObject* wrapInit_as_init(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("components"),
      C("max_rows_process"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:init", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::kaldi::nnet3::Component *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init", names[0], "::std::vector< ::kaldi::nnet3::Component *>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Init(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// type() -> str
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// properties() -> int
static PyObject* wrapProperties_as_properties(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo
static PyObject* wrapPropagate_as_propagate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("indexes"),
      C("in"),
      C("out"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:propagate", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate", names[0], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("propagate", names[2], "::kaldi::CuMatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  void * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Propagate(arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)
static PyObject* wrapBackprop_as_backprop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("debug_info"),
      C("indexes"),
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("memo"),
      C("to_update"),
      C("in_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:backprop", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("backprop", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::ComponentPrecomputedIndexes * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("backprop", names[1], "::kaldi::nnet3::ComponentPrecomputedIndexes *", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("backprop", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("backprop", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("backprop", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  void * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("backprop", names[5], "void *", a[5]);
  ::kaldi::nnet3::Component * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("backprop", names[6], "::kaldi::nnet3::Component *", a[6]);
  ::kaldi::CuMatrixBase<float> * arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("backprop", names[7], "::kaldi::CuMatrixBase<float> *", a[7]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Backprop(std::move(arg1), arg2, *arg3, *arg4, *arg5, arg6, arg7, arg8);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// zero_stats()
static PyObject* wrapZeroStats_as_zero_stats(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ZeroStats();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_underlying_learning_rate(lrate:float)
static PyObject* wrapSetUnderlyingLearningRate_as_set_underlying_learning_rate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lrate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_underlying_learning_rate", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_underlying_learning_rate", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetUnderlyingLearningRate(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_actual_learning_rate(lrate:float)
static PyObject* wrapSetActualLearningRate_as_set_actual_learning_rate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lrate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_actual_learning_rate", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_actual_learning_rate", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetActualLearningRate(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_as_gradient()
static PyObject* wrapSetAsGradient_as_set_as_gradient(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetAsGradient();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(alpha:float, other:Component)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  ::kaldi::nnet3::Component* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add", names[1], "::kaldi::nnet3::Component", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// perturb_params(stddev:float)
static PyObject* wrapPerturbParams_as_perturb_params(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("stddev"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:perturb_params", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("perturb_params", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PerturbParams(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// dot_product(other:UpdatableComponent) -> float
static PyObject* wrapDotProduct_as_dot_product(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:dot_product", names, &a[0])) return nullptr;
  ::kaldi::nnet3::UpdatableComponent* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("dot_product", names[0], "::kaldi::nnet3::UpdatableComponent", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DotProduct(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parameters() -> int
static PyObject* wrapNumParameters_as_num_parameters(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParameters();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// vectorize(params:VectorBase)
static PyObject* wrapVectorize_as_vectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:vectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vectorize", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Vectorize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// unvectorize(params:VectorBase)
static PyObject* wrapUnVectorize_as_unvectorize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("params"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:unvectorize", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("unvectorize", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->UnVectorize(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// freeze_natural_gradient(freeze:bool)
static PyObject* wrapFreezeNaturalGradient_as_freeze_natural_gradient(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("freeze"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:freeze_natural_gradient", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("freeze_natural_gradient", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreezeNaturalGradient(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_components() -> int
static PyObject* wrapNumComponents_as_num_components(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumComponents();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_component(i:int) -> Component
static PyObject* wrapGetComponent_as_get_component(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("i"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_component", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_component", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Component * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetComponent(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_component(i:int, component:Component)
static PyObject* wrapSetComponent_as_set_component(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("i"),
      C("component"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:set_component", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_component", names[0], "int", a[0]);
  ::kaldi::nnet3::Component * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_component", names[1], "::kaldi::nnet3::Component *", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::CompositeComponent* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetComponent(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::UpdatableComponent*
static PyObject* as_kaldi_nnet3_UpdatableComponent(PyObject* self) {
  ::kaldi::nnet3::UpdatableComponent* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::UpdatableComponent"), nullptr);
}

// Implicit cast this as ::kaldi::nnet3::Component*
static PyObject* as_kaldi_nnet3_Component(PyObject* self) {
  ::kaldi::nnet3::Component* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::Component"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("input_dim"), (PyCFunction)wrapInputDim_as_input_dim, METH_NOARGS, C("input_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::CompositeComponent::InputDim()")},
  {C("output_dim"), (PyCFunction)wrapOutputDim_as_output_dim, METH_NOARGS, C("output_dim() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::CompositeComponent::OutputDim()")},
  {C("info"), (PyCFunction)wrapInfo_as_info, METH_NOARGS, C("info() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::CompositeComponent::Info()")},
  {C("init_from_config"), (PyCFunction)wrapInitFromConfig_as_init_from_config, METH_VARARGS | METH_KEYWORDS, C("init_from_config(cfl:ConfigLine)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::InitFromConfig(::kaldi::nnet3::ConfigLine *)")},
  {C("init"), (PyCFunction)wrapInit_as_init, METH_VARARGS | METH_KEYWORDS, C("init(components:list<Component>, max_rows_process:int)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Init(::std::vector< ::kaldi::nnet3::Component *>, int)")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> str\n  Calls C++ function\n  ::std::string ::kaldi::nnet3::CompositeComponent::Type()")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_NOARGS, C("properties() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::CompositeComponent::Properties()")},
  {C("propagate"), (PyCFunction)wrapPropagate_as_propagate, METH_VARARGS | METH_KEYWORDS, C("propagate(indexes:ComponentPrecomputedIndexes, in:CuMatrixBase, out:CuMatrixBase) -> Memo\n  Calls C++ function\n  void * ::kaldi::nnet3::CompositeComponent::Propagate(::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float> *)")},
  {C("backprop"), (PyCFunction)wrapBackprop_as_backprop, METH_VARARGS | METH_KEYWORDS, C("backprop(debug_info:str, indexes:ComponentPrecomputedIndexes, in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, memo:Memo, to_update:Component, in_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Backprop(::std::string, ::kaldi::nnet3::ComponentPrecomputedIndexes *, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, void *, ::kaldi::nnet3::Component *, ::kaldi::CuMatrixBase<float> *)")},
  {C("zero_stats"), (PyCFunction)wrapZeroStats_as_zero_stats, METH_NOARGS, C("zero_stats()\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::ZeroStats()")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("set_underlying_learning_rate"), (PyCFunction)wrapSetUnderlyingLearningRate_as_set_underlying_learning_rate, METH_VARARGS | METH_KEYWORDS, C("set_underlying_learning_rate(lrate:float)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::SetUnderlyingLearningRate(float)")},
  {C("set_actual_learning_rate"), (PyCFunction)wrapSetActualLearningRate_as_set_actual_learning_rate, METH_VARARGS | METH_KEYWORDS, C("set_actual_learning_rate(lrate:float)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::SetActualLearningRate(float)")},
  {C("set_as_gradient"), (PyCFunction)wrapSetAsGradient_as_set_as_gradient, METH_NOARGS, C("set_as_gradient()\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::SetAsGradient()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Scale(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(alpha:float, other:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Add(float, ::kaldi::nnet3::Component)")},
  {C("perturb_params"), (PyCFunction)wrapPerturbParams_as_perturb_params, METH_VARARGS | METH_KEYWORDS, C("perturb_params(stddev:float)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::PerturbParams(float)")},
  {C("dot_product"), (PyCFunction)wrapDotProduct_as_dot_product, METH_VARARGS | METH_KEYWORDS, C("dot_product(other:UpdatableComponent) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::CompositeComponent::DotProduct(::kaldi::nnet3::UpdatableComponent)")},
  {C("num_parameters"), (PyCFunction)wrapNumParameters_as_num_parameters, METH_NOARGS, C("num_parameters() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::CompositeComponent::NumParameters()")},
  {C("vectorize"), (PyCFunction)wrapVectorize_as_vectorize, METH_VARARGS | METH_KEYWORDS, C("vectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::Vectorize(::kaldi::VectorBase<float> *)")},
  {C("unvectorize"), (PyCFunction)wrapUnVectorize_as_unvectorize, METH_VARARGS | METH_KEYWORDS, C("unvectorize(params:VectorBase)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::UnVectorize(::kaldi::VectorBase<float>)")},
  {C("freeze_natural_gradient"), (PyCFunction)wrapFreezeNaturalGradient_as_freeze_natural_gradient, METH_VARARGS | METH_KEYWORDS, C("freeze_natural_gradient(freeze:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::FreezeNaturalGradient(bool)")},
  {C("num_components"), (PyCFunction)wrapNumComponents_as_num_components, METH_NOARGS, C("num_components() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::CompositeComponent::NumComponents()")},
  {C("get_component"), (PyCFunction)wrapGetComponent_as_get_component, METH_VARARGS | METH_KEYWORDS, C("get_component(i:int) -> Component\n  Calls C++ function\n  ::kaldi::nnet3::Component * ::kaldi::nnet3::CompositeComponent::GetComponent(int)")},
  {C("set_component"), (PyCFunction)wrapSetComponent_as_set_component, METH_VARARGS | METH_KEYWORDS, C("set_component(i:int, component:Component)\n  Calls C++ function\n  void ::kaldi::nnet3::CompositeComponent::SetComponent(int, ::kaldi::nnet3::Component *)")},
  {C("as_kaldi_nnet3_UpdatableComponent"), (PyCFunction)as_kaldi_nnet3_UpdatableComponent, METH_NOARGS, C("Upcast to ::kaldi::nnet3::UpdatableComponent*")},
  {C("as_kaldi_nnet3_Component"), (PyCFunction)as_kaldi_nnet3_Component, METH_NOARGS, C("Upcast to ::kaldi::nnet3::Component*")},
  {}
};

// CompositeComponent __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompositeComponent __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompositeComponent __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_simple_component.CompositeComponent", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::CompositeComponent", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CompositeComponent takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::CompositeComponent>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::CompositeComponent* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_CompositeComponent"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::CompositeComponent"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::CompositeComponent* c = static_cast<::kaldi::nnet3::CompositeComponent*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::CompositeComponent*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompositeComponent


// Initialize module

bool Ready() {
  PyObject* base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.Component is not a new style class inheriting from object.");
    return false;
  }
  pyPnormComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyPnormComponent::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.Component is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyPnormComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyPnormComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.RandomComponent");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.RandomComponent is not a new style class inheriting from object.");
    return false;
  }
  pyDropoutComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyDropoutComponent::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.RandomComponent is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyDropoutComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDropoutComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyElementwiseProductComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyElementwiseProductComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyElementwiseProductComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.NonlinearComponent");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.NonlinearComponent is not a new style class inheriting from object.");
    return false;
  }
  pySigmoidComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pySigmoidComponent::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.NonlinearComponent is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pySigmoidComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pySigmoidComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyTanhComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyTanhComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyTanhComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyRectifiedLinearComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyRectifiedLinearComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRectifiedLinearComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.UpdatableComponent");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.UpdatableComponent is not a new style class inheriting from object.");
    return false;
  }
  pyAffineComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyAffineComponent::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.nnet3._nnet_component_itf.UpdatableComponent is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyRepeatedAffineComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyRepeatedAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRepeatedAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyBlockAffineComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyBlockAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyBlockAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  pyNaturalGradientRepeatedAffineComponent::wrapper_Type.tp_base = &pyRepeatedAffineComponent::wrapper_Type;
  if (PyType_Ready(&pyNaturalGradientRepeatedAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNaturalGradientRepeatedAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.NonlinearComponent");
  pySoftmaxComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pySoftmaxComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pySoftmaxComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.NonlinearComponent");
  pyLogSoftmaxComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyLogSoftmaxComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLogSoftmaxComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  pyNaturalGradientAffineComponent::wrapper_Type.tp_base = &pyAffineComponent::wrapper_Type;
  if (PyType_Ready(&pyNaturalGradientAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNaturalGradientAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyLinearComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyLinearComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLinearComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyFixedAffineComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyFixedAffineComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyFixedAffineComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pySumGroupComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pySumGroupComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pySumGroupComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyFixedScaleComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyFixedScaleComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyFixedScaleComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyFixedBiasComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyFixedBiasComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyFixedBiasComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.NonlinearComponent");
  pyNoOpComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyNoOpComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNoOpComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pySumBlockComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pySumBlockComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pySumBlockComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyClipGradientComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyClipGradientComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyClipGradientComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.nnet3._nnet_component_itf.Component");
  pyPermuteComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyPermuteComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyPermuteComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyPerElementScaleComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyPerElementScaleComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyPerElementScaleComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyPerElementOffsetComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyPerElementOffsetComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyPerElementOffsetComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyConstantFunctionComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyConstantFunctionComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyConstantFunctionComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  pyNaturalGradientPerElementScaleComponent::wrapper_Type.tp_base = &pyPerElementScaleComponent::wrapper_Type;
  if (PyType_Ready(&pyNaturalGradientPerElementScaleComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNaturalGradientPerElementScaleComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyScaleAndOffsetComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyScaleAndOffsetComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyScaleAndOffsetComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyLstmNonlinearityComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyLstmNonlinearityComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLstmNonlinearityComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  Py_INCREF(base_cls);
  pyCompositeComponent::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  if (PyType_Ready(&pyCompositeComponent::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompositeComponent::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_nnet_simple_component",  // module name
  "CLIF-generated module for nnet3/nnet-simple-component.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_parse")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_computation_graph_ext")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_misc_computation_info")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_component_itf")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "PnormComponent", reinterpret_cast<PyObject*>(&pyPnormComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DropoutComponent", reinterpret_cast<PyObject*>(&pyDropoutComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ElementwiseProductComponent", reinterpret_cast<PyObject*>(&pyElementwiseProductComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SigmoidComponent", reinterpret_cast<PyObject*>(&pySigmoidComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "TanhComponent", reinterpret_cast<PyObject*>(&pyTanhComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RectifiedLinearComponent", reinterpret_cast<PyObject*>(&pyRectifiedLinearComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "AffineComponent", reinterpret_cast<PyObject*>(&pyAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RepeatedAffineComponent", reinterpret_cast<PyObject*>(&pyRepeatedAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "BlockAffineComponent", reinterpret_cast<PyObject*>(&pyBlockAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "NaturalGradientRepeatedAffineComponent", reinterpret_cast<PyObject*>(&pyNaturalGradientRepeatedAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SoftmaxComponent", reinterpret_cast<PyObject*>(&pySoftmaxComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LogSoftmaxComponent", reinterpret_cast<PyObject*>(&pyLogSoftmaxComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "NaturalGradientAffineComponent", reinterpret_cast<PyObject*>(&pyNaturalGradientAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LinearComponent", reinterpret_cast<PyObject*>(&pyLinearComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "FixedAffineComponent", reinterpret_cast<PyObject*>(&pyFixedAffineComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SumGroupComponent", reinterpret_cast<PyObject*>(&pySumGroupComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "FixedScaleComponent", reinterpret_cast<PyObject*>(&pyFixedScaleComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "FixedBiasComponent", reinterpret_cast<PyObject*>(&pyFixedBiasComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "NoOpComponent", reinterpret_cast<PyObject*>(&pyNoOpComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SumBlockComponent", reinterpret_cast<PyObject*>(&pySumBlockComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ClipGradientComponent", reinterpret_cast<PyObject*>(&pyClipGradientComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "PermuteComponent", reinterpret_cast<PyObject*>(&pyPermuteComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "PerElementScaleComponent", reinterpret_cast<PyObject*>(&pyPerElementScaleComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "PerElementOffsetComponent", reinterpret_cast<PyObject*>(&pyPerElementOffsetComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ConstantFunctionComponent", reinterpret_cast<PyObject*>(&pyConstantFunctionComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "NaturalGradientPerElementScaleComponent", reinterpret_cast<PyObject*>(&pyNaturalGradientPerElementScaleComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ScaleAndOffsetComponent", reinterpret_cast<PyObject*>(&pyScaleAndOffsetComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LstmNonlinearityComponent", reinterpret_cast<PyObject*>(&pyLstmNonlinearityComponent::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompositeComponent", reinterpret_cast<PyObject*>(&pyCompositeComponent::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __nnet__simple__component_clifwrap

namespace kaldi { namespace nnet3 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// AffineComponent to/from ::kaldi::nnet3::AffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::AffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::AffineComponent* cpp = __nnet__simple__component_clifwrap::pyAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::AffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::AffineComponent* cpp = __nnet__simple__component_clifwrap::pyAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::AffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::AffineComponent* cpp = __nnet__simple__component_clifwrap::pyAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert AffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::AffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::AffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::AffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::AffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::AffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::AffineComponent>(std::move(c));
  return py;
}

// BlockAffineComponent to/from ::kaldi::nnet3::BlockAffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::BlockAffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::BlockAffineComponent* cpp = __nnet__simple__component_clifwrap::pyBlockAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::BlockAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BlockAffineComponent* cpp = __nnet__simple__component_clifwrap::pyBlockAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::BlockAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BlockAffineComponent* cpp = __nnet__simple__component_clifwrap::pyBlockAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert BlockAffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::BlockAffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BlockAffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::BlockAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BlockAffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::BlockAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyBlockAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BlockAffineComponent>(std::move(c));
  return py;
}

// ClipGradientComponent to/from ::kaldi::nnet3::ClipGradientComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ClipGradientComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ClipGradientComponent* cpp = __nnet__simple__component_clifwrap::pyClipGradientComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ClipGradientComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ClipGradientComponent* cpp = __nnet__simple__component_clifwrap::pyClipGradientComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ClipGradientComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ClipGradientComponent* cpp = __nnet__simple__component_clifwrap::pyClipGradientComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ClipGradientComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ClipGradientComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ClipGradientComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ClipGradientComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ClipGradientComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ClipGradientComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyClipGradientComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ClipGradientComponent>(std::move(c));
  return py;
}

// CompositeComponent to/from ::kaldi::nnet3::CompositeComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::CompositeComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::CompositeComponent* cpp = __nnet__simple__component_clifwrap::pyCompositeComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::CompositeComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CompositeComponent* cpp = __nnet__simple__component_clifwrap::pyCompositeComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::CompositeComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::CompositeComponent* cpp = __nnet__simple__component_clifwrap::pyCompositeComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompositeComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::CompositeComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CompositeComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::CompositeComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CompositeComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::CompositeComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyCompositeComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::CompositeComponent>(std::move(c));
  return py;
}

// ConstantFunctionComponent to/from ::kaldi::nnet3::ConstantFunctionComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ConstantFunctionComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ConstantFunctionComponent* cpp = __nnet__simple__component_clifwrap::pyConstantFunctionComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ConstantFunctionComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantFunctionComponent* cpp = __nnet__simple__component_clifwrap::pyConstantFunctionComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ConstantFunctionComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantFunctionComponent* cpp = __nnet__simple__component_clifwrap::pyConstantFunctionComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ConstantFunctionComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ConstantFunctionComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantFunctionComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ConstantFunctionComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantFunctionComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ConstantFunctionComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyConstantFunctionComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantFunctionComponent>(std::move(c));
  return py;
}

// DropoutComponent to/from ::kaldi::nnet3::DropoutComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::DropoutComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::DropoutComponent* cpp = __nnet__simple__component_clifwrap::pyDropoutComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::DropoutComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::DropoutComponent* cpp = __nnet__simple__component_clifwrap::pyDropoutComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::DropoutComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::DropoutComponent* cpp = __nnet__simple__component_clifwrap::pyDropoutComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DropoutComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::DropoutComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::DropoutComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::DropoutComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::DropoutComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::DropoutComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyDropoutComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::DropoutComponent>(std::move(c));
  return py;
}

// ElementwiseProductComponent to/from ::kaldi::nnet3::ElementwiseProductComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ElementwiseProductComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ElementwiseProductComponent* cpp = __nnet__simple__component_clifwrap::pyElementwiseProductComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ElementwiseProductComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ElementwiseProductComponent* cpp = __nnet__simple__component_clifwrap::pyElementwiseProductComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ElementwiseProductComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ElementwiseProductComponent* cpp = __nnet__simple__component_clifwrap::pyElementwiseProductComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ElementwiseProductComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ElementwiseProductComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ElementwiseProductComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ElementwiseProductComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ElementwiseProductComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ElementwiseProductComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyElementwiseProductComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ElementwiseProductComponent>(std::move(c));
  return py;
}

// FixedAffineComponent to/from ::kaldi::nnet3::FixedAffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::FixedAffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::FixedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyFixedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::FixedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyFixedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::FixedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyFixedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert FixedAffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::FixedAffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedAffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::FixedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedAffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::FixedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedAffineComponent>(std::move(c));
  return py;
}

// FixedBiasComponent to/from ::kaldi::nnet3::FixedBiasComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::FixedBiasComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::FixedBiasComponent* cpp = __nnet__simple__component_clifwrap::pyFixedBiasComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::FixedBiasComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedBiasComponent* cpp = __nnet__simple__component_clifwrap::pyFixedBiasComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::FixedBiasComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedBiasComponent* cpp = __nnet__simple__component_clifwrap::pyFixedBiasComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert FixedBiasComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::FixedBiasComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedBiasComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::FixedBiasComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedBiasComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::FixedBiasComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedBiasComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedBiasComponent>(std::move(c));
  return py;
}

// FixedScaleComponent to/from ::kaldi::nnet3::FixedScaleComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::FixedScaleComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::FixedScaleComponent* cpp = __nnet__simple__component_clifwrap::pyFixedScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::FixedScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedScaleComponent* cpp = __nnet__simple__component_clifwrap::pyFixedScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::FixedScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::FixedScaleComponent* cpp = __nnet__simple__component_clifwrap::pyFixedScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert FixedScaleComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::FixedScaleComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedScaleComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::FixedScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedScaleComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::FixedScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyFixedScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::FixedScaleComponent>(std::move(c));
  return py;
}

// LinearComponent to/from ::kaldi::nnet3::LinearComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::LinearComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::LinearComponent* cpp = __nnet__simple__component_clifwrap::pyLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::LinearComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LinearComponent* cpp = __nnet__simple__component_clifwrap::pyLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyLinearComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::LinearComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LinearComponent* cpp = __nnet__simple__component_clifwrap::pyLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyLinearComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LinearComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::LinearComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LinearComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::LinearComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LinearComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::LinearComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LinearComponent>(std::move(c));
  return py;
}

// LogSoftmaxComponent to/from ::kaldi::nnet3::LogSoftmaxComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::LogSoftmaxComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::LogSoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pyLogSoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::LogSoftmaxComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LogSoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pyLogSoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::LogSoftmaxComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LogSoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pyLogSoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LogSoftmaxComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::LogSoftmaxComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LogSoftmaxComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::LogSoftmaxComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LogSoftmaxComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::LogSoftmaxComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLogSoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LogSoftmaxComponent>(std::move(c));
  return py;
}

// LstmNonlinearityComponent to/from ::kaldi::nnet3::LstmNonlinearityComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::LstmNonlinearityComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::LstmNonlinearityComponent* cpp = __nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::LstmNonlinearityComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LstmNonlinearityComponent* cpp = __nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::LstmNonlinearityComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::LstmNonlinearityComponent* cpp = __nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LstmNonlinearityComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::LstmNonlinearityComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LstmNonlinearityComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::LstmNonlinearityComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LstmNonlinearityComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::LstmNonlinearityComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyLstmNonlinearityComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::LstmNonlinearityComponent>(std::move(c));
  return py;
}

// NaturalGradientAffineComponent to/from ::kaldi::nnet3::NaturalGradientAffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NaturalGradientAffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NaturalGradientAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NaturalGradientAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NaturalGradientAffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NaturalGradientAffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientAffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientAffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NaturalGradientAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientAffineComponent>(std::move(c));
  return py;
}

// NaturalGradientPerElementScaleComponent to/from ::kaldi::nnet3::NaturalGradientPerElementScaleComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NaturalGradientPerElementScaleComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientPerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NaturalGradientPerElementScaleComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NaturalGradientPerElementScaleComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NaturalGradientPerElementScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientPerElementScaleComponent>(std::move(c));
  return py;
}

// NaturalGradientRepeatedAffineComponent to/from ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NaturalGradientRepeatedAffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NaturalGradientRepeatedAffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNaturalGradientRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NaturalGradientRepeatedAffineComponent>(std::move(c));
  return py;
}

// NoOpComponent to/from ::kaldi::nnet3::NoOpComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NoOpComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NoOpComponent* cpp = __nnet__simple__component_clifwrap::pyNoOpComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NoOpComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NoOpComponent* cpp = __nnet__simple__component_clifwrap::pyNoOpComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NoOpComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NoOpComponent* cpp = __nnet__simple__component_clifwrap::pyNoOpComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NoOpComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NoOpComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NoOpComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NoOpComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NoOpComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NoOpComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyNoOpComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NoOpComponent>(std::move(c));
  return py;
}

// PerElementOffsetComponent to/from ::kaldi::nnet3::PerElementOffsetComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::PerElementOffsetComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::PerElementOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::PerElementOffsetComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PerElementOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::PerElementOffsetComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PerElementOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert PerElementOffsetComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::PerElementOffsetComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementOffsetComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::PerElementOffsetComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementOffsetComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::PerElementOffsetComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementOffsetComponent>(std::move(c));
  return py;
}

// PerElementScaleComponent to/from ::kaldi::nnet3::PerElementScaleComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::PerElementScaleComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::PerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::PerElementScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::PerElementScaleComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PerElementScaleComponent* cpp = __nnet__simple__component_clifwrap::pyPerElementScaleComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert PerElementScaleComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::PerElementScaleComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementScaleComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::PerElementScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementScaleComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::PerElementScaleComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPerElementScaleComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PerElementScaleComponent>(std::move(c));
  return py;
}

// PermuteComponent to/from ::kaldi::nnet3::PermuteComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::PermuteComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::PermuteComponent* cpp = __nnet__simple__component_clifwrap::pyPermuteComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::PermuteComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PermuteComponent* cpp = __nnet__simple__component_clifwrap::pyPermuteComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::PermuteComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PermuteComponent* cpp = __nnet__simple__component_clifwrap::pyPermuteComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert PermuteComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::PermuteComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PermuteComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::PermuteComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PermuteComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::PermuteComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPermuteComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PermuteComponent>(std::move(c));
  return py;
}

// PnormComponent to/from ::kaldi::nnet3::PnormComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::PnormComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::PnormComponent* cpp = __nnet__simple__component_clifwrap::pyPnormComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::PnormComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PnormComponent* cpp = __nnet__simple__component_clifwrap::pyPnormComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyPnormComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::PnormComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::PnormComponent* cpp = __nnet__simple__component_clifwrap::pyPnormComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyPnormComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert PnormComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::PnormComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPnormComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPnormComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PnormComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::PnormComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPnormComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPnormComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PnormComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::PnormComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyPnormComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyPnormComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::PnormComponent>(std::move(c));
  return py;
}

// RectifiedLinearComponent to/from ::kaldi::nnet3::RectifiedLinearComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::RectifiedLinearComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::RectifiedLinearComponent* cpp = __nnet__simple__component_clifwrap::pyRectifiedLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::RectifiedLinearComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RectifiedLinearComponent* cpp = __nnet__simple__component_clifwrap::pyRectifiedLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::RectifiedLinearComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RectifiedLinearComponent* cpp = __nnet__simple__component_clifwrap::pyRectifiedLinearComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RectifiedLinearComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::RectifiedLinearComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RectifiedLinearComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::RectifiedLinearComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RectifiedLinearComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::RectifiedLinearComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRectifiedLinearComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RectifiedLinearComponent>(std::move(c));
  return py;
}

// RepeatedAffineComponent to/from ::kaldi::nnet3::RepeatedAffineComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::RepeatedAffineComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::RepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::RepeatedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::RepeatedAffineComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RepeatedAffineComponent* cpp = __nnet__simple__component_clifwrap::pyRepeatedAffineComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RepeatedAffineComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::RepeatedAffineComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RepeatedAffineComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::RepeatedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RepeatedAffineComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::RepeatedAffineComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyRepeatedAffineComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RepeatedAffineComponent>(std::move(c));
  return py;
}

// ScaleAndOffsetComponent to/from ::kaldi::nnet3::ScaleAndOffsetComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ScaleAndOffsetComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ScaleAndOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ScaleAndOffsetComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ScaleAndOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ScaleAndOffsetComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ScaleAndOffsetComponent* cpp = __nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ScaleAndOffsetComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ScaleAndOffsetComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ScaleAndOffsetComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ScaleAndOffsetComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ScaleAndOffsetComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ScaleAndOffsetComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyScaleAndOffsetComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ScaleAndOffsetComponent>(std::move(c));
  return py;
}

// SigmoidComponent to/from ::kaldi::nnet3::SigmoidComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SigmoidComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SigmoidComponent* cpp = __nnet__simple__component_clifwrap::pySigmoidComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SigmoidComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SigmoidComponent* cpp = __nnet__simple__component_clifwrap::pySigmoidComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SigmoidComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SigmoidComponent* cpp = __nnet__simple__component_clifwrap::pySigmoidComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SigmoidComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SigmoidComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SigmoidComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SigmoidComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SigmoidComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SigmoidComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySigmoidComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SigmoidComponent>(std::move(c));
  return py;
}

// SoftmaxComponent to/from ::kaldi::nnet3::SoftmaxComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SoftmaxComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pySoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SoftmaxComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pySoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SoftmaxComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SoftmaxComponent* cpp = __nnet__simple__component_clifwrap::pySoftmaxComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SoftmaxComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SoftmaxComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SoftmaxComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SoftmaxComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SoftmaxComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SoftmaxComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySoftmaxComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SoftmaxComponent>(std::move(c));
  return py;
}

// SumBlockComponent to/from ::kaldi::nnet3::SumBlockComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SumBlockComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SumBlockComponent* cpp = __nnet__simple__component_clifwrap::pySumBlockComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SumBlockComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumBlockComponent* cpp = __nnet__simple__component_clifwrap::pySumBlockComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SumBlockComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumBlockComponent* cpp = __nnet__simple__component_clifwrap::pySumBlockComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SumBlockComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SumBlockComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumBlockComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SumBlockComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumBlockComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SumBlockComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumBlockComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumBlockComponent>(std::move(c));
  return py;
}

// SumGroupComponent to/from ::kaldi::nnet3::SumGroupComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SumGroupComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SumGroupComponent* cpp = __nnet__simple__component_clifwrap::pySumGroupComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SumGroupComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumGroupComponent* cpp = __nnet__simple__component_clifwrap::pySumGroupComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SumGroupComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumGroupComponent* cpp = __nnet__simple__component_clifwrap::pySumGroupComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SumGroupComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SumGroupComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumGroupComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SumGroupComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumGroupComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SumGroupComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pySumGroupComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumGroupComponent>(std::move(c));
  return py;
}

// TanhComponent to/from ::kaldi::nnet3::TanhComponent conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::TanhComponent** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::TanhComponent* cpp = __nnet__simple__component_clifwrap::pyTanhComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::TanhComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::TanhComponent* cpp = __nnet__simple__component_clifwrap::pyTanhComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__simple__component_clifwrap::pyTanhComponent::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::TanhComponent>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::TanhComponent* cpp = __nnet__simple__component_clifwrap::pyTanhComponent::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__simple__component_clifwrap::pyTanhComponent::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert TanhComponent instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::TanhComponent* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyTanhComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyTanhComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::TanhComponent>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::TanhComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyTanhComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyTanhComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::TanhComponent>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::TanhComponent> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__simple__component_clifwrap::pyTanhComponent::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__simple__component_clifwrap::pyTanhComponent::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::TanhComponent>(std::move(c));
  return py;
}

} }  // namespace kaldi::nnet3
