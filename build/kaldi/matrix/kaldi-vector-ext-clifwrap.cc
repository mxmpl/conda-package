//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/kaldi-vector-ext.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/packed-matrix-clifwrap.h"
#include "matrix/sp-matrix-clifwrap.h"
#include "matrix/tp-matrix-clifwrap.h"
#include "kaldi-vector-ext-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__vector__ext_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _copy_from_packed(self:VectorBase, M:PackedMatrix)
static PyObject* wrapCopyFromPacked_as__copy_from_packed(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_packed", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_packed", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::PackedMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_packed", names[1], "::kaldi::PackedMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_double_packed(self:VectorBase, M:DoublePackedMatrix)
static PyObject* wrapCopyFromPacked_as__copy_from_double_packed(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_double_packed", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_double_packed", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::PackedMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_double_packed", names[1], "::kaldi::PackedMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_double_vec(self:VectorBase, v:DoubleVectorBase)
static PyObject* wrapCopyFromVec_as__copy_from_double_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_double_vec", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_double_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_double_vec", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromVec(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_double_vec(self:VectorBase, alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVec_as__add_double_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_double_vec", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_double_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_double_vec", names[1], "float", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_double_vec", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddVec(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_double_vec2(self:VectorBase, alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVec2_as__add_double_vec2(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_double_vec2", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_double_vec2", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_double_vec2", names[1], "float", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_double_vec2", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddVec2(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_vec(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType, v:VectorBase, beta:float)
static PyObject* wrapAddMatVec_as__add_mat_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_vec", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_vec", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_vec", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_vec", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_vec", names[4], "::kaldi::VectorBase<float>", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_vec", names[5], "float", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatVec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_svec(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType, v:VectorBase, beta:float)
static PyObject* wrapAddMatSvec_as__add_mat_svec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_svec", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_svec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_svec", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_svec", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_svec", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_svec", names[4], "::kaldi::VectorBase<float>", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_svec", names[5], "float", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatSvec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_vec(self:VectorBase, alpha:float, M:SpMatrix, v:VectorBase, beta:float)
static PyObject* wrapAddSpVec_as__add_sp_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_add_sp_vec", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_vec", names[1], "float", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_vec", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::VectorBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_vec", names[3], "::kaldi::VectorBase<float>", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_vec", names[4], "float", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpVec(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_vec(self:VectorBase, alpha:float, M:TpMatrix, trans:MatrixTransposeType, v:VectorBase, beta:float)
static PyObject* wrapAddTpVec_as__add_tp_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_tp_vec", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_vec", names[1], "float", a[1]);
  ::kaldi::TpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_vec", names[2], "::kaldi::TpMatrix<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_vec", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_vec", names[4], "::kaldi::VectorBase<float>", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_vec", names[5], "float", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpVec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _mul_double_elements(self:VectorBase, v:DoubleVectorBase)
static PyObject* wrapMulElements_as__mul_double_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_mul_double_elements", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_double_elements", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_mul_double_elements", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::MulElements(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _div_double_elements(self:VectorBase, v:DoubleVectorBase)
static PyObject* wrapDivElements_as__div_double_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_div_double_elements", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_div_double_elements", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_div_double_elements", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::DivElements(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _mul_tp(self:VectorBase, M:TpMatrix, trans:MatrixTransposeType)
static PyObject* wrapMulTp_as__mul_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_mul_tp", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_tp", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::TpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_mul_tp", names[1], "::kaldi::TpMatrix<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_mul_tp", names[2], "::kaldi::MatrixTransposeType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::MulTp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _solve(self:VectorBase, M:TpMatrix, trans:MatrixTransposeType)
static PyObject* wrapSolve_as__solve(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_solve", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_solve", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::TpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_solve", names[1], "::kaldi::TpMatrix<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_solve", names[2], "::kaldi::MatrixTransposeType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::Solve(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows_from_mat(self:VectorBase, M:MatrixBase)
static PyObject* wrapCopyRowsFromMat_as__copy_rows_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_rows_from_mat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows_from_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows_from_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows_from_double_mat(self:VectorBase, M:DoubleMatrixBase)
static PyObject* wrapCopyRowsFromMat_as__copy_rows_from_double_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_rows_from_double_mat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows_from_double_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows_from_double_mat", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_cols_from_mat(self:VectorBase, M:MatrixBase)
static PyObject* wrapCopyColsFromMat_as__copy_cols_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_cols_from_mat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_cols_from_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_cols_from_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_mat(self:VectorBase, M:MatrixBase, row:int)
static PyObject* wrapCopyRowFromMat_as__copy_row_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_mat", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_double_mat(self:VectorBase, M:DoubleMatrixBase, row:int)
static PyObject* wrapCopyRowFromMat_as__copy_row_from_double_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_double_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_double_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_double_mat", names[1], "::kaldi::MatrixBase<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_double_mat", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_sp(self:VectorBase, M:SpMatrix, row:int)
static PyObject* wrapCopyRowFromSp_as__copy_row_from_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_sp", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_sp", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_sp", names[1], "::kaldi::SpMatrix<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_sp", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromSp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_double_sp(self:VectorBase, M:DoubleSpMatrix, row:int)
static PyObject* wrapCopyRowFromSp_as__copy_row_from_double_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_double_sp", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_double_sp", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_double_sp", names[1], "::kaldi::SpMatrix<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_double_sp", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromSp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_col_from_mat(self:VectorBase, M:MatrixBase, col:int)
static PyObject* wrapCopyColFromMat_as__copy_col_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_col_from_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_col_from_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_col_from_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_col_from_mat", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_col_from_double_mat(self:VectorBase, M:DoubleMatrixBase, col:int)
static PyObject* wrapCopyColFromMat_as__copy_col_from_double_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_col_from_double_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_col_from_double_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_col_from_double_mat", names[1], "::kaldi::MatrixBase<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_col_from_double_mat", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_mat(self:VectorBase, M:MatrixBase)
static PyObject* wrapCopyDiagFromMat_as__copy_diag_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_mat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_packed(self:VectorBase, M:PackedMatrix)
static PyObject* wrapCopyDiagFromPacked_as__copy_diag_from_packed(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_packed", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_packed", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::PackedMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_packed", names[1], "::kaldi::PackedMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_sp(self:VectorBase, M:SpMatrix)
static PyObject* wrapCopyDiagFromSp_as__copy_diag_from_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_sp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_sp", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_sp", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_tp(self:VectorBase, M:TpMatrix)
static PyObject* wrapCopyDiagFromTp_as__copy_diag_from_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_tp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_tp", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::TpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_tp", names[1], "::kaldi::TpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromTp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_row_sum_mat(self:VectorBase, alpha:float, M:MatrixBase, beta:float=default)
static PyObject* wrapAddRowSumMat_as__add_row_sum_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:_add_row_sum_mat", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_row_sum_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_row_sum_mat", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_row_sum_mat", names[2], "::kaldi::MatrixBase<float>", a[2]);
  float arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_row_sum_mat", names[3], "float", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddRowSumMat(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddRowSumMat(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_col_sum_mat(self:VectorBase, alpha:float, M:MatrixBase, beta:float=default)
static PyObject* wrapAddColSumMat_as__add_col_sum_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:_add_col_sum_mat", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_col_sum_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_col_sum_mat", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_col_sum_mat", names[2], "::kaldi::MatrixBase<float>", a[2]);
  float arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_col_sum_mat", names[3], "float", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddColSumMat(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddColSumMat(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_diag_mat2(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType=default, beta:float=default)
static PyObject* wrapAddDiagMat2_as__add_diag_mat2(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:_add_diag_mat2", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_diag_mat2", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_diag_mat2", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_diag_mat2", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("_add_diag_mat2", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_diag_mat2", names[3], "::kaldi::MatrixTransposeType", a[3]);
  }
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_diag_mat2", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  case 5:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_diag_mat_mat(self:VectorBase, alpha:float, M:MatrixBase, transM:MatrixTransposeType, N:MatrixBase, transN:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagMatMat_as__add_diag_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("transM"),
      C("N"),
      C("transN"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO|O:_add_diag_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 7; nargs > 6; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_diag_mat_mat", names[0], "::kaldi::VectorBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_diag_mat_mat", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_diag_mat_mat", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_diag_mat_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_diag_mat_mat", names[4], "::kaldi::MatrixBase<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_diag_mat_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  float arg7;
  if (nargs > 6) {
    if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_diag_mat_mat", names[6], "float", a[6]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 6:
    ::kaldi::AddDiagMatMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6)); break;
  case 7:
    ::kaldi::AddDiagMatMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _vec_mat_vec(v1:VectorBase, M:MatrixBase, v2:VectorBase) -> float
static PyObject* wrapVecMatVec_as__vec_mat_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("v1"),
      C("M"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_vec_mat_vec", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_mat_vec", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_mat_vec", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_vec_mat_vec", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecMatVec(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _copy_from_packed_double(self:DoubleVectorBase, M:DoublePackedMatrix)
static PyObject* wrapCopyFromPacked_as__copy_from_packed_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_packed_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_packed_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::PackedMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_packed_double", names[1], "::kaldi::PackedMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_single_packed_double(self:DoubleVectorBase, M:PackedMatrix)
static PyObject* wrapCopyFromPacked_as__copy_from_single_packed_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_single_packed_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_single_packed_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::PackedMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_single_packed_double", names[1], "::kaldi::PackedMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_single_vec_double(self:DoubleVectorBase, v:VectorBase)
static PyObject* wrapCopyFromVec_as__copy_from_single_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_single_vec_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_single_vec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_single_vec_double", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromVec(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_single_vec_double(self:DoubleVectorBase, alpha:float, v:VectorBase)
static PyObject* wrapAddVec_as__add_single_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_single_vec_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_single_vec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_single_vec_double", names[1], "double", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_single_vec_double", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddVec(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_single_vec2_double(self:DoubleVectorBase, alpha:float, v:VectorBase)
static PyObject* wrapAddVec2_as__add_single_vec2_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_single_vec2_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_single_vec2_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_single_vec2_double", names[1], "double", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_single_vec2_double", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddVec2(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)
static PyObject* wrapAddMatVec_as__add_mat_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_vec_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_vec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_vec_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_vec_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_vec_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_vec_double", names[4], "::kaldi::VectorBase<double>", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_vec_double", names[5], "double", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatVec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_svec_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)
static PyObject* wrapAddMatSvec_as__add_mat_svec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_svec_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_svec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_svec_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_svec_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_svec_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_svec_double", names[4], "::kaldi::VectorBase<double>", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_svec_double", names[5], "double", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatSvec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleSpMatrix, v:DoubleVectorBase, beta:float)
static PyObject* wrapAddSpVec_as__add_sp_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_add_sp_vec_double", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_vec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_vec_double", names[1], "double", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_vec_double", names[2], "::kaldi::SpMatrix<double>", a[2]);
  ::kaldi::VectorBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_vec_double", names[3], "::kaldi::VectorBase<double>", a[3]);
  double arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_vec_double", names[4], "double", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpVec(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleTpMatrix, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)
static PyObject* wrapAddTpVec_as__add_tp_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_tp_vec_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_vec_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_vec_double", names[1], "double", a[1]);
  ::kaldi::TpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_vec_double", names[2], "::kaldi::TpMatrix<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_vec_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::VectorBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_vec_double", names[4], "::kaldi::VectorBase<double>", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_vec_double", names[5], "double", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpVec(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _mul_single_elements_double(self:DoubleVectorBase, v:VectorBase)
static PyObject* wrapMulElements_as__mul_single_elements_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_mul_single_elements_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_single_elements_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_mul_single_elements_double", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::MulElements(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _div_single_elements_double(self:DoubleVectorBase, v:VectorBase)
static PyObject* wrapDivElements_as__div_single_elements_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_div_single_elements_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_div_single_elements_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_div_single_elements_double", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::DivElements(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _mul_tp_double(self:DoubleVectorBase, M:DoubleTpMatrix, trans:MatrixTransposeType)
static PyObject* wrapMulTp_as__mul_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_mul_tp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_tp_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::TpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_mul_tp_double", names[1], "::kaldi::TpMatrix<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_mul_tp_double", names[2], "::kaldi::MatrixTransposeType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::MulTp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _solve_double(self:DoubleVectorBase, M:DoubleTpMatrix, trans:MatrixTransposeType)
static PyObject* wrapSolve_as__solve_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_solve_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_solve_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::TpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_solve_double", names[1], "::kaldi::TpMatrix<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_solve_double", names[2], "::kaldi::MatrixTransposeType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::Solve(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)
static PyObject* wrapCopyRowsFromMat_as__copy_rows_from_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_rows_from_mat_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows_from_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows_from_mat_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase)
static PyObject* wrapCopyRowsFromMat_as__copy_rows_from_single_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_rows_from_single_mat_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows_from_single_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows_from_single_mat_double", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_cols_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)
static PyObject* wrapCopyColsFromMat_as__copy_cols_from_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_cols_from_mat_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_cols_from_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_cols_from_mat_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColsFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase, row:int)
static PyObject* wrapCopyRowFromMat_as__copy_row_from_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_mat_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_mat_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_mat_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase, row:int)
static PyObject* wrapCopyRowFromMat_as__copy_row_from_single_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_single_mat_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_single_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_single_mat_double", names[1], "::kaldi::MatrixBase<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_single_mat_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_sp_double(self:DoubleVectorBase, M:DoubleSpMatrix, row:int)
static PyObject* wrapCopyRowFromSp_as__copy_row_from_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_sp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_sp_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_sp_double", names[1], "::kaldi::SpMatrix<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_sp_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromSp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_row_from_single_sp_double(self:DoubleVectorBase, M:SpMatrix, row:int)
static PyObject* wrapCopyRowFromSp_as__copy_row_from_single_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_row_from_single_sp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_row_from_single_sp_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_row_from_single_sp_double", names[1], "::kaldi::SpMatrix<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_row_from_single_sp_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRowFromSp(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_col_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase, col:int)
static PyObject* wrapCopyColFromMat_as__copy_col_from_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_col_from_mat_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_col_from_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_col_from_mat_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_col_from_mat_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_col_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase, col:int)
static PyObject* wrapCopyColFromMat_as__copy_col_from_single_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("M"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_col_from_single_mat_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_col_from_single_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_col_from_single_mat_double", names[1], "::kaldi::MatrixBase<float>", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_col_from_single_mat_double", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyColFromMat(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)
static PyObject* wrapCopyDiagFromMat_as__copy_diag_from_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_mat_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_mat_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromMat(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_packed_double(self:DoubleVectorBase, M:DoublePackedMatrix)
static PyObject* wrapCopyDiagFromPacked_as__copy_diag_from_packed_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_packed_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_packed_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::PackedMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_packed_double", names[1], "::kaldi::PackedMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromPacked(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_sp_double(self:DoubleVectorBase, M:DoubleSpMatrix)
static PyObject* wrapCopyDiagFromSp_as__copy_diag_from_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_sp_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_sp_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_sp_double", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_diag_from_tp_double(self:DoubleVectorBase, M:DoubleTpMatrix)
static PyObject* wrapCopyDiagFromTp_as__copy_diag_from_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_diag_from_tp_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_diag_from_tp_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::TpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_diag_from_tp_double", names[1], "::kaldi::TpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyDiagFromTp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_row_sum_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, beta:float=default)
static PyObject* wrapAddRowSumMat_as__add_row_sum_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:_add_row_sum_mat_double", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_row_sum_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_row_sum_mat_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_row_sum_mat_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  double arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_row_sum_mat_double", names[3], "double", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddRowSumMat(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddRowSumMat(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_col_sum_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, beta:float=default)
static PyObject* wrapAddColSumMat_as__add_col_sum_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|O:_add_col_sum_mat_double", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_col_sum_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_col_sum_mat_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_col_sum_mat_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  double arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_col_sum_mat_double", names[3], "double", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddColSumMat(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddColSumMat(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_diag_mat2_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType=default, beta:float=default)
static PyObject* wrapAddDiagMat2_as__add_diag_mat2_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("trans"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:_add_diag_mat2_double", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_diag_mat2_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_diag_mat2_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_diag_mat2_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("_add_diag_mat2_double", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_diag_mat2_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  }
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_diag_mat2_double", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  case 5:
    ::kaldi::AddDiagMat2(arg1, std::move(arg2), *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_diag_mat_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, N:DoubleMatrixBase, transN:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagMatMat_as__add_diag_mat_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7]{};
  char* names[] = {
      C("self"),
      C("alpha"),
      C("M"),
      C("transM"),
      C("N"),
      C("transN"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO|O:_add_diag_mat_mat_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 7; nargs > 6; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_diag_mat_mat_double", names[0], "::kaldi::VectorBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_diag_mat_mat_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_diag_mat_mat_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_diag_mat_mat_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_diag_mat_mat_double", names[4], "::kaldi::MatrixBase<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_diag_mat_mat_double", names[5], "::kaldi::MatrixTransposeType", a[5]);
  double arg7;
  if (nargs > 6) {
    if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_diag_mat_mat_double", names[6], "double", a[6]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 6:
    ::kaldi::AddDiagMatMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6)); break;
  case 7:
    ::kaldi::AddDiagMatMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _vec_mat_vec_double(v1:DoubleVectorBase, M:DoubleMatrixBase, v2:DoubleVectorBase) -> float
static PyObject* wrapVecMatVec_as__vec_mat_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("v1"),
      C("M"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_vec_mat_vec_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_mat_vec_double", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_mat_vec_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_vec_mat_vec_double", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecMatVec(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_copy_from_packed"), (PyCFunction)wrapCopyFromPacked_as__copy_from_packed, METH_VARARGS | METH_KEYWORDS, C("_copy_from_packed(self:VectorBase, M:PackedMatrix)\n\nCopy data from a Packed Matrix(triangular or symmetric)\n\nArgs:\n    M(PackedMatrix): A triangular or symmetric matrix")},
  {C("_copy_from_double_packed"), (PyCFunction)wrapCopyFromPacked_as__copy_from_double_packed, METH_VARARGS | METH_KEYWORDS, C("_copy_from_double_packed(self:VectorBase, M:DoublePackedMatrix)\n\nCopy data from a Packed Matrix(triangular or symmetric)\n\nArgs:\n    M(DoublePackedMatrix): A triangular or symmetric matrix")},
  {C("_copy_from_double_vec"), (PyCFunction)wrapCopyFromVec_as__copy_from_double_vec, METH_VARARGS | METH_KEYWORDS, C("_copy_from_double_vec(self:VectorBase, v:DoubleVectorBase)\n\nCopy data from a vector\n\nArgs:\n    v(DoubleVectorBase): A vector")},
  {C("_add_double_vec"), (PyCFunction)wrapAddVec_as__add_double_vec, METH_VARARGS | METH_KEYWORDS, C("_add_double_vec(self:VectorBase, alpha:float, v:DoubleVectorBase)\n\nAdd a vector\n\nArgs:\n    v(DoubleVectorBase): A vector")},
  {C("_add_double_vec2"), (PyCFunction)wrapAddVec2_as__add_double_vec2, METH_VARARGS | METH_KEYWORDS, C("_add_double_vec2(self:VectorBase, alpha:float, v:DoubleVectorBase)\n\nAdd a vector squared\n\nArgs:\n    v(DoubleVectorBase): A vector")},
  {C("_add_mat_vec"), (PyCFunction)wrapAddMatVec_as__add_mat_vec, METH_VARARGS | METH_KEYWORDS, C("_add_mat_vec(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType, v:VectorBase, beta:float)\n\nScale self and add a matrix*vector, e.g. self = beta*self + alpha*M*v.\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(VectorBase): A vector\n    beta(float): A scaling constant.\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_mat_svec"), (PyCFunction)wrapAddMatSvec_as__add_mat_svec, METH_VARARGS | METH_KEYWORDS, C("_add_mat_svec(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType, v:VectorBase, beta:float)\n\nSame as AddMatVec, but optimized when v contains a lot of zeros.\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(VectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_sp_vec"), (PyCFunction)wrapAddSpVec_as__add_sp_vec, METH_VARARGS | METH_KEYWORDS, C("_add_sp_vec(self:VectorBase, alpha:float, M:SpMatrix, v:VectorBase, beta:float)\n\nSame as AddMatVec, but optimized when M is symmetric positive definite.\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(VectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_tp_vec"), (PyCFunction)wrapAddTpVec_as__add_tp_vec, METH_VARARGS | METH_KEYWORDS, C("_add_tp_vec(self:VectorBase, alpha:float, M:TpMatrix, trans:MatrixTransposeType, v:VectorBase, beta:float)\n\nSame as AddMatVec, but optimized when M is triangular.\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(VectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_mul_double_elements"), (PyCFunction)wrapMulElements_as__mul_double_elements, METH_VARARGS | METH_KEYWORDS, C("_mul_double_elements(self:VectorBase, v:DoubleVectorBase)\n\nMultiply elements with elements of another vector\n\nArgs:\n    v(DoubleVectorBase): A vector")},
  {C("_div_double_elements"), (PyCFunction)wrapDivElements_as__div_double_elements, METH_VARARGS | METH_KEYWORDS, C("_div_double_elements(self:VectorBase, v:DoubleVectorBase)\n\nDivide elements with elements of another vector\n\nArgs:\n    v(DoubleVectorBase): A vector")},
  {C("_mul_tp"), (PyCFunction)wrapMulTp_as__mul_tp, METH_VARARGS | METH_KEYWORDS, C("_mul_tp(self:VectorBase, M:TpMatrix, trans:MatrixTransposeType)\n\nMultiplies this vector by lower-triangular matrix: self = self*M\n\nArgs:\n    M(TpMatrix): A lower triangularMatrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_solve"), (PyCFunction)wrapSolve_as__solve, METH_VARARGS | METH_KEYWORDS, C("_solve(self:VectorBase, M:TpMatrix, trans:MatrixTransposeType)\n\nIf trans == kNoTrans, solves M*x = b, where b is the value of self input\n   and x is the value of self at output. If trans == kTrans, solves M'*x = b.\n   Does not test for M being singular or near-singular.\n\nArgs:\n    M(TpMatrix): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_copy_rows_from_mat"), (PyCFunction)wrapCopyRowsFromMat_as__copy_rows_from_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_rows_from_mat(self:VectorBase, M:MatrixBase)\n\nStacks all the rows of matrix M into a vector and copies it to self\n\nArgs:\n    M(MatrixBase): The matrix whose rows will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_rows_from_double_mat"), (PyCFunction)wrapCopyRowsFromMat_as__copy_rows_from_double_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_rows_from_double_mat(self:VectorBase, M:DoubleMatrixBase)\n\nStacks all the rows of matrix M into a vector and copies it to self\n\nArgs:\n    M(DoubleMatrixBase): The matrix whose rows will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_cols_from_mat"), (PyCFunction)wrapCopyColsFromMat_as__copy_cols_from_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_cols_from_mat(self:VectorBase, M:MatrixBase)\n\nStacks all the columns of matrix M into a vector and copies it to self\n\nArgs:\n    M(MatrixBase): The matrix whose columns will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_row_from_mat"), (PyCFunction)wrapCopyRowFromMat_as__copy_row_from_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_mat(self:VectorBase, M:MatrixBase, row:int)\n\nExtracts a row of the matrix M and copies it to self.\n\nArgs:\n    M(MatrixBase): The matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_double_mat"), (PyCFunction)wrapCopyRowFromMat_as__copy_row_from_double_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_double_mat(self:VectorBase, M:DoubleMatrixBase, row:int)\n\nExtracts a row of the matrix M and copies it to self.\n\nArgs:\n    M(DoubleMatrixBase): The matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_sp"), (PyCFunction)wrapCopyRowFromSp_as__copy_row_from_sp, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_sp(self:VectorBase, M:SpMatrix, row:int)\n\nExtracts a row of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(SpMatrix): The symmetric matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_double_sp"), (PyCFunction)wrapCopyRowFromSp_as__copy_row_from_double_sp, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_double_sp(self:VectorBase, M:DoubleSpMatrix, row:int)\n\nExtracts a row of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(DoubleSpMatrix): The symmetric matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_col_from_mat"), (PyCFunction)wrapCopyColFromMat_as__copy_col_from_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_col_from_mat(self:VectorBase, M:MatrixBase, col:int)\n\nExtracts a column of the matrix M and copies it to self.\n\nArgs:\n    M(MatrixBase): The matrix from which we will extract a column\n    col(int): An index to the column of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if col>=M.cols")},
  {C("_copy_col_from_double_mat"), (PyCFunction)wrapCopyColFromMat_as__copy_col_from_double_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_col_from_double_mat(self:VectorBase, M:DoubleMatrixBase, col:int)\n\nExtracts a column of the matrix M and copies it to self.\n\nArgs:\n    M(DoubleMatrixBase): The matrix from which we will extract a column\n    col(int): An index to the column of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if col>=M.cols")},
  {C("_copy_diag_from_mat"), (PyCFunction)wrapCopyDiagFromMat_as__copy_diag_from_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_mat(self:VectorBase, M:MatrixBase)\n\nExtracts the diagonal of the matrix M and copies it to self.\n\nArgs:\n    M(MatrixBase): The matrix from which we will extract its diagonal\n\nRaises:\n    Error if self.dim != min(M.rows, M.cols)")},
  {C("_copy_diag_from_packed"), (PyCFunction)wrapCopyDiagFromPacked_as__copy_diag_from_packed, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_packed(self:VectorBase, M:PackedMatrix)\n\nExtracts the diagonal of the packed matrix M and copies it to self.\n\nArgs:\n    M(PackedMatrix): A triangular or symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_copy_diag_from_sp"), (PyCFunction)wrapCopyDiagFromSp_as__copy_diag_from_sp, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_sp(self:VectorBase, M:SpMatrix)\n\nExtracts the diagonal of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(SpMatrix): A symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_copy_diag_from_tp"), (PyCFunction)wrapCopyDiagFromTp_as__copy_diag_from_tp, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_tp(self:VectorBase, M:TpMatrix)\n\nExtracts the diagonal of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(TpMatrix): A symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_add_row_sum_mat"), (PyCFunction)wrapAddRowSumMat_as__add_row_sum_mat, METH_VARARGS | METH_KEYWORDS, C("_add_row_sum_mat(self:VectorBase, alpha:float, M:MatrixBase, beta:float=default)\n\nPerforms the operation self = alpha * (sum of rows of M) + beta * self\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of self.dim != M.cols")},
  {C("_add_col_sum_mat"), (PyCFunction)wrapAddColSumMat_as__add_col_sum_mat, METH_VARARGS | METH_KEYWORDS, C("_add_col_sum_mat(self:VectorBase, alpha:float, M:MatrixBase, beta:float=default)\n\nPerforms the operation self = alpha * (sum of cols of M) + beta * self\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of self.dim != M.rows")},
  {C("_add_diag_mat2"), (PyCFunction)wrapAddDiagMat2_as__add_diag_mat2, METH_VARARGS | METH_KEYWORDS, C("_add_diag_mat2(self:VectorBase, alpha:float, M:MatrixBase, trans:MatrixTransposeType=default, beta:float=default)\n\nPerform the operation self = alpha*diag(M*M^T) + beta*self (if trans == kNoTrans),\n   or self = alpha*diag(M^T*M) + beta*self (if trans == kTrans).\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A matrix\n    trans(MatrixTransposeType): kNoTrans(default) or kTrans\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_diag_mat_mat"), (PyCFunction)wrapAddDiagMatMat_as__add_diag_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_add_diag_mat_mat(self:VectorBase, alpha:float, M:MatrixBase, transM:MatrixTransposeType, N:MatrixBase, transN:MatrixTransposeType, beta:float=default)\n\nPerform the operation self = alpha*diag(M*N) + beta*self.\n\nArgs:\n    alpha(float): A scaling constant\n    M(MatrixBase): A matrix\n    N(MatrixBase): A matrix\n    transM(MatrixTransposeType): kNoTrans(default) or kTrans, denotes if we are going to use matrix M or its transpose\n    transN(MatrixTransposeType): kNoTrans(default) or kTrans, denotes if we are going to use matrix N or its transpose\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_vec_mat_vec"), (PyCFunction)wrapVecMatVec_as__vec_mat_vec, METH_VARARGS | METH_KEYWORDS, C("_vec_mat_vec(v1:VectorBase, M:MatrixBase, v2:VectorBase) -> float\n\nPerforms the operation v1'*M*v2\n\nArgs:\n    v1(VectorBase): a vector\n    M(MatrixBase): a matrix\n    v2(VectorBase): a vector\n\nReturns:\n   The outcome of v1'*M*v2\n\nRaises:\n   Error in case of dimension mismatch")},
  {C("_copy_from_packed_double"), (PyCFunction)wrapCopyFromPacked_as__copy_from_packed_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_packed_double(self:DoubleVectorBase, M:DoublePackedMatrix)\n\nCopy data from a Packed Matrix(triangular or symmetric)\n\nArgs:\n    M(DoublePackedMatrix): A triangular or symmetric matrix")},
  {C("_copy_from_single_packed_double"), (PyCFunction)wrapCopyFromPacked_as__copy_from_single_packed_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_single_packed_double(self:DoubleVectorBase, M:PackedMatrix)\n\nCopy data from a Packed Matrix(triangular or symmetric)\n\nArgs:\n    M(PackedMatrix): A triangular or symmetric matrix")},
  {C("_copy_from_single_vec_double"), (PyCFunction)wrapCopyFromVec_as__copy_from_single_vec_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_single_vec_double(self:DoubleVectorBase, v:VectorBase)\n\nCopy data from a vector\n\nArgs:\n    v(VectorBase): A vector")},
  {C("_add_single_vec_double"), (PyCFunction)wrapAddVec_as__add_single_vec_double, METH_VARARGS | METH_KEYWORDS, C("_add_single_vec_double(self:DoubleVectorBase, alpha:float, v:VectorBase)\n\nAdd a vector\n\nArgs:\n    v(VectorBase): A vector")},
  {C("_add_single_vec2_double"), (PyCFunction)wrapAddVec2_as__add_single_vec2_double, METH_VARARGS | METH_KEYWORDS, C("_add_single_vec2_double(self:DoubleVectorBase, alpha:float, v:VectorBase)\n\nAdd a vector squared\n\nArgs:\n    v(VectorBase): A vector")},
  {C("_add_mat_vec_double"), (PyCFunction)wrapAddMatVec_as__add_mat_vec_double, METH_VARARGS | METH_KEYWORDS, C("_add_mat_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)\n\nScale self and add a matrix*vector, e.g. self = beta*self + alpha*M*v.\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(DoubleVectorBase): A vector\n    beta(float): A scaling constant.\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_mat_svec_double"), (PyCFunction)wrapAddMatSvec_as__add_mat_svec_double, METH_VARARGS | METH_KEYWORDS, C("_add_mat_svec_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)\n\nSame as AddMatVec, but optimized when v contains a lot of zeros.\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(DoubleVectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_sp_vec_double"), (PyCFunction)wrapAddSpVec_as__add_sp_vec_double, METH_VARARGS | METH_KEYWORDS, C("_add_sp_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleSpMatrix, v:DoubleVectorBase, beta:float)\n\nSame as AddMatVec, but optimized when M is symmetric positive definite.\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(DoubleVectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_tp_vec_double"), (PyCFunction)wrapAddTpVec_as__add_tp_vec_double, METH_VARARGS | METH_KEYWORDS, C("_add_tp_vec_double(self:DoubleVectorBase, alpha:float, M:DoubleTpMatrix, trans:MatrixTransposeType, v:DoubleVectorBase, beta:float)\n\nSame as AddMatVec, but optimized when M is triangular.\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise.\n    v(DoubleVectorBase): A vector\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_mul_single_elements_double"), (PyCFunction)wrapMulElements_as__mul_single_elements_double, METH_VARARGS | METH_KEYWORDS, C("_mul_single_elements_double(self:DoubleVectorBase, v:VectorBase)\n\nMultiply elements with elements of another vector\n\nArgs:\n    v(VectorBase): A vector")},
  {C("_div_single_elements_double"), (PyCFunction)wrapDivElements_as__div_single_elements_double, METH_VARARGS | METH_KEYWORDS, C("_div_single_elements_double(self:DoubleVectorBase, v:VectorBase)\n\nDivide elements with elements of another vector\n\nArgs:\n    v(VectorBase): A vector")},
  {C("_mul_tp_double"), (PyCFunction)wrapMulTp_as__mul_tp_double, METH_VARARGS | METH_KEYWORDS, C("_mul_tp_double(self:DoubleVectorBase, M:DoubleTpMatrix, trans:MatrixTransposeType)\n\nMultiplies this vector by lower-triangular matrix: self = self*M\n\nArgs:\n    M(DoubleTpMatrix): A lower triangularMatrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_solve_double"), (PyCFunction)wrapSolve_as__solve_double, METH_VARARGS | METH_KEYWORDS, C("_solve_double(self:DoubleVectorBase, M:DoubleTpMatrix, trans:MatrixTransposeType)\n\nIf trans == kNoTrans, solves M*x = b, where b is the value of self input\n   and x is the value of self at output. If trans == kTrans, solves M'*x = b.\n   Does not test for M being singular or near-singular.\n\nArgs:\n    M(DoubleTpMatrix): A Matrix\n    trans(MatrixTransposeType): kTrans if the matrix is to be transposed or kNoTrans otherwise\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_copy_rows_from_mat_double"), (PyCFunction)wrapCopyRowsFromMat_as__copy_rows_from_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_rows_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)\n\nStacks all the rows of matrix M into a vector and copies it to self\n\nArgs:\n    M(DoubleMatrixBase): The matrix whose rows will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_rows_from_single_mat_double"), (PyCFunction)wrapCopyRowsFromMat_as__copy_rows_from_single_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_rows_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase)\n\nStacks all the rows of matrix M into a vector and copies it to self\n\nArgs:\n    M(MatrixBase): The matrix whose rows will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_cols_from_mat_double"), (PyCFunction)wrapCopyColsFromMat_as__copy_cols_from_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_cols_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)\n\nStacks all the columns of matrix M into a vector and copies it to self\n\nArgs:\n    M(DoubleMatrixBase): The matrix whose columns will be stacked into a vector\n\nRaises:\n    Error in case of dimension mismatch, e.g. self.size != M.num_rows*M_num.cols")},
  {C("_copy_row_from_mat_double"), (PyCFunction)wrapCopyRowFromMat_as__copy_row_from_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase, row:int)\n\nExtracts a row of the matrix M and copies it to self.\n\nArgs:\n    M(DoubleMatrixBase): The matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_single_mat_double"), (PyCFunction)wrapCopyRowFromMat_as__copy_row_from_single_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase, row:int)\n\nExtracts a row of the matrix M and copies it to self.\n\nArgs:\n    M(MatrixBase): The matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_sp_double"), (PyCFunction)wrapCopyRowFromSp_as__copy_row_from_sp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_sp_double(self:DoubleVectorBase, M:DoubleSpMatrix, row:int)\n\nExtracts a row of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(DoubleSpMatrix): The symmetric matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_row_from_single_sp_double"), (PyCFunction)wrapCopyRowFromSp_as__copy_row_from_single_sp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_row_from_single_sp_double(self:DoubleVectorBase, M:SpMatrix, row:int)\n\nExtracts a row of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(SpMatrix): The symmetric matrix from which we will extract a row\n    row(int): An index to the row of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if row>=M.rows")},
  {C("_copy_col_from_mat_double"), (PyCFunction)wrapCopyColFromMat_as__copy_col_from_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_col_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase, col:int)\n\nExtracts a column of the matrix M and copies it to self.\n\nArgs:\n    M(DoubleMatrixBase): The matrix from which we will extract a column\n    col(int): An index to the column of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if col>=M.cols")},
  {C("_copy_col_from_single_mat_double"), (PyCFunction)wrapCopyColFromMat_as__copy_col_from_single_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_col_from_single_mat_double(self:DoubleVectorBase, M:MatrixBase, col:int)\n\nExtracts a column of the matrix M and copies it to self.\n\nArgs:\n    M(MatrixBase): The matrix from which we will extract a column\n    col(int): An index to the column of the matrix. Indexing starts from 0\n\nRaises:\n    Error in case of dimension mismatch or if col>=M.cols")},
  {C("_copy_diag_from_mat_double"), (PyCFunction)wrapCopyDiagFromMat_as__copy_diag_from_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_mat_double(self:DoubleVectorBase, M:DoubleMatrixBase)\n\nExtracts the diagonal of the matrix M and copies it to self.\n\nArgs:\n    M(DoubleMatrixBase): The matrix from which we will extract its diagonal\n\nRaises:\n    Error if self.dim != min(M.rows, M.cols)")},
  {C("_copy_diag_from_packed_double"), (PyCFunction)wrapCopyDiagFromPacked_as__copy_diag_from_packed_double, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_packed_double(self:DoubleVectorBase, M:DoublePackedMatrix)\n\nExtracts the diagonal of the packed matrix M and copies it to self.\n\nArgs:\n    M(DoublePackedMatrix): A triangular or symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_copy_diag_from_sp_double"), (PyCFunction)wrapCopyDiagFromSp_as__copy_diag_from_sp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_sp_double(self:DoubleVectorBase, M:DoubleSpMatrix)\n\nExtracts the diagonal of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(DoubleSpMatrix): A symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_copy_diag_from_tp_double"), (PyCFunction)wrapCopyDiagFromTp_as__copy_diag_from_tp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_diag_from_tp_double(self:DoubleVectorBase, M:DoubleTpMatrix)\n\nExtracts the diagonal of the symmetric matrix M and copies it to self.\n\nArgs:\n    M(DoubleTpMatrix): A symmetric matrix\n\nRaises:\n    Error if self.dim !=  M.cols")},
  {C("_add_row_sum_mat_double"), (PyCFunction)wrapAddRowSumMat_as__add_row_sum_mat_double, METH_VARARGS | METH_KEYWORDS, C("_add_row_sum_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, beta:float=default)\n\nPerforms the operation self = alpha * (sum of rows of M) + beta * self\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of self.dim != M.cols")},
  {C("_add_col_sum_mat_double"), (PyCFunction)wrapAddColSumMat_as__add_col_sum_mat_double, METH_VARARGS | METH_KEYWORDS, C("_add_col_sum_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, beta:float=default)\n\nPerforms the operation self = alpha * (sum of cols of M) + beta * self\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of self.dim != M.rows")},
  {C("_add_diag_mat2_double"), (PyCFunction)wrapAddDiagMat2_as__add_diag_mat2_double, METH_VARARGS | METH_KEYWORDS, C("_add_diag_mat2_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, trans:MatrixTransposeType=default, beta:float=default)\n\nPerform the operation self = alpha*diag(M*M^T) + beta*self (if trans == kNoTrans),\n   or self = alpha*diag(M^T*M) + beta*self (if trans == kTrans).\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A matrix\n    trans(MatrixTransposeType): kNoTrans(default) or kTrans\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_add_diag_mat_mat_double"), (PyCFunction)wrapAddDiagMatMat_as__add_diag_mat_mat_double, METH_VARARGS | METH_KEYWORDS, C("_add_diag_mat_mat_double(self:DoubleVectorBase, alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, N:DoubleMatrixBase, transN:MatrixTransposeType, beta:float=default)\n\nPerform the operation self = alpha*diag(M*N) + beta*self.\n\nArgs:\n    alpha(float): A scaling constant\n    M(DoubleMatrixBase): A matrix\n    N(DoubleMatrixBase): A matrix\n    transM(MatrixTransposeType): kNoTrans(default) or kTrans, denotes if we are going to use matrix M or its transpose\n    transN(MatrixTransposeType): kNoTrans(default) or kTrans, denotes if we are going to use matrix N or its transpose\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_vec_mat_vec_double"), (PyCFunction)wrapVecMatVec_as__vec_mat_vec_double, METH_VARARGS | METH_KEYWORDS, C("_vec_mat_vec_double(v1:DoubleVectorBase, M:DoubleMatrixBase, v2:DoubleVectorBase) -> float\n\nPerforms the operation v1'*M*v2\n\nArgs:\n    v1(DoubleVectorBase): a vector\n    M(DoubleMatrixBase): a matrix\n    v2(DoubleVectorBase): a vector\n\nReturns:\n   The outcome of v1'*M*v2\n\nRaises:\n   Error in case of dimension mismatch")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_vector_ext",  // module name
  "CLIF-generated module for matrix/kaldi-vector-ext.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_packed_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sp_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_tp_matrix")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__vector__ext_clifwrap
