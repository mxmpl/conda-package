//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/sparse-matrix.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/compressed-matrix-clifwrap.h"
#include "cudamatrix/cu-matrix-clifwrap.h"
#include "sparse-matrix-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __sparse__matrix_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


namespace pySparseVector {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SparseVector<float>> cpp;
};
static ::kaldi::SparseVector<float>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapDim_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Dim(), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_elements_to_vec(vec:VectorBase)
static PyObject* wrapCopyElementsToVec_as_copy_elements_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_elements_to_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_elements_to_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyElementsToVec(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_vec(alpha:float, vec:VectorBase)
static PyObject* wrapAddToVec_as_add_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_to_vec", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_vec", names[0], "float", a[0]);
  ::kaldi::VectorBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_vec", names[1], "::kaldi::VectorBase<float> *", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToVec(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_svec_(other:SparseVector)
static PyObject* wrapCopyFromSvec_as_copy_from_svec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_svec_", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_svec_", names[0], "::kaldi::SparseVector<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSvec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_other(other:SparseVector) -> SparseVector
static PyObject* wrapSparseVector_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SparseVector<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<float>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:SparseVector)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::SparseVector<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max() -> (value:float, index:int)
static PyObject* wrapMax_as_max(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// num_elements() -> int
static PyObject* wrapNumElements_as_num_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_elements(i:int) -> tuple<int, float>
static PyObject* wrapGetElement_as_get_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("i"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_elements", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_elements", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::pair< ::kaldi::MatrixIndexT, float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetElement(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn_(zero_prob:float)
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("zero_prob"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_randn_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_randn_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_dim(dim:int) -> SparseVector
static PyObject* wrapSparseVector_as_from_dim(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_dim", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_dim", names[0], "int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<float>>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_pairs(dim:int, pairs:list<tuple<int, float>>) -> SparseVector
static PyObject* wrapSparseVector_as_from_pairs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dim"),
      C("pairs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_pairs", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_pairs", names[0], "int", a[0]);
  ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, float> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_pairs", names[1], "::std::vector< ::std::pair< ::kaldi::MatrixIndexT, float> >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<float>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// resize_(dim:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("dim"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:resize_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->Resize(std::move(arg1)); break;
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_(is:istream, binary:bool)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

static PyGetSetDef Properties[] = {
  {C("dim"), get_dim, nullptr, C("Dimension (zero for empty vector).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the summation of the elements.")},
  {C("copy_elements_to_vec"), (PyCFunction)wrapCopyElementsToVec_as_copy_elements_to_vec, METH_VARARGS | METH_KEYWORDS, C("copy_elements_to_vec(vec:VectorBase)\n\nCopy the elements of self to vec.\n\nArgs:\n    vec(Vector): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_to_vec"), (PyCFunction)wrapAddToVec_as_add_to_vec, METH_VARARGS | METH_KEYWORDS, C("add_to_vec(alpha:float, vec:VectorBase)\n\nPerforms vec=vec+alpha*self\n\nArgs:\n    alpha(float): A scaling constant\n    vec(Vector): A vector")},
  {C("copy_from_svec_"), (PyCFunction)wrapCopyFromSvec_as_copy_from_svec_, METH_VARARGS | METH_KEYWORDS, C("copy_from_svec_(other:SparseVector)\n\nCopy elements of other to self\n\nArgs:\n    other(SparseVector): A sparse vector whose elements we will copy\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("from_other"), (PyCFunction)wrapSparseVector_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:SparseVector) -> SparseVector\n\nInitialization by copying the elements of other.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:SparseVector)\n\nSwaps the contents of self and other. Shallow swap.\n\nArgs:\n    other(Vector): The vector whose elements we want to swap with self.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> (value:float, index:int)\n\nReturns a tuple holding the maximum value(float) of the vector and its index(int).")},
  {C("num_elements"), (PyCFunction)wrapNumElements_as_num_elements, METH_NOARGS, C("num_elements() -> int\n\nReturns the number of nonzero elements.")},
  {C("get_elements"), (PyCFunction)wrapGetElement_as_get_elements, METH_VARARGS | METH_KEYWORDS, C("get_elements(i:int) -> tuple<int, float>\n\nGet an indexed element.\n\nReturns:\n    A tuple holding the index and a float")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_VARARGS | METH_KEYWORDS, C("set_randn_(zero_prob:float)\n\nSets elements to zero with probability zero_prob, else normally distributed.")},
  {C("from_dim"), (PyCFunction)wrapSparseVector_as_from_dim, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_dim(dim:int) -> SparseVector\n\nInitialization by defining the size of the vector.\n\nArgs:\n    dim(int): The size of the vector")},
  {C("from_pairs"), (PyCFunction)wrapSparseVector_as_from_pairs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_pairs(dim:int, pairs:list<tuple<int, float>>) -> SparseVector\n\nInitialization using a list of tuples(pairs).\n\nArgs:\n    dim(int): The size of the vector\n    pairs(list<tuple<int,float>>): A list of tuples. Each tuple holds an index\n                                   in the vector and its corresponding value")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(dim:int, resize_type:MatrixResizeType=default)\n\nSet vector size to length (length can be zero).\n   The default resize type is kSetZero, in which case the new data will\n   be zero. If the resize type is kUndefined, the new data will be undefined.\n   Finally if the resize type is kCopyData, the new data will be the same as\n   the old data in any shared positions, and zero elsewhere.\n\nArgs:\n    dim(int): The new size of the vector\n    resize_type(MatrixResizeType): Determines the initial values of the vector.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites to C++ stream.\n\nArgs:\n    os(ostream): The output straem.\n    binary(bool): If the stream is binary.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool)\n\nReads from C++ stream.\n\nArgs:\n    is(istream): The input straem.\n    binary(bool): If the stream is binary.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScale the elements of the vector by alpha")},
  {}
};

// SparseVector __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SparseVector __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SparseVector __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sparse_matrix.SparseVector",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Defines a class for sparse vectors.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SparseVector takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SparseVector<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SparseVector<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SparseVector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SparseVector<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SparseVector<float>* c = static_cast<::kaldi::SparseVector<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SparseVector<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySparseVector

// _vec_svec(vec:VectorBase, svec:SparseVector) -> float
static PyObject* wrapVecSvec_as__vec_svec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("vec"),
      C("svec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_vec_svec", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_svec", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::SparseVector<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_svec", names[1], "::kaldi::SparseVector<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecSvec(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pySparseMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SparseMatrix<float>> cpp;
};
static ::kaldi::SparseMatrix<float>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumRows(), {});
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumCols(), {});
}

// num_elements() -> int
static PyObject* wrapNumElements_as_num_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_to_mat(other:MatrixBase, t:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("t"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_elements_to_vec(other:VectorBase)
static PyObject* wrapCopyElementsToVec_as_copy_elements_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_elements_to_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_elements_to_vec", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyElementsToVec(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_smat_(other:SparseMatrix)
static PyObject* wrapCopyFromSmat_as_copy_from_smat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_smat_", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_smat_", names[0], "::kaldi::SparseMatrix<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSmat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_to_mat(alpha:float, other:MatrixBase, t:MatrixTransposeType=default)
static PyObject* wrapAddToMat_as_add_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("other"),
      C("t"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_to_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_mat", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_mat", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_to_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddToMat(std::move(arg1), arg2); break;
  case 3:
    c->AddToMat(std::move(arg1), arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:SparseMatrix) -> SparseMatrix
static PyObject* wrapSparseMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SparseMatrix<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<float>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:SparseMatrix)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::SparseMatrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_pairs(dim:int, pairs:list<list<tuple<int, float>>>) -> SparseMatrix
static PyObject* wrapSparseMatrix_as_from_pairs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dim"),
      C("pairs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_pairs", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_pairs", names[0], "int", a[0]);
  ::std::vector< ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, float> > > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_pairs", names[1], "::std::vector< ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<float>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn_(zero_prob:float)
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("zero_prob"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_randn_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_randn_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_(is:istream, binary:bool)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// row(r:int) -> SparseVector
static PyObject* wrapRow_as_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("r"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:row", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("row", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SparseVector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Row(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_row_(r:int, vec:SparseVector)
static PyObject* wrapSetRow_as_set_row_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:set_row_", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_row_", names[0], "int", a[0]);
  ::kaldi::SparseVector<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_row_", names[1], "::kaldi::SparseVector<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRow(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_dims(num_rows:int, num_cols:int) -> SparseMatrix
static PyObject* wrapSparseMatrix_as_from_dims(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("num_rows"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_dims", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_dims", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_dims", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<float>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// resize_(rows:int, cols:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:resize_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize_", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

static PyGetSetDef Properties[] = {
  {C("num_rows"), get_num_rows, nullptr, C("Number of rows (zero for empty matrix).")},
  {C("num_cols"), get_num_cols, nullptr, C("Number of columns (zero for empty matrix).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("num_elements"), (PyCFunction)wrapNumElements_as_num_elements, METH_NOARGS, C("num_elements() -> int\n\nReturns the number of nonzero elements.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elememts.")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nComputes and returns the Frobenius norm.")},
  {C("copy_to_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_mat(other:MatrixBase, t:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::SparseMatrix<float>::CopyToMat(::kaldi::MatrixBase<float> *, ::kaldi::MatrixTransposeType)")},
  {C("copy_elements_to_vec"), (PyCFunction)wrapCopyElementsToVec_as_copy_elements_to_vec, METH_VARARGS | METH_KEYWORDS, C("copy_elements_to_vec(other:VectorBase)\n\nCopies the nonzero elements of the matrix to the vector other.\n\nArgs:\n    other(Vector): A vector to store the nonzero elements of self\n\nRaises:\n    Error if the size of other is different than the number of nonzero\n    elements of self")},
  {C("copy_from_smat_"), (PyCFunction)wrapCopyFromSmat_as_copy_from_smat_, METH_VARARGS | METH_KEYWORDS, C("copy_from_smat_(other:SparseMatrix)\n\nCopy data from another sparse matrix. Will resize if necessary.\n\nArgs:\n    other(SparseMatrix): The matrix to copy from.")},
  {C("add_to_mat"), (PyCFunction)wrapAddToMat_as_add_to_mat, METH_VARARGS | METH_KEYWORDS, C("add_to_mat(alpha:float, other:MatrixBase, t:MatrixTransposeType=default)\n\nPerforms other = other+alpha*self if t==kNoTrans\nor other^T = other^T+alpha*self if t==kTrans\n\nArgs:\n    alpha(float): A constant\n    other(Matrix): A matrix\n    t(MatrixTransposeType): transpose or not\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("from_other"), (PyCFunction)wrapSparseMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:SparseMatrix) -> SparseMatrix\n\nInitialization by copying the elements of another sparse matrix.\n\nArgs:\n    other(SparseMatrix): A sparse matrix")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:SparseMatrix)\n\nSwaps the contents of self and other. Shallow swap.")},
  {C("from_pairs"), (PyCFunction)wrapSparseMatrix_as_from_pairs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_pairs(dim:int, pairs:list<list<tuple<int, float>>>) -> SparseMatrix\n\nInitialization by a list of list of tuples. The tuples hold\n   and index for the matrix and the corresponding value.\n\nArgs:\n    dim(int): Determines the number of columns\n    pairs(list<list<tuple<int,float>>>): Contains the element of the matrix.\n                                         The length of the ``outer'' list determines\n                                         the number of rows")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_VARARGS | METH_KEYWORDS, C("set_randn_(zero_prob:float)\n\nSets up to a pseudo-randomly initialized matrix,\nwith each element zero with probability zero_prob\nand else normally distributed.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites to C++ stream.\n\nArgs:\n    os(ostream): The output straem.\n    binary(bool): If the stream is binary.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool)\n\nReads from C++ stream.\n\nArgs:\n    is(istream): The input straem.\n    binary(bool): If the stream is binary.")},
  {C("row"), (PyCFunction)wrapRow_as_row, METH_VARARGS | METH_KEYWORDS, C("row(r:int) -> SparseVector\n\nReturns the row indexed by r as a sparse vector")},
  {C("set_row_"), (PyCFunction)wrapSetRow_as_set_row_, METH_VARARGS | METH_KEYWORDS, C("set_row_(r:int, vec:SparseVector)\n\nSets row r to \"vec\"; makes sure it has the correct dimension.")},
  {C("from_dims"), (PyCFunction)wrapSparseMatrix_as_from_dims, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_dims(num_rows:int, num_cols:int) -> SparseMatrix\n\nInitialization by defining the dimensions.\n\nArgs:\n    num_rows(int): The number of rows\n    num_cols(int): The number of columns")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(rows:int, cols:int, resize_type:MatrixResizeType=default)\n\nResizes a matrix. If the resize_type is kSetZero,\n   the new data will be zero. If the resize type is kUndefined,\n   the new data will be undefined. Finally if the resize type is kCopyData,\n   the new data will be the same as the old data in any shared positions,\n   and zero elsewhere. stride_type defines how data will be read from memory,\n   we advise to let it in its default value.\n\nArgs:\n    rows(int): The new number of rows\n    cols(int): The new number of columns\n    resize_type(MatrixResizeType): Determines the initial values of the vector.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScale the elements of the matrix by alpha.")},
  {}
};

// SparseMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SparseMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SparseMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sparse_matrix.SparseMatrix",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "This class defines a Sparse Matrix.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SparseMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SparseMatrix<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SparseMatrix<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SparseMatrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SparseMatrix<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SparseMatrix<float>* c = static_cast<::kaldi::SparseMatrix<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SparseMatrix<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySparseMatrix

// _trace_mat_smat(A:MatrixBase, B:SparseMatrix, trans:MatrixTransposeType=default) -> float
static PyObject* wrapTraceMatSmat_as__trace_mat_smat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_trace_mat_smat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_smat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::SparseMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_smat", names[1], "::kaldi::SparseMatrix<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_smat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::TraceMatSmat(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::TraceMatSmat(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Create Python Enum object (cached in _GeneralMatrixType) for ::kaldi::GeneralMatrixType
static PyObject* wrapGeneralMatrixType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("FULL_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::GeneralMatrixType>::type>(::kaldi::GeneralMatrixType::kFullMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COMPRESSED_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::GeneralMatrixType>::type>(::kaldi::GeneralMatrixType::kCompressedMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SPARSE_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::GeneralMatrixType>::type>(::kaldi::GeneralMatrixType::kSparseMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("GeneralMatrixType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _GeneralMatrixType{};  // set by above func in Init()

namespace pyGeneralMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::GeneralMatrix> cpp;
};
static ::kaldi::GeneralMatrix* ThisPtr(PyObject*);

// type() -> GeneralMatrixType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::GeneralMatrixType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compress()
static PyObject* wrapCompress_as_compress(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Compress();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// uncompress()
static PyObject* wrapUncompress_as_uncompress(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Uncompress();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_sparse_matrix() -> SparseMatrix
static PyObject* wrapGetSparseMatrix_as_get_sparse_matrix(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SparseMatrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetSparseMatrix();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_sparse_matrix(smat:SparseMatrix)
static PyObject* wrapSwapSparseMatrix_as_swap_sparse_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("smat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_sparse_matrix", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_sparse_matrix", names[0], "::kaldi::SparseMatrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SwapSparseMatrix(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_compressed_matrix() -> CompressedMatrix
static PyObject* wrapGetCompressedMatrix_as_get_compressed_matrix(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::CompressedMatrix ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetCompressedMatrix();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_compressed_matrix(cmat:CompressedMatrix)
static PyObject* wrapSwapCompressedMatrix_as_swap_compressed_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cmat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_compressed_matrix", names, &a[0])) return nullptr;
  ::kaldi::CompressedMatrix * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_compressed_matrix", names[0], "::kaldi::CompressedMatrix *", a[0]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SwapCompressedMatrix(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_full_matrix() -> Matrix
static PyObject* wrapGetFullMatrix_as_get_full_matrix(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetFullMatrix();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// get_matrix() -> Matrix
static PyObject* wrapGetMatrix_as_get_matrix(PyObject* self) {
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetMatrix(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// swap_full_matrix(cmat:Matrix)
static PyObject* wrapSwapFullMatrix_as_swap_full_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("cmat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_full_matrix", names, &a[0])) return nullptr;
  ::kaldi::Matrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_full_matrix", names[0], "::kaldi::Matrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SwapFullMatrix(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_mat(mat:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("mat"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (::kaldi::MatrixTransposeType)111;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_cu_mat(cu_mat:CuMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_cu_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("cu_mat"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_cu_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_cu_mat", names[0], "::kaldi::CuMatrixBase<float> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (::kaldi::MatrixTransposeType)111;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_cu_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_mat(alpha:float, mat:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapAddToMat_as_add_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("mat"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_to_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_mat", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_mat", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (::kaldi::MatrixTransposeType)111;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_to_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddToMat(std::move(arg1), arg2); break;
  case 3:
    c->AddToMat(std::move(arg1), arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(alpha:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_rows() -> int
static PyObject* wrapNumRows_as_num_rows(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_cols() -> int
static PyObject* wrapNumCols_as_num_cols(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumCols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_matrix(other:MatrixBase) -> GeneralMatrix
static PyObject* wrapGeneralMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_matrix", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::GeneralMatrix> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::GeneralMatrix>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_compressed(other:CompressedMatrix) -> GeneralMatrix
static PyObject* wrapGeneralMatrix_as_from_compressed(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_compressed", names, &a[0])) return nullptr;
  ::kaldi::CompressedMatrix* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_compressed", names[0], "::kaldi::CompressedMatrix", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::GeneralMatrix> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::GeneralMatrix>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_sparse(other:SparseMatrix) -> GeneralMatrix
static PyObject* wrapGeneralMatrix_as_from_sparse(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_sparse", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_sparse", names[0], "::kaldi::SparseMatrix<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::GeneralMatrix> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::GeneralMatrix>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(other:GeneralMatrix) -> GeneralMatrix
static PyObject* wrapGeneralMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::GeneralMatrix* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::GeneralMatrix", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::GeneralMatrix> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::GeneralMatrix>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// clear()
static PyObject* wrapClear_as_clear(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Clear();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap(other:GeneralMatrix)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::GeneralMatrix * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::GeneralMatrix *", a[0]);
  // Call actual C++ method.
  ::kaldi::GeneralMatrix* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> GeneralMatrixType\n\nReturns the type of the matrix: kSparseMatrix, kCompressedMatrix\nor kFullMatrix. If this matrix is empty, returns kFullMatrix.")},
  {C("compress"), (PyCFunction)wrapCompress_as_compress, METH_NOARGS, C("compress()\n\nCompresses the matrix to a sparse one.")},
  {C("uncompress"), (PyCFunction)wrapUncompress_as_uncompress, METH_NOARGS, C("uncompress()\n\nUncompresses the matrix to a one of class Matrix.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites to C++ stream.\n\nArgs:\n    os(ostream): The output straem.\n    binary(bool): If the stream is binary.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n\nReads from C++ stream.\n\nArgs:\n    is(istream): The input straem.\n    binary(bool): If the stream is binary.\n    add(bool): True if you want to add the stream to self.")},
  {C("get_sparse_matrix"), (PyCFunction)wrapGetSparseMatrix_as_get_sparse_matrix, METH_NOARGS, C("get_sparse_matrix() -> SparseMatrix\n\nReturns the contents as a SparseMatrix.\n\nRaises:\n    Error if type returns something other than kSparseMatrix,\n    or NumRows() != 0")},
  {C("swap_sparse_matrix"), (PyCFunction)wrapSwapSparseMatrix_as_swap_sparse_matrix, METH_VARARGS | METH_KEYWORDS, C("swap_sparse_matrix(smat:SparseMatrix)\n\nSwaps the contents of self and smat.\n\nRaises:\n    Error if type returns something other than kSparseMatrix,\n    or NumRows() != 0")},
  {C("get_compressed_matrix"), (PyCFunction)wrapGetCompressedMatrix_as_get_compressed_matrix, METH_NOARGS, C("get_compressed_matrix() -> CompressedMatrix\n\nReturns the contents as a compressed matrix.\n\nRaises:\n    Error if type returns something other than kCompressedMatrix,\n    or NumRows() != 0")},
  {C("swap_compressed_matrix"), (PyCFunction)wrapSwapCompressedMatrix_as_swap_compressed_matrix, METH_VARARGS | METH_KEYWORDS, C("swap_compressed_matrix(cmat:CompressedMatrix)\n\nSwaps the current compressed matrix with another(cmat).")},
  {C("get_full_matrix"), (PyCFunction)wrapGetFullMatrix_as_get_full_matrix, METH_NOARGS, C("get_full_matrix() -> Matrix\n\nReturns the contents as an instance of class Matrix.\n\nRaises:\n    Error if the type is anything other than kFullMatrix\n    or NumRows() != 0")},
  {C("get_matrix"), (PyCFunction)wrapGetMatrix_as_get_matrix, METH_NOARGS, C("get_matrix() -> Matrix\n\nOutputs the contents as an instance of class Matrix.")},
  {C("swap_full_matrix"), (PyCFunction)wrapSwapFullMatrix_as_swap_full_matrix, METH_VARARGS | METH_KEYWORDS, C("swap_full_matrix(cmat:Matrix)\n\nSwap the contents of self with cmat.\n\nRaises:\n    Error if type is anything other than kFullMatrix,\n    or if NumRows() != 0")},
  {C("copy_to_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_mat(mat:MatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::GeneralMatrix::CopyToMat(::kaldi::MatrixBase<float> *, ::kaldi::MatrixTransposeType)")},
  {C("copy_to_cu_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_cu_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_cu_mat(cu_mat:CuMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::GeneralMatrix::CopyToMat(::kaldi::CuMatrixBase<float> *, ::kaldi::MatrixTransposeType)")},
  {C("add_to_mat"), (PyCFunction)wrapAddToMat_as_add_to_mat, METH_VARARGS | METH_KEYWORDS, C("add_to_mat(alpha:float, mat:MatrixBase, trans:MatrixTransposeType=default)\n\nPerforms mat=mat+alpha*self if MatrixTransposeType==kNoTrans.\n   Performs mat^T=mat^T+alpha*self if MatrixTransposeType==kNoTrans.\n\nArgs:\n    alpha(float): A constant\n    mat(MatrixBase): A matrix\n    trans(MatrixTransposeType): Determines transposition of mat.\n                                Default is kNoTrans\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(alpha:float)\n\nScale all elements of the matrix by alpha.")},
  {C("num_rows"), (PyCFunction)wrapNumRows_as_num_rows, METH_NOARGS, C("num_rows() -> int\n\nReturn the number of rows.")},
  {C("num_cols"), (PyCFunction)wrapNumCols_as_num_cols, METH_NOARGS, C("num_cols() -> int\n\nReturn the number of columns.")},
  {C("from_matrix"), (PyCFunction)wrapGeneralMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(other:MatrixBase) -> GeneralMatrix\n\nInitialization of a General Matrix from matrix of class MatrixBase.")},
  {C("from_compressed"), (PyCFunction)wrapGeneralMatrix_as_from_compressed, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_compressed(other:CompressedMatrix) -> GeneralMatrix\n\nInitialization of a General Matrix from matrix of class CompressesMatrix.")},
  {C("from_sparse"), (PyCFunction)wrapGeneralMatrix_as_from_sparse, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_sparse(other:SparseMatrix) -> GeneralMatrix\n\nInitialization of a General Matrix from matrix of class SparseMatrix.")},
  {C("from_other"), (PyCFunction)wrapGeneralMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:GeneralMatrix) -> GeneralMatrix\n\nInitialization of a General Matrix from matrix of class GeneralMatrix.")},
  {C("clear"), (PyCFunction)wrapClear_as_clear, METH_NOARGS, C("clear()\n\nClear the contents of self.")},
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:GeneralMatrix)\n\nSwaps the contents of self and other. Shallow swap.")},
  {}
};

// GeneralMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// GeneralMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// GeneralMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sparse_matrix.GeneralMatrix",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Defines a class for general matrices. A general matrix can be either\nfull(kFullMatrix), compresssed(kCompressedMatrix), or sparse(kSparseMatrix).", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "GeneralMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::GeneralMatrix>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::GeneralMatrix* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_GeneralMatrix"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::GeneralMatrix"));
      if (!PyErr_Occurred()) {
        ::kaldi::GeneralMatrix* c = static_cast<::kaldi::GeneralMatrix*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::GeneralMatrix*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyGeneralMatrix

// _filter_sparse_matrix_rows(in:SparseMatrix, keep_rows:list<bool>) -> SparseMatrix
static PyObject* wrapFilterSparseMatrixRows_as__filter_sparse_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_sparse_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SparseMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_sparse_matrix_rows", names[0], "::kaldi::SparseMatrix<float>", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_sparse_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::SparseMatrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterSparseMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _filter_matrix_rows(in:Matrix, keep_rows:list<bool>) -> Matrix
static PyObject* wrapFilterMatrixRows_as__filter_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::Matrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_matrix_rows", names[0], "::kaldi::Matrix<float>", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _filter_compressed_matrix_rows(in:CompressedMatrix, keep_rows:list<bool>) -> Matrix
static PyObject* wrapFilterCompressedMatrixRows_as__filter_compressed_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_compressed_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CompressedMatrix* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_compressed_matrix_rows", names[0], "::kaldi::CompressedMatrix", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_compressed_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterCompressedMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _filter_general_matrix_rows(in:GeneralMatrix, keep_rows:list<bool>) -> GeneralMatrix
static PyObject* wrapFilterGeneralMatrixRows_as__filter_general_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_general_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::GeneralMatrix* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_general_matrix_rows", names[0], "::kaldi::GeneralMatrix", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_general_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::GeneralMatrix ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterGeneralMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// extract_row_range_with_padding(matrix:GeneralMatrix, row_offset:int, num_rows:int) -> GeneralMatrix
static PyObject* wrapExtractRowRangeWithPadding_as_extract_row_range_with_padding(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("matrix"),
      C("row_offset"),
      C("num_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:extract_row_range_with_padding", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::GeneralMatrix* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("extract_row_range_with_padding", names[0], "::kaldi::GeneralMatrix", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("extract_row_range_with_padding", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("extract_row_range_with_padding", names[2], "int", a[2]);
  ::kaldi::GeneralMatrix ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ExtractRowRangeWithPadding(*arg1, std::move(arg2), std::move(arg3), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyDoubleSparseVector {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SparseVector<double>> cpp;
};
static ::kaldi::SparseVector<double>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapDim_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Dim(), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_elements_to_vec(vec:DoubleVectorBase)
static PyObject* wrapCopyElementsToVec_as_copy_elements_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_elements_to_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_elements_to_vec", names[0], "::kaldi::VectorBase<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyElementsToVec(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_vec(alpha:float, vec:DoubleVectorBase)
static PyObject* wrapAddToVec_as_add_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_to_vec", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_vec", names[0], "double", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_vec", names[1], "::kaldi::VectorBase<double> *", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToVec(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_svec(other:DoubleSparseVector)
static PyObject* wrapCopyFromSvec_as_copy_from_svec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_svec", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_svec", names[0], "::kaldi::SparseVector<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSvec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:DoubleSparseVector) -> DoubleSparseVector
static PyObject* wrapSparseVector_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SparseVector<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<double>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:DoubleSparseVector)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::SparseVector<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::SparseVector<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max() -> (value:float, index:int)
static PyObject* wrapMax_as_max(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// num_elements() -> int
static PyObject* wrapNumElements_as_num_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_elements(i:int) -> tuple<int, float>
static PyObject* wrapGetElement_as_get_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("i"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_elements", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_elements", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::pair< ::kaldi::MatrixIndexT, double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetElement(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn_(zero_prob:float)
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("zero_prob"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_randn_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_randn_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_dim(dim:int) -> DoubleSparseVector
static PyObject* wrapSparseVector_as_from_dim(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_dim", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_dim", names[0], "int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<double>>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_pairs(dim:int, pairs:list<tuple<int, float>>) -> DoubleSparseVector
static PyObject* wrapSparseVector_as_from_pairs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dim"),
      C("pairs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_pairs", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_pairs", names[0], "int", a[0]);
  ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, double> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_pairs", names[1], "::std::vector< ::std::pair< ::kaldi::MatrixIndexT, double> >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseVector<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseVector<double>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// resize_(dim:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("dim"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:resize_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->Resize(std::move(arg1)); break;
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_(is:istream, binary:bool)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale(alpha:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseVector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("dim"), get_dim, nullptr, C("Dimension (zero for empty vector).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the summation of the elements.")},
  {C("copy_elements_to_vec"), (PyCFunction)wrapCopyElementsToVec_as_copy_elements_to_vec, METH_VARARGS | METH_KEYWORDS, C("copy_elements_to_vec(vec:DoubleVectorBase)\n\nCopy the elements of self to vec.\n\nArgs:\n    vec(DoubleVector): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_to_vec"), (PyCFunction)wrapAddToVec_as_add_to_vec, METH_VARARGS | METH_KEYWORDS, C("add_to_vec(alpha:float, vec:DoubleVectorBase)\n\nPerforms vec=vec+alpha*self\n\nArgs:\n    alpha(float): A scaling constant\n    vec(DoubleVector): A vector")},
  {C("copy_from_svec"), (PyCFunction)wrapCopyFromSvec_as_copy_from_svec, METH_VARARGS | METH_KEYWORDS, C("copy_from_svec(other:DoubleSparseVector)\n\nCopy elements of other to self\n\nArgs:\n    other(DoubleSparseVector): A sparse vector whose elements we will copy\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("from_other"), (PyCFunction)wrapSparseVector_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:DoubleSparseVector) -> DoubleSparseVector\n\nInitialization by copying the elements of other.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:DoubleSparseVector)\n\nSwaps the contents of self and other. Shallow swap.\n\nArgs:\n    other(DoubleVector): The vector whose elements we want to swap with self.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> (value:float, index:int)\n\nReturns a tuple holding the maximum value(float) of the vector and its index(int).")},
  {C("num_elements"), (PyCFunction)wrapNumElements_as_num_elements, METH_NOARGS, C("num_elements() -> int\n\nReturns the number of nonzero elements.")},
  {C("get_elements"), (PyCFunction)wrapGetElement_as_get_elements, METH_VARARGS | METH_KEYWORDS, C("get_elements(i:int) -> tuple<int, float>\n\nGet an indexed element.\n\nReturns:\n    A tuple holding the index and a float")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_VARARGS | METH_KEYWORDS, C("set_randn_(zero_prob:float)\n\nSets elements to zero with probability zero_prob, else normally distributed.")},
  {C("from_dim"), (PyCFunction)wrapSparseVector_as_from_dim, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_dim(dim:int) -> DoubleSparseVector\n\nInitialization by defining the size of the vector.\n\nArgs:\n    dim(int): The size of the vector")},
  {C("from_pairs"), (PyCFunction)wrapSparseVector_as_from_pairs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_pairs(dim:int, pairs:list<tuple<int, float>>) -> DoubleSparseVector\n\nInitialization using a list of tuples(pairs).\n\nArgs:\n    dim(int): The size of the vector\n    pairs(list<tuple<int,float>>): A list of tuples. Each tuple holds an index\n                                   in the vector and its corresponding value")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(dim:int, resize_type:MatrixResizeType=default)\n\nSet vector size to length (length can be zero).\n   The default resize type is kSetZero, in which case the new data will\n   be zero. If the resize type is kUndefined, the new data will be undefined.\n   Finally if the resize type is kCopyData, the new data will be the same as\n   the old data in any shared positions, and zero elsewhere.\n\nArgs:\n    dim(int): The new size of the vector\n    resize_type(MatrixResizeType): Determines the initial values of the vector.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites to C++ stream.\n\nArgs:\n    os(ostream): The output straem.\n    binary(bool): If the stream is binary.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool)\n\nReads from C++ stream.\n\nArgs:\n    is(istream): The input straem.\n    binary(bool): If the stream is binary.")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(alpha:float)\n\nScale the elements of the vector by alpha")},
  {}
};

// DoubleSparseVector __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleSparseVector __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleSparseVector __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sparse_matrix.DoubleSparseVector", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Defines a class for sparse vectors.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleSparseVector takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SparseVector<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SparseVector<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SparseVector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SparseVector<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SparseVector<double>* c = static_cast<::kaldi::SparseVector<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SparseVector<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleSparseVector

// _vec_svec_double(vec:DoubleVectorBase, svec:DoubleSparseVector) -> float
static PyObject* wrapVecSvec_as__vec_svec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("vec"),
      C("svec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_vec_svec_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_svec_double", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::SparseVector<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_svec_double", names[1], "::kaldi::SparseVector<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecSvec(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyDoubleSparseMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SparseMatrix<double>> cpp;
};
static ::kaldi::SparseMatrix<double>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumRows(), {});
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumCols(), {});
}

// num_elements() -> int
static PyObject* wrapNumElements_as_num_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_to_mat(other:DoubleMatrixBase, t:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("t"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_mat", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_elements_to_vec(other:DoubleVectorBase)
static PyObject* wrapCopyElementsToVec_as_copy_elements_to_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_elements_to_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_elements_to_vec", names[0], "::kaldi::VectorBase<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyElementsToVec(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_smat_(other:DoubleSparseMatrix)
static PyObject* wrapCopyFromSmat_as_copy_from_smat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_smat_", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_smat_", names[0], "::kaldi::SparseMatrix<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSmat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_to_mat(alpha:float, other:DoubleMatrixBase, t:MatrixTransposeType=default)
static PyObject* wrapAddToMat_as_add_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("other"),
      C("t"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_to_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_mat", names[0], "float", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_mat", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_to_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddToMat(std::move(arg1), arg2); break;
  case 3:
    c->AddToMat(std::move(arg1), arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:DoubleSparseMatrix) -> DoubleSparseMatrix
static PyObject* wrapSparseMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SparseMatrix<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<double>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:DoubleSparseMatrix)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::SparseMatrix<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::SparseMatrix<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_pairs(dim:int, pairs:list<list<tuple<int, float>>>) -> DoubleSparseMatrix
static PyObject* wrapSparseMatrix_as_from_pairs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dim"),
      C("pairs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_pairs", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_pairs", names[0], "int", a[0]);
  ::std::vector< ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, double> > > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_pairs", names[1], "::std::vector< ::std::vector< ::std::pair< ::kaldi::MatrixIndexT, double> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<double>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn_(zero_prob:float)
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("zero_prob"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_randn_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_randn_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_(is:istream, binary:bool)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// row(r:int) -> DoubleSparseVector
static PyObject* wrapRow_as_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("r"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:row", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("row", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SparseVector<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Row(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_row_(r:int, vec:DoubleSparseVector)
static PyObject* wrapSetRow_as_set_row_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("vec"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:set_row_", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_row_", names[0], "int", a[0]);
  ::kaldi::SparseVector<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_row_", names[1], "::kaldi::SparseVector<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRow(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_dims(num_rows:int, num_cols:int) -> DoubleSparseMatrix
static PyObject* wrapSparseMatrix_as_from_dims(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("num_rows"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_dims", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_dims", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_dims", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SparseMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SparseMatrix<double>>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// resize_(rows:int, cols:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:resize_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize_", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::SparseMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

static PyGetSetDef Properties[] = {
  {C("num_rows"), get_num_rows, nullptr, C("Number of rows (zero for empty matrix).")},
  {C("num_cols"), get_num_cols, nullptr, C("Number of columns (zero for empty matrix).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("num_elements"), (PyCFunction)wrapNumElements_as_num_elements, METH_NOARGS, C("num_elements() -> int\n\nReturns the number of nonzero elements.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elememts.")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nComputes and returns the Frobenius norm.")},
  {C("copy_to_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_mat(other:DoubleMatrixBase, t:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::SparseMatrix<double>::CopyToMat(::kaldi::MatrixBase<double> *, ::kaldi::MatrixTransposeType)")},
  {C("copy_elements_to_vec"), (PyCFunction)wrapCopyElementsToVec_as_copy_elements_to_vec, METH_VARARGS | METH_KEYWORDS, C("copy_elements_to_vec(other:DoubleVectorBase)\n\nCopies the nonzero elements of the matrix to the vector other.\n\nArgs:\n    other(DoubleVector): A vector to store the nonzero elements of self\n\nRaises:\n    Error if the size of other is different than the number of nonzero\n    elements of self")},
  {C("copy_from_smat_"), (PyCFunction)wrapCopyFromSmat_as_copy_from_smat_, METH_VARARGS | METH_KEYWORDS, C("copy_from_smat_(other:DoubleSparseMatrix)\n\nCopy data from another sparse matrix. Will resize if necessary.\n\nArgs:\n    other(DoubleSparseMatrix): The matrix to copy from.")},
  {C("add_to_mat"), (PyCFunction)wrapAddToMat_as_add_to_mat, METH_VARARGS | METH_KEYWORDS, C("add_to_mat(alpha:float, other:DoubleMatrixBase, t:MatrixTransposeType=default)\n\nPerforms other = other+alpha*self if t==kNoTrans\nor other^T = other^T+alpha*self if t==kTrans\n\nArgs:\n    alpha(float): A constant\n    other(DoubleMatrix): A matrix\n    t(MatrixTransposeType): transpose or not\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("from_other"), (PyCFunction)wrapSparseMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:DoubleSparseMatrix) -> DoubleSparseMatrix\n\nInitialization by copying the elements of another sparse matrix.\n\nArgs:\n    other(DoubleSparseMatrix): A sparse matrix")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:DoubleSparseMatrix)\n\nSwaps the contents of self and other. Shallow swap.")},
  {C("from_pairs"), (PyCFunction)wrapSparseMatrix_as_from_pairs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_pairs(dim:int, pairs:list<list<tuple<int, float>>>) -> DoubleSparseMatrix\n\nInitialization by a list of list of tuples. The tuples hold\n   and index for the matrix and the corresponding value.\n\nArgs:\n    dim(int): Determines the number of columns\n    pairs(list<list<tuple<int,float>>>): Contains the element of the matrix.\n                                         The length of the ``outer'' list determines\n                                         the number of rows")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_VARARGS | METH_KEYWORDS, C("set_randn_(zero_prob:float)\n\nSets up to a pseudo-randomly initialized matrix,\nwith each element zero with probability zero_prob\nand else normally distributed.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites to C++ stream.\n\nArgs:\n    os(ostream): The output straem.\n    binary(bool): If the stream is binary.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool)\n\nReads from C++ stream.\n\nArgs:\n    is(istream): The input straem.\n    binary(bool): If the stream is binary.")},
  {C("row"), (PyCFunction)wrapRow_as_row, METH_VARARGS | METH_KEYWORDS, C("row(r:int) -> DoubleSparseVector\n\nReturns the row indexed by r as a sparse vector")},
  {C("set_row_"), (PyCFunction)wrapSetRow_as_set_row_, METH_VARARGS | METH_KEYWORDS, C("set_row_(r:int, vec:DoubleSparseVector)\n\nSets row r to \"vec\"; makes sure it has the correct dimension.")},
  {C("from_dims"), (PyCFunction)wrapSparseMatrix_as_from_dims, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_dims(num_rows:int, num_cols:int) -> DoubleSparseMatrix\n\nInitialization by defining the dimensions.\n\nArgs:\n    num_rows(int): The number of rows\n    num_cols(int): The number of columns")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(rows:int, cols:int, resize_type:MatrixResizeType=default)\n\nResizes a matrix. If the resize_type is kSetZero,\n   the new data will be zero. If the resize type is kUndefined,\n   the new data will be undefined. Finally if the resize type is kCopyData,\n   the new data will be the same as the old data in any shared positions,\n   and zero elsewhere. stride_type defines how data will be read from memory,\n   we advise to let it in its default value.\n\nArgs:\n    rows(int): The new number of rows\n    cols(int): The new number of columns\n    resize_type(MatrixResizeType): Determines the initial values of the vector.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScale the elements of the matrix by alpha.")},
  {}
};

// DoubleSparseMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleSparseMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleSparseMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sparse_matrix.DoubleSparseMatrix", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "This class defines a Sparse Matrix.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleSparseMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SparseMatrix<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SparseMatrix<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SparseMatrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SparseMatrix<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SparseMatrix<double>* c = static_cast<::kaldi::SparseMatrix<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SparseMatrix<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleSparseMatrix

// _trace_double_mat_smat(A:DoubleMatrixBase, B:DoubleSparseMatrix, trans:MatrixTransposeType=default) -> float
static PyObject* wrapTraceMatSmat_as__trace_double_mat_smat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_trace_double_mat_smat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_smat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::SparseMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_smat", names[1], "::kaldi::SparseMatrix<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_smat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::TraceMatSmat(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::TraceMatSmat(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _filter_double_sparse_matrix_rows(in:DoubleSparseMatrix, keep_rows:list<bool>) -> DoubleSparseMatrix
static PyObject* wrapFilterSparseMatrixRows_as__filter_double_sparse_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_double_sparse_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SparseMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_double_sparse_matrix_rows", names[0], "::kaldi::SparseMatrix<double>", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_double_sparse_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::SparseMatrix<double> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterSparseMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _filter_double_matrix_rows(in:DoubleMatrix, keep_rows:list<bool>) -> DoubleMatrix
static PyObject* wrapFilterMatrixRows_as__filter_double_matrix_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in"),
      C("keep_rows"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_filter_double_matrix_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::Matrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_filter_double_matrix_rows", names[0], "::kaldi::Matrix<double>", a[0]);
  ::std::vector<bool> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_filter_double_matrix_rows", names[1], "::std::vector<bool>", a[1]);
  ::kaldi::Matrix<double> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FilterMatrixRows(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_vec_svec"), (PyCFunction)wrapVecSvec_as__vec_svec, METH_VARARGS | METH_KEYWORDS, C("_vec_svec(vec:VectorBase, svec:SparseVector) -> float\n\nReturns the inner product of vec and svec.")},
  {C("_trace_mat_smat"), (PyCFunction)wrapTraceMatSmat_as__trace_mat_smat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_smat(A:MatrixBase, B:SparseMatrix, trans:MatrixTransposeType=default) -> float\n\nIf trans==kNoTrans compute Trace(A*B). If trans==kTrans compute Trace(A^T*B)\n\nArgs:\n    A(Matrix): A matrix\n    B(SparseMatrix): A sparse matrix\n    trans(MatrixTransposeType): Determines if we use A as is or its transpose\n\nRaises:\n    Error in case of dimensionality mismatch")},
  {C("_filter_sparse_matrix_rows"), (PyCFunction)wrapFilterSparseMatrixRows_as__filter_sparse_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_sparse_matrix_rows(in:SparseMatrix, keep_rows:list<bool>) -> SparseMatrix\n\nOutputs a sparse matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(SparseMatrix): The sparse matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered sparse matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {C("_filter_matrix_rows"), (PyCFunction)wrapFilterMatrixRows_as__filter_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_matrix_rows(in:Matrix, keep_rows:list<bool>) -> Matrix\n\nOutputs a matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(Matrix): The matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {C("_filter_compressed_matrix_rows"), (PyCFunction)wrapFilterCompressedMatrixRows_as__filter_compressed_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_compressed_matrix_rows(in:CompressedMatrix, keep_rows:list<bool>) -> Matrix\n\nOutputs a matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(CompressedMatrix): The compressed matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {C("_filter_general_matrix_rows"), (PyCFunction)wrapFilterGeneralMatrixRows_as__filter_general_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_general_matrix_rows(in:GeneralMatrix, keep_rows:list<bool>) -> GeneralMatrix\n\nOutputs a general matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(GeneralMatrix): The general matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered general matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {C("extract_row_range_with_padding"), (PyCFunction)wrapExtractRowRangeWithPadding_as_extract_row_range_with_padding, METH_VARARGS | METH_KEYWORDS, C("extract_row_range_with_padding(matrix:GeneralMatrix, row_offset:int, num_rows:int) -> GeneralMatrix\n\nExtracts a row-range from a general matrix.\n\n   This function extracts a row-range from a general matrix and writes\n   a GeneralMatrix containing the same type of underlying matrix.\n   If the row-range is partly outside the row-range of 'in'\n   (i.e. if row_offset < 0 or row_offset + num_rows > in.NumRows())\n   then it will pad with copies of the first and last row as needed.\n   This is more efficient than un-compressing and re-compressing\n   the underlying CompressedMatrix, and causes less accuracy loss\n   due to re-compression (no loss in most cases).\n\nArgs:\n    matrix (GeneralMatrix): The general matrix.\n    row_offset (int): The start row index.\n    num_rows (int): The number of rows.\n\nReturns:\n    A general matrix.")},
  {C("_vec_svec_double"), (PyCFunction)wrapVecSvec_as__vec_svec_double, METH_VARARGS | METH_KEYWORDS, C("_vec_svec_double(vec:DoubleVectorBase, svec:DoubleSparseVector) -> float\n\nReturns the inner product of vec and svec.")},
  {C("_trace_double_mat_smat"), (PyCFunction)wrapTraceMatSmat_as__trace_double_mat_smat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_smat(A:DoubleMatrixBase, B:DoubleSparseMatrix, trans:MatrixTransposeType=default) -> float\n\nIf trans==kNoTrans compute Trace(A*B). If trans==kTrans compute Trace(A^T*B)\n\nArgs:\n    A(DoubleMatrix): A matrix\n    B(DoubleSparseMatrix): A sparse matrix\n    trans(MatrixTransposeType): Determines if we use A as is or its transpose\n\nRaises:\n    Error in case of dimensionality mismatch")},
  {C("_filter_double_sparse_matrix_rows"), (PyCFunction)wrapFilterSparseMatrixRows_as__filter_double_sparse_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_double_sparse_matrix_rows(in:DoubleSparseMatrix, keep_rows:list<bool>) -> DoubleSparseMatrix\n\nOutputs a sparse matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(DoubleSparseMatrix): The sparse matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered sparse matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {C("_filter_double_matrix_rows"), (PyCFunction)wrapFilterMatrixRows_as__filter_double_matrix_rows, METH_VARARGS | METH_KEYWORDS, C("_filter_double_matrix_rows(in:DoubleMatrix, keep_rows:list<bool>) -> DoubleMatrix\n\nOutputs a matrix containing only the rows r\n   of ``in'' such that keep_rows[r] == true.\n\nArgs:\n    in(DoubleMatrix): The matrix to be filtered\n    keep_rows(list<bool>): A list that determines which rows will be filtered\n\nReturns:\n    The filtered matrix\n\nRaises:\n    Error if in.num_rows != list.length")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pySparseVector::wrapper_Type) < 0) return false;
  Py_INCREF(&pySparseVector::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySparseMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pySparseMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyGeneralMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyGeneralMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleSparseVector::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleSparseVector::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleSparseMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleSparseMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_sparse_matrix",  // module name
  "CLIF-generated module for matrix/sparse-matrix.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_compressed_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrix")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "SparseVector", reinterpret_cast<PyObject*>(&pySparseVector::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SparseMatrix", reinterpret_cast<PyObject*>(&pySparseMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "GeneralMatrixType", (_GeneralMatrixType=wrapGeneralMatrixType())) < 0) goto err;
  if (PyModule_AddObject(module, "GeneralMatrix", reinterpret_cast<PyObject*>(&pyGeneralMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleSparseVector", reinterpret_cast<PyObject*>(&pyDoubleSparseVector::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleSparseMatrix", reinterpret_cast<PyObject*>(&pyDoubleSparseMatrix::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __sparse__matrix_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// DoubleSparseMatrix to/from ::kaldi::SparseMatrix<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseMatrix<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SparseMatrix<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SparseMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SparseMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleSparseMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseMatrix<double>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SparseMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SparseMatrix<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SparseMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SparseMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SparseMatrix<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SparseMatrix<double>>(c);
  return py;
}

// DoubleSparseVector to/from ::kaldi::SparseVector<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseVector<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SparseVector<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SparseVector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SparseVector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleSparseVector instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseVector<double>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SparseVector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<double>* cpp = __sparse__matrix_clifwrap::pyDoubleSparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SparseVector<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SparseVector<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SparseVector<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SparseVector<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyDoubleSparseVector::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SparseVector<double>>(c);
  return py;
}

// GeneralMatrix to/from ::kaldi::GeneralMatrix conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::GeneralMatrix** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::GeneralMatrix* cpp = __sparse__matrix_clifwrap::pyGeneralMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::GeneralMatrix>* c) {
  assert(c != nullptr);
  ::kaldi::GeneralMatrix* cpp = __sparse__matrix_clifwrap::pyGeneralMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::GeneralMatrix>* c) {
  assert(c != nullptr);
  ::kaldi::GeneralMatrix* cpp = __sparse__matrix_clifwrap::pyGeneralMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert GeneralMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::GeneralMatrix* c) {
  assert(c != nullptr);
  ::kaldi::GeneralMatrix* cpp = __sparse__matrix_clifwrap::pyGeneralMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::GeneralMatrix>* c) {
  assert(c != nullptr);
  ::kaldi::GeneralMatrix* cpp = __sparse__matrix_clifwrap::pyGeneralMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::GeneralMatrix* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::GeneralMatrix>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::GeneralMatrix> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::GeneralMatrix>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::GeneralMatrix> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::GeneralMatrix>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::GeneralMatrix& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pyGeneralMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::GeneralMatrix>(c);
  return py;
}

// GeneralMatrixType:IntEnum to/from enum ::kaldi::GeneralMatrixType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::GeneralMatrixType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __sparse__matrix_clifwrap::_GeneralMatrixType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum GeneralMatrixType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::GeneralMatrixType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::GeneralMatrixType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::GeneralMatrixType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__sparse__matrix_clifwrap::_GeneralMatrixType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::GeneralMatrixType>::type>(c)), nullptr);
}

// SparseMatrix to/from ::kaldi::SparseMatrix<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseMatrix<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SparseMatrix<float>* cpp = __sparse__matrix_clifwrap::pySparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SparseMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<float>* cpp = __sparse__matrix_clifwrap::pySparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SparseMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<float>* cpp = __sparse__matrix_clifwrap::pySparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SparseMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseMatrix<float>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<float>* cpp = __sparse__matrix_clifwrap::pySparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SparseMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseMatrix<float>* cpp = __sparse__matrix_clifwrap::pySparseMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SparseMatrix<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SparseMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SparseMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseMatrix<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SparseMatrix<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SparseMatrix<float>>(c);
  return py;
}

// SparseVector to/from ::kaldi::SparseVector<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseVector<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SparseVector<float>* cpp = __sparse__matrix_clifwrap::pySparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SparseVector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<float>* cpp = __sparse__matrix_clifwrap::pySparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SparseVector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<float>* cpp = __sparse__matrix_clifwrap::pySparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SparseVector instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SparseVector<float>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<float>* cpp = __sparse__matrix_clifwrap::pySparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SparseVector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SparseVector<float>* cpp = __sparse__matrix_clifwrap::pySparseVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SparseVector<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SparseVector<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SparseVector<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SparseVector<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SparseVector<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sparse__matrix_clifwrap::pySparseVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sparse__matrix_clifwrap::pySparseVector::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SparseVector<float>>(c);
  return py;
}

}  // namespace kaldi
