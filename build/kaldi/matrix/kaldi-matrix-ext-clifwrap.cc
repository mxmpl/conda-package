//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/kaldi-matrix-ext.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/sp-matrix-clifwrap.h"
#include "matrix/tp-matrix-clifwrap.h"
#include "matrix/compressed-matrix-clifwrap.h"
#include "kaldi-matrix-ext-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__matrix__ext_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _copy_from_double_mat(self:MatrixBase, M:DoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as__copy_from_double_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_double_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_double_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_double_mat", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_double_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromMat(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromMat(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_cmat(self:MatrixBase, M:CompressedMatrix)
static PyObject* wrapCopyFromCompressed_as__copy_from_cmat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_cmat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_cmat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::CompressedMatrix* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_cmat", names[1], "::kaldi::CompressedMatrix", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromCompressed(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_sp(self:MatrixBase, M:SpMatrix)
static PyObject* wrapCopyFromSp_as__copy_from_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_sp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_sp", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_double_sp(self:MatrixBase, M:DoubleSpMatrix)
static PyObject* wrapCopyFromSp_as__copy_from_double_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_double_sp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_double_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_double_sp", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_tp(self:MatrixBase, M:TpMatrix, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromTp_as__copy_from_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_tp", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_tp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::TpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_tp", names[1], "::kaldi::TpMatrix<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_tp", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromTp(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromTp(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_double_tp(self:MatrixBase, M:DoubleTpMatrix, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromTp_as__copy_from_double_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_double_tp", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_double_tp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::TpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_double_tp", names[1], "::kaldi::TpMatrix<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_double_tp", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromTp(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromTp(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp(self:MatrixBase, alpha:float, S:SpMatrix)
static PyObject* wrapAddSp_as__add_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("S"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_sp", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp", names[1], "float", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp", names[2], "::kaldi::SpMatrix<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSp(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_double_sp(self:MatrixBase, alpha:float, S:DoubleSpMatrix)
static PyObject* wrapAddSp_as__add_double_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("S"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_double_sp", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_double_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_double_sp", names[1], "float", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_double_sp", names[2], "::kaldi::SpMatrix<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSp(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_mat(self:MatrixBase, alpha:float, A:SpMatrix, B:MatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddSpMat_as__add_sp_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_sp_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_mat", names[1], "float", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_mat", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_mat", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_mat", names[4], "::kaldi::MatrixTransposeType", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_sp_mat", names[5], "float", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpMat(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_mat(self:MatrixBase, alpha:float, A:TpMatrix, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddTpMat_as__add_tp_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_tp_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_mat", names[1], "float", a[1]);
  ::kaldi::TpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_mat", names[2], "::kaldi::TpMatrix<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_mat", names[4], "::kaldi::MatrixBase<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  float arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_tp_mat", names[6], "float", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_sp(self:MatrixBase, alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, beta:float)
static PyObject* wrapAddMatSp_as__add_mat_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_sp", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_sp", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_sp", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_sp", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::SpMatrix<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_sp", names[4], "::kaldi::SpMatrix<float>", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_sp", names[5], "float", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatSp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_tp(self:MatrixBase, alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:TpMatrix, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatTp_as__add_mat_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_mat_tp", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_tp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_tp", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_tp", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_tp", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::TpMatrix<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_tp", names[4], "::kaldi::TpMatrix<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_tp", names[5], "::kaldi::MatrixTransposeType", a[5]);
  float arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_mat_tp", names[6], "float", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatTp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_tp(self:MatrixBase, alpha:float, A:TpMatrix, transA:MatrixTransposeType, B:TpMatrix, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddTpTp_as__add_tp_tp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_tp_tp", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_tp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_tp", names[1], "float", a[1]);
  ::kaldi::TpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_tp", names[2], "::kaldi::TpMatrix<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_tp", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::TpMatrix<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_tp", names[4], "::kaldi::TpMatrix<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_tp", names[5], "::kaldi::MatrixTransposeType", a[5]);
  float arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_tp_tp", names[6], "float", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpTp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_sp(self:MatrixBase, alpha:float, A:SpMatrix, B:SpMatrix, beta:float)
static PyObject* wrapAddSpSp_as__add_sp_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_add_sp_sp", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_sp", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_sp", names[1], "float", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_sp", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::SpMatrix<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_sp", names[3], "::kaldi::SpMatrix<float>", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_sp", names[4], "float", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpSp(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _invert(self:MatrixBase) -> (log_det:float, det_sign:float)
static PyObject* wrapInvert_as__invert(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("self"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_invert", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_invert", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float ret0{};
  float ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::Invert(arg1, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// _invert_in_double(self:MatrixBase) -> (log_det:float, det_sign:float)
static PyObject* wrapInvertDouble_as__invert_in_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("self"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_invert_in_double", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_invert_in_double", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float ret0{};
  float ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::InvertDouble(arg1, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// _copy_cols(self:MatrixBase, src:MatrixBase, indices:list<int>)
static PyObject* wrapCopyCols_as__copy_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_cols", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_cols", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_cols", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_cols", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyCols(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows(self:MatrixBase, src:MatrixBase, indices:list<int>)
static PyObject* wrapCopyRows_as__copy_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_rows", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_rows", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRows(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_cols(self:MatrixBase, src:MatrixBase, indices:list<int>)
static PyObject* wrapAddCols_as__add_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_cols", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_cols", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_cols", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_cols", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddCols(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_rows(self:MatrixBase, alpha:float, src:MatrixBase, indexes:list<int>)
static PyObject* wrapAddRows_as__add_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:_add_rows", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_rows", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_rows", names[1], "float", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_rows", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::std::vector< ::kaldi::MatrixIndexT> arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_rows", names[3], "::std::vector< ::kaldi::MatrixIndexT>", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddRows(arg1, std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_single_mat_double(self:DoubleMatrixBase, M:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as__copy_from_single_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_single_mat_double", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_single_mat_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_single_mat_double", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_single_mat_double", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromMat(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromMat(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_cmat_double(self:DoubleMatrixBase, M:CompressedMatrix)
static PyObject* wrapCopyFromCompressed_as__copy_from_cmat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_cmat_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_cmat_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::CompressedMatrix* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_cmat_double", names[1], "::kaldi::CompressedMatrix", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromCompressed(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_sp_double(self:DoubleMatrixBase, M:DoubleSpMatrix)
static PyObject* wrapCopyFromSp_as__copy_from_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_sp_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_sp_double", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_single_sp_double(self:DoubleMatrixBase, M:SpMatrix)
static PyObject* wrapCopyFromSp_as__copy_from_single_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("self"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_copy_from_single_sp_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_single_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_single_sp_double", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyFromSp(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_tp_double(self:DoubleMatrixBase, M:DoubleTpMatrix, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromTp_as__copy_from_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_tp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_tp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::TpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_tp_double", names[1], "::kaldi::TpMatrix<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_tp_double", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromTp(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromTp(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_single_tp_double(self:DoubleMatrixBase, M:TpMatrix, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromTp_as__copy_from_single_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("self"),
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_copy_from_single_tp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_single_tp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::TpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_single_tp_double", names[1], "::kaldi::TpMatrix<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_from_single_tp_double", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::CopyFromTp(arg1, *arg2); break;
  case 3:
    ::kaldi::CopyFromTp(arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_double(self:DoubleMatrixBase, alpha:float, S:DoubleSpMatrix)
static PyObject* wrapAddSp_as__add_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("S"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_sp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_double", names[1], "double", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_double", names[2], "::kaldi::SpMatrix<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSp(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_single_sp_double(self:DoubleMatrixBase, alpha:float, S:SpMatrix)
static PyObject* wrapAddSp_as__add_single_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("S"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_single_sp_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_single_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_single_sp_double", names[1], "double", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_single_sp_double", names[2], "::kaldi::SpMatrix<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSp(arg1, std::move(arg2), *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_mat_double(self:DoubleMatrixBase, alpha:float, A:DoubleSpMatrix, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddSpMat_as__add_sp_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_sp_mat_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_mat_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_mat_double", names[1], "double", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_mat_double", names[2], "::kaldi::SpMatrix<double>", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_mat_double", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_mat_double", names[4], "::kaldi::MatrixTransposeType", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_sp_mat_double", names[5], "double", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpMat(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_mat_double(self:DoubleMatrixBase, alpha:float, A:DoubleTpMatrix, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddTpMat_as__add_tp_mat_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_tp_mat_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_mat_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_mat_double", names[1], "double", a[1]);
  ::kaldi::TpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_mat_double", names[2], "::kaldi::TpMatrix<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_mat_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_mat_double", names[4], "::kaldi::MatrixBase<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_mat_double", names[5], "::kaldi::MatrixTransposeType", a[5]);
  double arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_tp_mat_double", names[6], "double", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpMat(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_sp_double(self:DoubleMatrixBase, alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, beta:float)
static PyObject* wrapAddMatSp_as__add_mat_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_sp_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_sp_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_sp_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_sp_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::SpMatrix<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_sp_double", names[4], "::kaldi::SpMatrix<double>", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_sp_double", names[5], "double", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatSp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_mat_tp_double(self:DoubleMatrixBase, alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleTpMatrix, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatTp_as__add_mat_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_mat_tp_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_tp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_tp_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_tp_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_tp_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::TpMatrix<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_tp_double", names[4], "::kaldi::TpMatrix<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_tp_double", names[5], "::kaldi::MatrixTransposeType", a[5]);
  double arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_mat_tp_double", names[6], "double", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddMatTp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_tp_tp_double(self:DoubleMatrixBase, alpha:float, A:DoubleTpMatrix, transA:MatrixTransposeType, B:DoubleTpMatrix, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddTpTp_as__add_tp_tp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:_add_tp_tp_double", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_tp_tp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_tp_tp_double", names[1], "double", a[1]);
  ::kaldi::TpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_tp_tp_double", names[2], "::kaldi::TpMatrix<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_tp_tp_double", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::TpMatrix<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_tp_tp_double", names[4], "::kaldi::TpMatrix<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_tp_tp_double", names[5], "::kaldi::MatrixTransposeType", a[5]);
  double arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_add_tp_tp_double", names[6], "double", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddTpTp(arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), std::move(arg7));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_sp_sp_double(self:DoubleMatrixBase, alpha:float, A:DoubleSpMatrix, B:DoubleSpMatrix, beta:float)
static PyObject* wrapAddSpSp_as__add_sp_sp_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_add_sp_sp_double", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_sp_sp_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_sp_sp_double", names[1], "double", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_sp_sp_double", names[2], "::kaldi::SpMatrix<double>", a[2]);
  ::kaldi::SpMatrix<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_sp_sp_double", names[3], "::kaldi::SpMatrix<double>", a[3]);
  double arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_sp_sp_double", names[4], "double", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddSpSp(arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _invert_double(self:DoubleMatrixBase) -> (log_det:float, det_sign:float)
static PyObject* wrapInvert_as__invert_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("self"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_invert_double", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_invert_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double ret0{};
  double ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::Invert(arg1, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// _copy_cols_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)
static PyObject* wrapCopyCols_as__copy_cols_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_cols_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_cols_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_cols_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_cols_double", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyCols(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_rows_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)
static PyObject* wrapCopyRows_as__copy_rows_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_copy_rows_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_rows_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_rows_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_copy_rows_double", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CopyRows(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_cols_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)
static PyObject* wrapAddCols_as__add_cols_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("self"),
      C("src"),
      C("indices"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_add_cols_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_cols_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_cols_double", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::std::vector< ::kaldi::MatrixIndexT> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_cols_double", names[2], "::std::vector< ::kaldi::MatrixIndexT>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddCols(arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _add_rows_double(self:DoubleMatrixBase, alpha:float, src:DoubleMatrixBase, indexes:list<int>)
static PyObject* wrapAddRows_as__add_rows_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("self"),
      C("alpha"),
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:_add_rows_double", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_rows_double", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_rows_double", names[1], "double", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_rows_double", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::std::vector< ::kaldi::MatrixIndexT> arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_rows_double", names[3], "::std::vector< ::kaldi::MatrixIndexT>", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddRows(arg1, std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_copy_from_double_mat"), (PyCFunction)wrapCopyFromMat_as__copy_from_double_mat, METH_VARARGS | METH_KEYWORDS, C("_copy_from_double_mat(self:MatrixBase, M:DoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromMat(::kaldi::MatrixBase<float> *, ::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("_copy_from_cmat"), (PyCFunction)wrapCopyFromCompressed_as__copy_from_cmat, METH_VARARGS | METH_KEYWORDS, C("_copy_from_cmat(self:MatrixBase, M:CompressedMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromCompressed(::kaldi::MatrixBase<float> *, ::kaldi::CompressedMatrix)")},
  {C("_copy_from_sp"), (PyCFunction)wrapCopyFromSp_as__copy_from_sp, METH_VARARGS | METH_KEYWORDS, C("_copy_from_sp(self:MatrixBase, M:SpMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromSp(::kaldi::MatrixBase<float> *, ::kaldi::SpMatrix<float>)")},
  {C("_copy_from_double_sp"), (PyCFunction)wrapCopyFromSp_as__copy_from_double_sp, METH_VARARGS | METH_KEYWORDS, C("_copy_from_double_sp(self:MatrixBase, M:DoubleSpMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromSp(::kaldi::MatrixBase<float> *, ::kaldi::SpMatrix<double>)")},
  {C("_copy_from_tp"), (PyCFunction)wrapCopyFromTp_as__copy_from_tp, METH_VARARGS | METH_KEYWORDS, C("_copy_from_tp(self:MatrixBase, M:TpMatrix, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromTp(::kaldi::MatrixBase<float> *, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType)")},
  {C("_copy_from_double_tp"), (PyCFunction)wrapCopyFromTp_as__copy_from_double_tp, METH_VARARGS | METH_KEYWORDS, C("_copy_from_double_tp(self:MatrixBase, M:DoubleTpMatrix, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromTp(::kaldi::MatrixBase<float> *, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType)")},
  {C("_add_sp"), (PyCFunction)wrapAddSp_as__add_sp, METH_VARARGS | METH_KEYWORDS, C("_add_sp(self:MatrixBase, alpha:float, S:SpMatrix)\n  Calls C++ function\n  void ::kaldi::AddSp(::kaldi::MatrixBase<float> *, float, ::kaldi::SpMatrix<float>)")},
  {C("_add_double_sp"), (PyCFunction)wrapAddSp_as__add_double_sp, METH_VARARGS | METH_KEYWORDS, C("_add_double_sp(self:MatrixBase, alpha:float, S:DoubleSpMatrix)\n  Calls C++ function\n  void ::kaldi::AddSp(::kaldi::MatrixBase<float> *, float, ::kaldi::SpMatrix<double>)")},
  {C("_add_sp_mat"), (PyCFunction)wrapAddSpMat_as__add_sp_mat, METH_VARARGS | METH_KEYWORDS, C("_add_sp_mat(self:MatrixBase, alpha:float, A:SpMatrix, B:MatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddSpMat(::kaldi::MatrixBase<float> *, float, ::kaldi::SpMatrix<float>, ::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("_add_tp_mat"), (PyCFunction)wrapAddTpMat_as__add_tp_mat, METH_VARARGS | METH_KEYWORDS, C("_add_tp_mat(self:MatrixBase, alpha:float, A:TpMatrix, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddTpMat(::kaldi::MatrixBase<float> *, float, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType, ::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("_add_mat_sp"), (PyCFunction)wrapAddMatSp_as__add_mat_sp, METH_VARARGS | METH_KEYWORDS, C("_add_mat_sp(self:MatrixBase, alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, beta:float)\n  Calls C++ function\n  void ::kaldi::AddMatSp(::kaldi::MatrixBase<float> *, float, ::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType, ::kaldi::SpMatrix<float>, float)")},
  {C("_add_mat_tp"), (PyCFunction)wrapAddMatTp_as__add_mat_tp, METH_VARARGS | METH_KEYWORDS, C("_add_mat_tp(self:MatrixBase, alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:TpMatrix, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddMatTp(::kaldi::MatrixBase<float> *, float, ::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("_add_tp_tp"), (PyCFunction)wrapAddTpTp_as__add_tp_tp, METH_VARARGS | METH_KEYWORDS, C("_add_tp_tp(self:MatrixBase, alpha:float, A:TpMatrix, transA:MatrixTransposeType, B:TpMatrix, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddTpTp(::kaldi::MatrixBase<float> *, float, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("_add_sp_sp"), (PyCFunction)wrapAddSpSp_as__add_sp_sp, METH_VARARGS | METH_KEYWORDS, C("_add_sp_sp(self:MatrixBase, alpha:float, A:SpMatrix, B:SpMatrix, beta:float)\n  Calls C++ function\n  void ::kaldi::AddSpSp(::kaldi::MatrixBase<float> *, float, ::kaldi::SpMatrix<float>, ::kaldi::SpMatrix<float>, float)")},
  {C("_invert"), (PyCFunction)wrapInvert_as__invert, METH_VARARGS | METH_KEYWORDS, C("_invert(self:MatrixBase) -> (log_det:float, det_sign:float)\n\nInverts the matrix.\n\nReturns:\n  log_det(float): The log determinant.\n  det_sign(float): The sign of the determinant, 1 or -1.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("_invert_in_double"), (PyCFunction)wrapInvertDouble_as__invert_in_double, METH_VARARGS | METH_KEYWORDS, C("_invert_in_double(self:MatrixBase) -> (log_det:float, det_sign:float)\n\nInverts the matrix in double precision.\n\nReturns:\n  log_det(float): The log determinant.\n  det_sign(float): The sign of the determinant, 1 or -1.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("_copy_cols"), (PyCFunction)wrapCopyCols_as__copy_cols, METH_VARARGS | METH_KEYWORDS, C("_copy_cols(self:MatrixBase, src:MatrixBase, indices:list<int>)\n\nCopies columns from another matrix.\n\nCopies column r from column indices[r] of src. As a special case, if\nindexes[i] == -1, sets column i to zero. All elements of indices must\nbe in [-1, src.num_cols-1], and src.num_rows must equal self.num_rows.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_copy_rows"), (PyCFunction)wrapCopyRows_as__copy_rows, METH_VARARGS | METH_KEYWORDS, C("_copy_rows(self:MatrixBase, src:MatrixBase, indices:list<int>)\n\nCopies rows from another matrix.\n\nCopies row r from row indices[r] of src. As a special case, if\nindexes[i] == -1, sets row i to zero. All elements of indices must\nbe in [-1, src.num_rows-1], and src.num_cols must equal self.num_cols.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_add_cols"), (PyCFunction)wrapAddCols_as__add_cols, METH_VARARGS | METH_KEYWORDS, C("_add_cols(self:MatrixBase, src:MatrixBase, indices:list<int>)\n\nAdds columns from another matrix.\n\nAdds column indices[r] of src to column r. As a special case, if\nindexes[i] == -1, skips column i. All elements of indices must\nbe in [-1, src.num_cols-1], and src.num_rows must equal self.num_rows.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_add_rows"), (PyCFunction)wrapAddRows_as__add_rows, METH_VARARGS | METH_KEYWORDS, C("_add_rows(self:MatrixBase, alpha:float, src:MatrixBase, indexes:list<int>)\n\nAdds rows from another matrix.\n\nScales row indices[r] of src with alpha and adds it to row r. As a\nspecial case, if indexes[i] == -1, skips row i. All elements of indices\nmust be in [-1, src.num_rows-1], and src.num_cols must equal\nself.num_cols.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_copy_from_single_mat_double"), (PyCFunction)wrapCopyFromMat_as__copy_from_single_mat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_single_mat_double(self:DoubleMatrixBase, M:MatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromMat(::kaldi::MatrixBase<double> *, ::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("_copy_from_cmat_double"), (PyCFunction)wrapCopyFromCompressed_as__copy_from_cmat_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_cmat_double(self:DoubleMatrixBase, M:CompressedMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromCompressed(::kaldi::MatrixBase<double> *, ::kaldi::CompressedMatrix)")},
  {C("_copy_from_sp_double"), (PyCFunction)wrapCopyFromSp_as__copy_from_sp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_sp_double(self:DoubleMatrixBase, M:DoubleSpMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromSp(::kaldi::MatrixBase<double> *, ::kaldi::SpMatrix<double>)")},
  {C("_copy_from_single_sp_double"), (PyCFunction)wrapCopyFromSp_as__copy_from_single_sp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_single_sp_double(self:DoubleMatrixBase, M:SpMatrix)\n  Calls C++ function\n  void ::kaldi::CopyFromSp(::kaldi::MatrixBase<double> *, ::kaldi::SpMatrix<float>)")},
  {C("_copy_from_tp_double"), (PyCFunction)wrapCopyFromTp_as__copy_from_tp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_tp_double(self:DoubleMatrixBase, M:DoubleTpMatrix, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromTp(::kaldi::MatrixBase<double> *, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType)")},
  {C("_copy_from_single_tp_double"), (PyCFunction)wrapCopyFromTp_as__copy_from_single_tp_double, METH_VARARGS | METH_KEYWORDS, C("_copy_from_single_tp_double(self:DoubleMatrixBase, M:TpMatrix, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CopyFromTp(::kaldi::MatrixBase<double> *, ::kaldi::TpMatrix<float>, ::kaldi::MatrixTransposeType)")},
  {C("_add_sp_double"), (PyCFunction)wrapAddSp_as__add_sp_double, METH_VARARGS | METH_KEYWORDS, C("_add_sp_double(self:DoubleMatrixBase, alpha:float, S:DoubleSpMatrix)\n  Calls C++ function\n  void ::kaldi::AddSp(::kaldi::MatrixBase<double> *, double, ::kaldi::SpMatrix<double>)")},
  {C("_add_single_sp_double"), (PyCFunction)wrapAddSp_as__add_single_sp_double, METH_VARARGS | METH_KEYWORDS, C("_add_single_sp_double(self:DoubleMatrixBase, alpha:float, S:SpMatrix)\n  Calls C++ function\n  void ::kaldi::AddSp(::kaldi::MatrixBase<double> *, double, ::kaldi::SpMatrix<float>)")},
  {C("_add_sp_mat_double"), (PyCFunction)wrapAddSpMat_as__add_sp_mat_double, METH_VARARGS | METH_KEYWORDS, C("_add_sp_mat_double(self:DoubleMatrixBase, alpha:float, A:DoubleSpMatrix, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddSpMat(::kaldi::MatrixBase<double> *, double, ::kaldi::SpMatrix<double>, ::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("_add_tp_mat_double"), (PyCFunction)wrapAddTpMat_as__add_tp_mat_double, METH_VARARGS | METH_KEYWORDS, C("_add_tp_mat_double(self:DoubleMatrixBase, alpha:float, A:DoubleTpMatrix, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddTpMat(::kaldi::MatrixBase<double> *, double, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType, ::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("_add_mat_sp_double"), (PyCFunction)wrapAddMatSp_as__add_mat_sp_double, METH_VARARGS | METH_KEYWORDS, C("_add_mat_sp_double(self:DoubleMatrixBase, alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, beta:float)\n  Calls C++ function\n  void ::kaldi::AddMatSp(::kaldi::MatrixBase<double> *, double, ::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType, ::kaldi::SpMatrix<double>, double)")},
  {C("_add_mat_tp_double"), (PyCFunction)wrapAddMatTp_as__add_mat_tp_double, METH_VARARGS | METH_KEYWORDS, C("_add_mat_tp_double(self:DoubleMatrixBase, alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleTpMatrix, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddMatTp(::kaldi::MatrixBase<double> *, double, ::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("_add_tp_tp_double"), (PyCFunction)wrapAddTpTp_as__add_tp_tp_double, METH_VARARGS | METH_KEYWORDS, C("_add_tp_tp_double(self:DoubleMatrixBase, alpha:float, A:DoubleTpMatrix, transA:MatrixTransposeType, B:DoubleTpMatrix, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::AddTpTp(::kaldi::MatrixBase<double> *, double, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType, ::kaldi::TpMatrix<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("_add_sp_sp_double"), (PyCFunction)wrapAddSpSp_as__add_sp_sp_double, METH_VARARGS | METH_KEYWORDS, C("_add_sp_sp_double(self:DoubleMatrixBase, alpha:float, A:DoubleSpMatrix, B:DoubleSpMatrix, beta:float)\n  Calls C++ function\n  void ::kaldi::AddSpSp(::kaldi::MatrixBase<double> *, double, ::kaldi::SpMatrix<double>, ::kaldi::SpMatrix<double>, double)")},
  {C("_invert_double"), (PyCFunction)wrapInvert_as__invert_double, METH_VARARGS | METH_KEYWORDS, C("_invert_double(self:DoubleMatrixBase) -> (log_det:float, det_sign:float)\n\nInverts the matrix.\n\nReturns:\n  log_det(float): The log determinant.\n  det_sign(float): The sign of the determinant, 1 or -1.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("_copy_cols_double"), (PyCFunction)wrapCopyCols_as__copy_cols_double, METH_VARARGS | METH_KEYWORDS, C("_copy_cols_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)\n\nCopies columns from another matrix.\n\nCopies column r from column indices[r] of src. As a special case, if\nindexes[i] == -1, sets column i to zero. All elements of indices must\nbe in [-1, src.num_cols-1], and src.num_rows must equal self.num_rows.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_copy_rows_double"), (PyCFunction)wrapCopyRows_as__copy_rows_double, METH_VARARGS | METH_KEYWORDS, C("_copy_rows_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)\n\nCopies rows from another matrix.\n\nCopies row r from row indices[r] of src. As a special case, if\nindexes[i] == -1, sets row i to zero. All elements of indices must\nbe in [-1, src.num_rows-1], and src.num_cols must equal self.num_cols.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_add_cols_double"), (PyCFunction)wrapAddCols_as__add_cols_double, METH_VARARGS | METH_KEYWORDS, C("_add_cols_double(self:DoubleMatrixBase, src:DoubleMatrixBase, indices:list<int>)\n\nAdds columns from another matrix.\n\nAdds column indices[r] of src to column r. As a special case, if\nindexes[i] == -1, skips column i. All elements of indices must\nbe in [-1, src.num_cols-1], and src.num_rows must equal self.num_rows.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {C("_add_rows_double"), (PyCFunction)wrapAddRows_as__add_rows_double, METH_VARARGS | METH_KEYWORDS, C("_add_rows_double(self:DoubleMatrixBase, alpha:float, src:DoubleMatrixBase, indexes:list<int>)\n\nAdds rows from another matrix.\n\nScales row indices[r] of src with alpha and adds it to row r. As a\nspecial case, if indexes[i] == -1, skips row i. All elements of indices\nmust be in [-1, src.num_rows-1], and src.num_cols must equal\nself.num_cols.\n\nArgs:\n  src (Matrix): The input matrix.\n  indices (List[int]): The list of indices.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_matrix_ext",  // module name
  "CLIF-generated module for matrix/kaldi-matrix-ext.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sp_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_tp_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_compressed_matrix")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__matrix__ext_clifwrap
