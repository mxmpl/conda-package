//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/sp-matrix.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/matrix-ext.h"
#include "sp-matrix-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __sp__matrix_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pySpMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SpMatrix<float>> cpp;
};
static ::kaldi::SpMatrix<float>* ThisPtr(PyObject*);

// @classmethod from_size(r:int, resize_type:MatrixResizeType=default) -> SpMatrix
static PyObject* wrapSpMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("r"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_size", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<float>>(std::move(arg1)); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<float>>(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(orig:SpMatrix) -> SpMatrix
static PyObject* wrapSpMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("orig"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SpMatrix<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<float>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_matrix(orig:MatrixBase, copy_type:SpCopyType=default) -> SpMatrix
static PyObject* wrapSpMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("orig"),
      C("copy_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::SpCopyType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::SpCopyType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<float>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<float>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_with_symmetric_(other:SpMatrix)
static PyObject* wrapSwap_as_swap_with_symmetric_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_with_symmetric_", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_with_symmetric_", names[0], "::kaldi::SpMatrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_from_sp_(other:SpMatrix)
static PyObject* wrapCopyFromSp_as_copy_from_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_sp_", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_sp_", names[0], "::kaldi::SpMatrix<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSp(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_from_mat_(orig:MatrixBase, copy_type:SpCopyType=default)
static PyObject* wrapCopyFromMat_as_copy_from_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("orig"),
      C("copy_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_mat_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::SpCopyType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_mat_", names[1], "::kaldi::SpCopyType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// getitem(r:int, c:int) -> float
static PyObject* wrapgetitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("c"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// invert_()
static PyObject* wrapInvert_as_invert_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Invert();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// invert_double_()
static PyObject* wrapInvertDouble_as_invert_double_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertDouble();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// cond() -> float
static PyObject* wrapCond_as_cond(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Cond();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_pow_(exponent:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("exponent"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max_abs_eig() -> float
static PyObject* wrapMaxAbsEig_as_max_abs_eig(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MaxAbsEig();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_pos_def() -> bool
static PyObject* wrapIsPosDef_as_is_pos_def(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsPosDef();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add_sp_(alpha:float, Ma:SpMatrix)
static PyObject* wrapAddSp_as_add_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("Ma"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_sp_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_sp_", names[0], "float", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_sp_", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddSp(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// log_pos_def_det() -> float
static PyObject* wrapLogPosDefDet_as_log_pos_def_det(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LogPosDefDet();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add_vec2_(alpha:float, v:VectorBase)
static PyObject* wrapAddVec2_as_add_vec2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec2_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec2_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec2_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, v:VectorBase, w:VectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("w"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec_", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_2_sp_(alpha:float, v:VectorBase, S:SpMatrix, beta:float)
static PyObject* wrapAddVec2Sp_as_add_vec_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("S"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_2_sp_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_2_sp_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_2_sp_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_2_sp_", names[2], "::kaldi::SpMatrix<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_2_sp_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2Sp(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_diag_vec_(alpha:float, v:VectorBase)
static PyObject* wrapAddDiagVec_as_add_diag_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_diag_vec_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddDiagVec(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat2_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, beta:float)
static PyObject* wrapAddMat2_as_add_mat2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat2_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat2_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat2_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat2_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat2_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_2_sp_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, A:SpMatrix, beta:float=default)
static PyObject* wrapAddMat2Sp_as_add_mat_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("A"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_2_sp_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_2_sp_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_2_sp_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_2_sp_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::SpMatrix<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_2_sp_", names[3], "::kaldi::SpMatrix<float>", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_2_sp_", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_smat_2_sp_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, A:SpMatrix, beta:float=default)
static PyObject* wrapAddSmat2Sp_as_add_smat_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("A"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_smat_2_sp_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_smat_2_sp_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_smat_2_sp_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_smat_2_sp_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::SpMatrix<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_smat_2_sp_", names[3], "::kaldi::SpMatrix<float>", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_smat_2_sp_", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddSmat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddSmat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_2_vec_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, v:VectorBase, beta:float=default)
static PyObject* wrapAddMat2Vec_as_add_mat_2_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_2_vec_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_2_vec_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_2_vec_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_2_vec_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::VectorBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_2_vec_", names[3], "::kaldi::VectorBase<float>", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_2_vec_", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMat2Vec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMat2Vec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_matrix_(floor:SpMatrix, alpha:float=default, verbose:bool=default) -> int
static PyObject* wrapApplyFloor_as_apply_floor_matrix_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("floor"),
      C("alpha"),
      C("verbose"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:apply_floor_matrix_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_matrix_", names[0], "::kaldi::SpMatrix<float>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("apply_floor_matrix_", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_floor_matrix_", names[1], "float", a[1]);
  }
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("apply_floor_matrix_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApplyFloor(*arg1); break;
  case 2:
    ret0 = c->ApplyFloor(*arg1, std::move(arg2)); break;
  case 3:
    ret0 = c->ApplyFloor(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_floor_(floor:float) -> int
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_diagonal(cutoff:float=default) -> bool
static PyObject* wrapIsDiagonal_as_is_diagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_diagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_diagonal", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsDiagonal(); break;
  case 1:
    ret0 = c->IsDiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(cutoff:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_triagonal(cutoff:float=default) -> bool
static PyObject* wrapIsTridiagonal_as_is_triagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_triagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_triagonal", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsTridiagonal(); break;
  case 1:
    ret0 = c->IsTridiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// approx_equal(other:SpMatrix, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal", names[0], "::kaldi::SpMatrix<float>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// limit_cond(maxCond:float=default, invert:bool=default) -> int
static PyObject* wrapLimitCond_as_limit_cond(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("maxCond"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|OO:limit_cond", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!a[0]) return DefaultArgMissedError("limit_cond", names[0]);
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("limit_cond", names[0], "float", a[0]);
  }
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("limit_cond", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LimitCond(); break;
  case 1:
    ret0 = c->LimitCond(std::move(arg1)); break;
  case 2:
    ret0 = c->LimitCond(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// limit_cond_double(maxCond:float=default, invert:bool=default) -> int
static PyObject* wrapLimitCondDouble_as_limit_cond_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("maxCond"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|OO:limit_cond_double", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!a[0]) return DefaultArgMissedError("limit_cond_double", names[0]);
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("limit_cond_double", names[0], "float", a[0]);
  }
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("limit_cond_double", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LimitCondDouble(); break;
  case 1:
    ret0 = c->LimitCondDouble(std::move(arg1)); break;
  case 2:
    ret0 = c->LimitCondDouble(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace() -> float
static PyObject* wrapTrace_as_trace(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Trace();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// tridiagonalize_(Q:MatrixBase)
static PyObject* wrapTridiagonalize_as_tridiagonalize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("Q"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tridiagonalize_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tridiagonalize_", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tridiagonalize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// qr_(Q:MatrixBase)
static PyObject* wrapQr_as_qr_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("Q"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:qr_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("qr_", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Qr(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::PackedMatrix<float>*
static PyObject* as_kaldi_PackedMatrix_float(PyObject* self) {
  ::kaldi::PackedMatrix<float>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::PackedMatrix<float>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapSpMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(r:int, resize_type:MatrixResizeType=default) -> SpMatrix\n\nCreates a new symmetric matrix of given size.\n\nArgs:\n  r (int): The number or rows.\n  resize_type (:class:`MatrixResizeType`): Determines how the elements\n    are initialized. If SET_ZERO (or COPY_DATA), they are set to zero.\n    If UNDEFINED, they are left uninitialized. Defaults to SET_ZERO.")},
  {C("from_other"), (PyCFunction)wrapSpMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(orig:SpMatrix) -> SpMatrix\n\nCreates a new symmetric matrix from the given symmetric matrix.\n\nArgs:\n    orig (SpMatrix): The input symmetric matrix.")},
  {C("from_matrix"), (PyCFunction)wrapSpMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(orig:MatrixBase, copy_type:SpCopyType=default) -> SpMatrix\n\nCreates a new symmetric matrix from the given square matrix.\n\nArgs:\n    orig (MatrixBase): The input square matrix.\n    copy_type (SpCopyType): Determines how elements will be copied.\n      If TAKE_LOWER, takes lower triangular elements in orig.\n      If TAKE_UPPER, takes upper triangular elements in orig.\n      If TAKE_MEAN, takes the average of symmetric elements in orig.\n      If TAKE_MEAN_AND_CHECK, does an extra symmetry check before\n      taking average of symmetric elements in orig.\n\nRaises:\n  RuntimeError: If orig is not a square matrix with matching size.")},
  {C("swap_with_symmetric_"), (PyCFunction)wrapSwap_as_swap_with_symmetric_, METH_VARARGS | METH_KEYWORDS, C("swap_with_symmetric_(other:SpMatrix)\n\nSwaps the contents with another symmetric matrix.\n\nShallow swap.\n\nArgs:\n  other (SpMatrix): The matrix to swap contents with.")},
  {C("copy_from_sp_"), (PyCFunction)wrapCopyFromSp_as_copy_from_sp_, METH_VARARGS | METH_KEYWORDS, C("copy_from_sp_(other:SpMatrix)\n\nCopies the elements from another symmetric matrix.\n\nArgs:\n  other(SpMatrix): The input symmetric matrix.\n\nRaises:\n  RuntimeError: In case of dimension mismatch.")},
  {C("copy_from_mat_"), (PyCFunction)wrapCopyFromMat_as_copy_from_mat_, METH_VARARGS | METH_KEYWORDS, C("copy_from_mat_(orig:MatrixBase, copy_type:SpCopyType=default)\n\nCopies the elements from a square matrix.\n\nArgs:\n    orig (MatrixBase): The input matrix.\n    copy_type (SpCopyType): Determines how elements will be copied.\n      If TAKE_LOWER, takes lower triangular elements in orig.\n      If TAKE_UPPER, takes upper triangular elements in orig.\n      If TAKE_MEAN, takes the average of symmetric elements in orig.\n      If TAKE_MEAN_AND_CHECK, does an extra symmetry check before\n      taking average of symmetric elements in orig.\n\nRaises:\n    RuntimeError: If orig is not symmetric.")},
  {C("getitem"), (PyCFunction)wrapgetitem, METH_VARARGS | METH_KEYWORDS, C("getitem(r:int, c:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  r (int): The row index of the element to get.\n  c (int): The column index of the element to get.\n\nReturns:\n  The element at the given index.\n\nRaises:\n  RuntimeError: If r > num_rows or c > num_cols.")},
  {C("invert_"), (PyCFunction)wrapInvert_as_invert_, METH_NOARGS, C("invert_()\n\nInverts the matrix.")},
  {C("invert_double_"), (PyCFunction)wrapInvertDouble_as_invert_double_, METH_NOARGS, C("invert_double_()\n\nInverts the matrix in double precision.")},
  {C("cond"), (PyCFunction)wrapCond_as_cond, METH_NOARGS, C("cond() -> float\n\nReturns the condition number of the SVD computation.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(exponent:float)\n\nApplies power to all elements of matrix.\n\nArgs:\n    expoenent (float): The exponent.")},
  {C("max_abs_eig"), (PyCFunction)wrapMaxAbsEig_as_max_abs_eig, METH_NOARGS, C("max_abs_eig() -> float\n\nReturns the maximum of the absolute values of the eigenvalues.")},
  {C("is_pos_def"), (PyCFunction)wrapIsPosDef_as_is_pos_def, METH_NOARGS, C("is_pos_def() -> bool\n\nReturns True if the matrix is positive definite.")},
  {C("add_sp_"), (PyCFunction)wrapAddSp_as_add_sp_, METH_VARARGS | METH_KEYWORDS, C("add_sp_(alpha:float, Ma:SpMatrix)\n\nPerforms the operation self = self+alpha*Ma.\n\nArgs:\n  alpha(float): A scaling constant\n  Ma(SpMatrix): A symmetrix Matrix")},
  {C("log_pos_def_det"), (PyCFunction)wrapLogPosDefDet_as_log_pos_def_det, METH_NOARGS, C("log_pos_def_det() -> float\n\nComputes the log determinant.\n\nReturns:\n  The log determinant\n\nRaises:\n  RuntimeError: If matrix is not positive definite.")},
  {C("add_vec2_"), (PyCFunction)wrapAddVec2_as_add_vec2_, METH_VARARGS | METH_KEYWORDS, C("add_vec2_(alpha:float, v:VectorBase)\n\nPerforms the operation self = self + alpha*(v*v^T)\n\nArgs:\n    alpha(float): A scaling constant\n    v(VectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, v:VectorBase, w:VectorBase)\n\nPerforms the operation self = self + alpha*(v*w^T+w*v^T)\n\nArgs:\n    alpha(float): A scaling constant\n    v(VectorBase): A vector\n    w(VectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_vec_2_sp_"), (PyCFunction)wrapAddVec2Sp_as_add_vec_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_vec_2_sp_(alpha:float, v:VectorBase, S:SpMatrix, beta:float)\n\nPerform self = beta*self + alpha*diag(v)*S*diag(v)\n\nArgs:\n    alpha(float): A scaling constant\n    v(VectorBase): A vector\n    S(SpMatrix): A symmetric matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_diag_vec_"), (PyCFunction)wrapAddDiagVec_as_add_diag_vec_, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_(alpha:float, v:VectorBase)\n\nPerforms self = self+diag(v)\n\nArgs:\n    alpha(float): A scaling constant\n    v(VectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_mat2_"), (PyCFunction)wrapAddMat2_as_add_mat2_, METH_VARARGS | METH_KEYWORDS, C("add_mat2_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, beta:float)\n\nIf transM == kNoTrans performs self = beta*self+alpha*M*M^T.\n   If transM == kTrans self = beta*self+alpha*M^T*M\n\nArgs:\n    alpha(float): A constant\n    M(MatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_mat_2_sp_"), (PyCFunction)wrapAddMat2Sp_as_add_mat_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_mat_2_sp_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, A:SpMatrix, beta:float=default)\n\nIf transM == kNoTrans perform self = beta*self+alpha*M*A*M^T.\n   If transM == kTrans perform self = beta*self+alpha*M^T*A*M.\n\nArgs:\n    alpha(float): A constant\n    M(MatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    A(SpMatrix): A symmetric matrix\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_smat_2_sp_"), (PyCFunction)wrapAddSmat2Sp_as_add_smat_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_smat_2_sp_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, A:SpMatrix, beta:float=default)\n\nSame as AddMat2Sp, optimized for sparse M.")},
  {C("add_mat_2_vec_"), (PyCFunction)wrapAddMat2Vec_as_add_mat_2_vec_, METH_VARARGS | METH_KEYWORDS, C("add_mat_2_vec_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, v:VectorBase, beta:float=default)\n\nIf transM == kNoTrans perform self = beta*self+alpha*M*diag(v)*M^T.\n   If transM == kTrans perform self = beta*self+alpha*M^T*diag(v)*M.\n\nArgs:\n    alpha(float): A constant\n    M(MatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    v(VectorBase): A vector\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("apply_floor_matrix_"), (PyCFunction)wrapApplyFloor_as_apply_floor_matrix_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_matrix_(floor:SpMatrix, alpha:float=default, verbose:bool=default) -> int\n\nFloors this symmetric matrix to the matrix alpha*floor,\n   where the matrix floor is positive definite.\n   It is floored in the sense that after flooring it must be that\n   x^T*self*x >= x^T*(alpha*floor)*x.\n   floor must be positive definite.\n\nArgs:\n    floor(SpMatrix): A positive definite matrix\n    alpha(float): a contant\n    verbose(bool): Default is False. If true, extra messages\n                   can be printed\n\nReturns:\n    the number of elements that were floored.\n\nRaises:\n    Error if floor is not positive definite.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float) -> int\n\nApplies floor to all elements. If self(i,j)<floor then self(i,j)=floor.\n\nArgs:\n    floor(float): The floor value to check against\n\nReturns:\n    The number of elements affected by the flooring operation")},
  {C("is_diagonal"), (PyCFunction)wrapIsDiagonal_as_is_diagonal, METH_VARARGS | METH_KEYWORDS, C("is_diagonal(cutoff:float=default) -> bool\n\nChecks if the matrix is diagonal. The nondiagonal elements\n   must be less or equal to cutoff value.\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if sum(digonal_elements)*cutoff > sum(nondiagonal_elements),\n    otherwise false")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(cutoff:float=default) -> bool\n\nChecks if the matrix is identity-like. It does not have to be square.\n   The nondiagonal elements must be less or equal to cutoff value,\n   while the diagonal ones must be one.\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if the diagonal elements are 1 and sum(nondiagonal_elements)<=cutoff")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if all elements are 0 (where 0 is the cutoff value).\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if it is a zero matrix")},
  {C("is_triagonal"), (PyCFunction)wrapIsTridiagonal_as_is_triagonal, METH_VARARGS | METH_KEYWORDS, C("is_triagonal(cutoff:float=default) -> bool\n\nReturns true if the matrix is tridiagonal(based on the\ncutoff value).")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nReturns the Frobenius norm of the matrix.")},
  {C("approx_equal"), (PyCFunction)wrapApproxEqual_as_approx_equal, METH_VARARGS | METH_KEYWORDS, C("approx_equal(other:SpMatrix, tol:float=default) -> bool\n\nChecks if self is equal with other by calculating the Frobenius\n   norm of their difference.\n\nArgs:\n    other(SpMatrix): The matrix to check against\n    tol(float): the tolerance\n\nReturns:\n    True if ||(self-other)||_F <= tol * ||self||_F")},
  {C("limit_cond"), (PyCFunction)wrapLimitCond_as_limit_cond, METH_VARARGS | METH_KEYWORDS, C("limit_cond(maxCond:float=default, invert:bool=default) -> int\n\nPerforms self = P*diag(floor(s))*P^T, where s is the eigenvalues\n   and P is the eigenvectors.\n\nArgs:\n    MaxCond(float): Determines the flooring threshold (i.e. floor=max_eigen/MaxCond)\n\nRaises:\n    Error if matrix is not positive definite")},
  {C("limit_cond_double"), (PyCFunction)wrapLimitCondDouble_as_limit_cond_double, METH_VARARGS | METH_KEYWORDS, C("limit_cond_double(maxCond:float=default, invert:bool=default) -> int\n\nSame as LimitCond but the resulting operation has ``double'' precision.")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_NOARGS, C("trace() -> float\n\nReturns the trace of the matrix.")},
  {C("tridiagonalize_"), (PyCFunction)wrapTridiagonalize_as_tridiagonalize_, METH_VARARGS | METH_KEYWORDS, C("tridiagonalize_(Q:MatrixBase)\n\nTridiagonalize the matrix with an orthogonal transformation.\n   Performs  self = Q*self*Q^T for an orthogonal Q.\n\nArgs:\n    Q(MatrixBase): A matrix that must be orthogonal.")},
  {C("qr_"), (PyCFunction)wrapQr_as_qr_, METH_VARARGS | METH_KEYWORDS, C("qr_(Q:MatrixBase)\n\nThe symmetric QR algorithm. This is the symmetric QR algorithm,\n   from Golub and Van Loan 3rd ed., Algorithm 8.3.3.\n\nArgs:\n    Q(MatrixBase): A matrix")},
  {C("as_kaldi_PackedMatrix_float"), (PyCFunction)as_kaldi_PackedMatrix_float, METH_NOARGS, C("Upcast to ::kaldi::PackedMatrix<float>*")},
  {}
};

// SpMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SpMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SpMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sp_matrix.SpMatrix",               // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Single precision symmetric matrix.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SpMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SpMatrix<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SpMatrix<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SpMatrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SpMatrix<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SpMatrix<float>* c = static_cast<::kaldi::SpMatrix<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SpMatrix<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySpMatrix

namespace pyDoubleSpMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SpMatrix<double>> cpp;
};
static ::kaldi::SpMatrix<double>* ThisPtr(PyObject*);

// @classmethod from_size(r:int, resize_type:MatrixResizeType=default) -> DoubleSpMatrix
static PyObject* wrapSpMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("r"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_size", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<double>>(std::move(arg1)); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<double>>(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(orig:DoubleSpMatrix) -> DoubleSpMatrix
static PyObject* wrapSpMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("orig"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::SpMatrix<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<double>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_matrix(orig:DoubleMatrixBase, copy_type:SpCopyType=default) -> DoubleSpMatrix
static PyObject* wrapSpMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("orig"),
      C("copy_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::SpCopyType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::SpCopyType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SpMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<double>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::SpMatrix<double>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_with_symmetric_(other:DoubleSpMatrix)
static PyObject* wrapSwap_as_swap_with_symmetric_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_with_symmetric_", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_with_symmetric_", names[0], "::kaldi::SpMatrix<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_from_sp_(other:DoubleSpMatrix)
static PyObject* wrapCopyFromSp_as_copy_from_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_from_sp_", names, &a[0])) return nullptr;
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_sp_", names[0], "::kaldi::SpMatrix<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromSp(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_from_mat_(orig:DoubleMatrixBase, copy_type:SpCopyType=default)
static PyObject* wrapCopyFromMat_as_copy_from_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("orig"),
      C("copy_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_mat_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::SpCopyType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_mat_", names[1], "::kaldi::SpCopyType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// getitem(r:int, c:int) -> float
static PyObject* wrapgetitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("c"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// invert_()
static PyObject* wrapInvert_as_invert_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Invert();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// invert_double_()
static PyObject* wrapInvertDouble_as_invert_double_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertDouble();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// cond() -> float
static PyObject* wrapCond_as_cond(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Cond();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_pow_(exponent:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("exponent"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max_abs_eig() -> float
static PyObject* wrapMaxAbsEig_as_max_abs_eig(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MaxAbsEig();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_pos_def() -> bool
static PyObject* wrapIsPosDef_as_is_pos_def(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsPosDef();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add_sp_(alpha:float, Ma:DoubleSpMatrix)
static PyObject* wrapAddSp_as_add_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("Ma"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_sp_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_sp_", names[0], "double", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_sp_", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddSp(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// log_pos_def_det() -> float
static PyObject* wrapLogPosDefDet_as_log_pos_def_det(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LogPosDefDet();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add_vec2_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVec2_as_add_vec2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec2_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec2_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec2_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, v:DoubleVectorBase, w:DoubleVectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("w"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec_", names, &a[0], &a[1], &a[2])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_2_sp_(alpha:float, v:DoubleVectorBase, S:DoubleSpMatrix, beta:float)
static PyObject* wrapAddVec2Sp_as_add_vec_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("S"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_2_sp_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_2_sp_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_2_sp_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_2_sp_", names[2], "::kaldi::SpMatrix<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_2_sp_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2Sp(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_diag_vec_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddDiagVec_as_add_diag_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_diag_vec_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddDiagVec(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat2_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, beta:float)
static PyObject* wrapAddMat2_as_add_mat2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat2_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat2_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat2_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat2_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat2_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_2_sp_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, A:DoubleSpMatrix, beta:float=default)
static PyObject* wrapAddMat2Sp_as_add_mat_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("A"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_2_sp_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_2_sp_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_2_sp_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_2_sp_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::SpMatrix<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_2_sp_", names[3], "::kaldi::SpMatrix<double>", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_2_sp_", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_smat_2_sp_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, A:DoubleSpMatrix, beta:float=default)
static PyObject* wrapAddSmat2Sp_as_add_smat_2_sp_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("A"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_smat_2_sp_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_smat_2_sp_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_smat_2_sp_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_smat_2_sp_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::SpMatrix<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_smat_2_sp_", names[3], "::kaldi::SpMatrix<double>", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_smat_2_sp_", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddSmat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddSmat2Sp(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_2_vec_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, v:DoubleVectorBase, beta:float=default)
static PyObject* wrapAddMat2Vec_as_add_mat_2_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_2_vec_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_2_vec_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_2_vec_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_2_vec_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::VectorBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_2_vec_", names[3], "::kaldi::VectorBase<double>", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_2_vec_", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMat2Vec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMat2Vec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_matrix_(floor:DoubleSpMatrix, alpha:float=default, verbose:bool=default) -> int
static PyObject* wrapApplyFloor_as_apply_floor_matrix_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("floor"),
      C("alpha"),
      C("verbose"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:apply_floor_matrix_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_matrix_", names[0], "::kaldi::SpMatrix<double>", a[0]);
  double arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("apply_floor_matrix_", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_floor_matrix_", names[1], "double", a[1]);
  }
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("apply_floor_matrix_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApplyFloor(*arg1); break;
  case 2:
    ret0 = c->ApplyFloor(*arg1, std::move(arg2)); break;
  case 3:
    ret0 = c->ApplyFloor(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_floor_(floor:float) -> int
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_diagonal(cutoff:float=default) -> bool
static PyObject* wrapIsDiagonal_as_is_diagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_diagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_diagonal", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsDiagonal(); break;
  case 1:
    ret0 = c->IsDiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(cutoff:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_triagonal(cutoff:float=default) -> bool
static PyObject* wrapIsTridiagonal_as_is_triagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_triagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_triagonal", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsTridiagonal(); break;
  case 1:
    ret0 = c->IsTridiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// approx_equal(other:DoubleSpMatrix, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal", names[0], "::kaldi::SpMatrix<double>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// limit_cond(maxCond:float=default, invert:bool=default) -> int
static PyObject* wrapLimitCond_as_limit_cond(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("maxCond"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|OO:limit_cond", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!a[0]) return DefaultArgMissedError("limit_cond", names[0]);
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("limit_cond", names[0], "double", a[0]);
  }
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("limit_cond", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LimitCond(); break;
  case 1:
    ret0 = c->LimitCond(std::move(arg1)); break;
  case 2:
    ret0 = c->LimitCond(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// limit_cond_double(maxCond:float=default, invert:bool=default) -> int
static PyObject* wrapLimitCondDouble_as_limit_cond_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("maxCond"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|OO:limit_cond_double", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!a[0]) return DefaultArgMissedError("limit_cond_double", names[0]);
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("limit_cond_double", names[0], "double", a[0]);
  }
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("limit_cond_double", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LimitCondDouble(); break;
  case 1:
    ret0 = c->LimitCondDouble(std::move(arg1)); break;
  case 2:
    ret0 = c->LimitCondDouble(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace() -> float
static PyObject* wrapTrace_as_trace(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Trace();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// tridiagonalize_(Q:DoubleMatrixBase)
static PyObject* wrapTridiagonalize_as_tridiagonalize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("Q"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tridiagonalize_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tridiagonalize_", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tridiagonalize(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// qr_(Q:DoubleMatrixBase)
static PyObject* wrapQr_as_qr_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("Q"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:qr_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("qr_", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::SpMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Qr(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::PackedMatrix<double>*
static PyObject* as_kaldi_PackedMatrix_double(PyObject* self) {
  ::kaldi::PackedMatrix<double>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::PackedMatrix<double>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapSpMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(r:int, resize_type:MatrixResizeType=default) -> DoubleSpMatrix\n\nCreates a new symmetric matrix of given size.\n\nArgs:\n  r (int): The number or rows.\n  resize_type (:class:`MatrixResizeType`): Determines how the elements\n    are initialized. If SET_ZERO (or COPY_DATA), they are set to zero.\n    If UNDEFINED, they are left uninitialized. Defaults to SET_ZERO.")},
  {C("from_other"), (PyCFunction)wrapSpMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(orig:DoubleSpMatrix) -> DoubleSpMatrix\n\nCreates a new symmetric matrix from the given symmetric matrix.\n\nArgs:\n    orig (DoubleSpMatrix): The input symmetric matrix.")},
  {C("from_matrix"), (PyCFunction)wrapSpMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(orig:DoubleMatrixBase, copy_type:SpCopyType=default) -> DoubleSpMatrix\n\nCreates a new symmetric matrix from the given square matrix.\n\nArgs:\n    orig (DoubleMatrixBase): The input square matrix.\n    copy_type (SpCopyType): Determines how elements will be copied.\n      If TAKE_LOWER, takes lower triangular elements in orig.\n      If TAKE_UPPER, takes upper triangular elements in orig.\n      If TAKE_MEAN, takes the average of symmetric elements in orig.\n      If TAKE_MEAN_AND_CHECK, does an extra symmetry check before\n      taking average of symmetric elements in orig.\n\nRaises:\n  RuntimeError: If orig is not a square matrix with matching size.")},
  {C("swap_with_symmetric_"), (PyCFunction)wrapSwap_as_swap_with_symmetric_, METH_VARARGS | METH_KEYWORDS, C("swap_with_symmetric_(other:DoubleSpMatrix)\n\nSwaps the contents with another symmetric matrix.\n\nShallow swap.\n\nArgs:\n  other (DoubleSpMatrix): The matrix to swap contents with.")},
  {C("copy_from_sp_"), (PyCFunction)wrapCopyFromSp_as_copy_from_sp_, METH_VARARGS | METH_KEYWORDS, C("copy_from_sp_(other:DoubleSpMatrix)\n\nCopies the elements from another symmetric matrix.\n\nArgs:\n  other(DoubleSpMatrix): The input symmetric matrix.\n\nRaises:\n  RuntimeError: In case of dimension mismatch.")},
  {C("copy_from_mat_"), (PyCFunction)wrapCopyFromMat_as_copy_from_mat_, METH_VARARGS | METH_KEYWORDS, C("copy_from_mat_(orig:DoubleMatrixBase, copy_type:SpCopyType=default)\n\nCopies the elements from a square matrix.\n\nArgs:\n    orig (DoubleMatrixBase): The input matrix.\n    copy_type (SpCopyType): Determines how elements will be copied.\n      If TAKE_LOWER, takes lower triangular elements in orig.\n      If TAKE_UPPER, takes upper triangular elements in orig.\n      If TAKE_MEAN, takes the average of symmetric elements in orig.\n      If TAKE_MEAN_AND_CHECK, does an extra symmetry check before\n      taking average of symmetric elements in orig.\n\nRaises:\n    RuntimeError: If orig is not symmetric.")},
  {C("getitem"), (PyCFunction)wrapgetitem, METH_VARARGS | METH_KEYWORDS, C("getitem(r:int, c:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  r (int): The row index of the element to get.\n  c (int): The column index of the element to get.\n\nReturns:\n  The element at the given index.\n\nRaises:\n  RuntimeError: If r > num_rows or c > num_cols.")},
  {C("invert_"), (PyCFunction)wrapInvert_as_invert_, METH_NOARGS, C("invert_()\n\nInverts the matrix.")},
  {C("invert_double_"), (PyCFunction)wrapInvertDouble_as_invert_double_, METH_NOARGS, C("invert_double_()\n\nInverts the matrix in double precision.")},
  {C("cond"), (PyCFunction)wrapCond_as_cond, METH_NOARGS, C("cond() -> float\n\nReturns the condition number of the SVD computation.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(exponent:float)\n\nApplies power to all elements of matrix.\n\nArgs:\n    expoenent (float): The exponent.")},
  {C("max_abs_eig"), (PyCFunction)wrapMaxAbsEig_as_max_abs_eig, METH_NOARGS, C("max_abs_eig() -> float\n\nReturns the maximum of the absolute values of the eigenvalues.")},
  {C("is_pos_def"), (PyCFunction)wrapIsPosDef_as_is_pos_def, METH_NOARGS, C("is_pos_def() -> bool\n\nReturns True if the matrix is positive definite.")},
  {C("add_sp_"), (PyCFunction)wrapAddSp_as_add_sp_, METH_VARARGS | METH_KEYWORDS, C("add_sp_(alpha:float, Ma:DoubleSpMatrix)\n\nPerforms the operation self = self+alpha*Ma.\n\nArgs:\n    alpha(float): A scaling constant\n    Ma(DoubleSpMatrix): A symmetrix Matrix")},
  {C("log_pos_def_det"), (PyCFunction)wrapLogPosDefDet_as_log_pos_def_det, METH_NOARGS, C("log_pos_def_det() -> float\n\nComputes the log determinant.\n\nReturns:\n    The log determinant\n\nRaises:\n    Error if matrix is not positive definite")},
  {C("add_vec2_"), (PyCFunction)wrapAddVec2_as_add_vec2_, METH_VARARGS | METH_KEYWORDS, C("add_vec2_(alpha:float, v:DoubleVectorBase)\n\nPerforms the operation self = self + alpha*(v*v^T)\n\nArgs:\n    alpha(float): A scaling constant\n    v(DoubleVectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, v:DoubleVectorBase, w:DoubleVectorBase)\n\nPerforms the operation self = self + alpha*(v*w^T+w*v^T)\n\nArgs:\n    alpha(float): A scaling constant\n    v(DoubleVectorBase): A vector\n    w(DoubleVectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_vec_2_sp_"), (PyCFunction)wrapAddVec2Sp_as_add_vec_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_vec_2_sp_(alpha:float, v:DoubleVectorBase, S:DoubleSpMatrix, beta:float)\n\nPerform self = beta*self + alpha*diag(v)*S*diag(v)\n\nArgs:\n    alpha(float): A scaling constant\n    v(DoubleVectorBase): A vector\n    S(DoubleSpMatrix): A symmetric matrix\n    beta(float): A scaling constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_diag_vec_"), (PyCFunction)wrapAddDiagVec_as_add_diag_vec_, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_(alpha:float, v:DoubleVectorBase)\n\nPerforms self = self+diag(v)\n\nArgs:\n    alpha(float): A scaling constant\n    v(DoubleVectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_mat2_"), (PyCFunction)wrapAddMat2_as_add_mat2_, METH_VARARGS | METH_KEYWORDS, C("add_mat2_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, beta:float)\n\nIf transM == kNoTrans performs self = beta*self+alpha*M*M^T.\n   If transM == kTrans self = beta*self+alpha*M^T*M\n\nArgs:\n    alpha(float): A constant\n    M(DoubleMatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_mat_2_sp_"), (PyCFunction)wrapAddMat2Sp_as_add_mat_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_mat_2_sp_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, A:DoubleSpMatrix, beta:float=default)\n\nIf transM == kNoTrans perform self = beta*self+alpha*M*A*M^T.\n   If transM == kTrans perform self = beta*self+alpha*M^T*A*M.\n\nArgs:\n    alpha(float): A constant\n    M(DoubleMatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    A(DoubleSpMatrix): A symmetric matrix\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("add_smat_2_sp_"), (PyCFunction)wrapAddSmat2Sp_as_add_smat_2_sp_, METH_VARARGS | METH_KEYWORDS, C("add_smat_2_sp_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, A:DoubleSpMatrix, beta:float=default)\n\nSame as AddMat2Sp, optimized for sparse M.")},
  {C("add_mat_2_vec_"), (PyCFunction)wrapAddMat2Vec_as_add_mat_2_vec_, METH_VARARGS | METH_KEYWORDS, C("add_mat_2_vec_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, v:DoubleVectorBase, beta:float=default)\n\nIf transM == kNoTrans perform self = beta*self+alpha*M*diag(v)*M^T.\n   If transM == kTrans perform self = beta*self+alpha*M^T*diag(v)*M.\n\nArgs:\n    alpha(float): A constant\n    M(DoubleMatrixBase): A matrix\n    transM(MatrixTransposeType): Determines if M will be transposed\n    v(DoubleVectorBase): A vector\n    beta(float): A constant\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("apply_floor_matrix_"), (PyCFunction)wrapApplyFloor_as_apply_floor_matrix_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_matrix_(floor:DoubleSpMatrix, alpha:float=default, verbose:bool=default) -> int\n\nFloors this symmetric matrix to the matrix alpha*floor,\n   where the matrix floor is positive definite.\n   It is floored in the sense that after flooring it must be that\n   x^T*self*x >= x^T*(alpha*floor)*x.\n   floor must be positive definite.\n\nArgs:\n    floor(DoubleSpMatrix): A positive definite matrix\n    alpha(float): a contant\n    verbose(bool): Default is False. If true, extra messages\n                   can be printed\n\nReturns:\n    the number of elements that were floored.\n\nRaises:\n    Error if floor is not positive definite.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float) -> int\n\nApplies floor to all elements. If self(i,j)<floor then self(i,j)=floor.\n\nArgs:\n    floor(float): The floor value to check against\n\nReturns:\n    The number of elements affected by the flooring operation")},
  {C("is_diagonal"), (PyCFunction)wrapIsDiagonal_as_is_diagonal, METH_VARARGS | METH_KEYWORDS, C("is_diagonal(cutoff:float=default) -> bool\n\nChecks if the matrix is diagonal. The nondiagonal elements\n   must be less or equal to cutoff value.\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if sum(digonal_elements)*cutoff > sum(nondiagonal_elements),\n    otherwise false")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(cutoff:float=default) -> bool\n\nChecks if the matrix is identity-like. It does not have to be square.\n   The nondiagonal elements must be less or equal to cutoff value,\n   while the diagonal ones must be one.\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if the diagonal elements are 1 and sum(nondiagonal_elements)<=cutoff")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if all elements are 0 (where 0 is the cutoff value).\n\nArgs:\n    cutoff(float): A cutoff value. Default is 1.0e-05\n\nReturns:\n    True if it is a zero matrix")},
  {C("is_triagonal"), (PyCFunction)wrapIsTridiagonal_as_is_triagonal, METH_VARARGS | METH_KEYWORDS, C("is_triagonal(cutoff:float=default) -> bool\n\nReturns true if the matrix is tridiagonal(based on the\ncutoff value).")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nReturns the Frobenius norm of the matrix.")},
  {C("approx_equal"), (PyCFunction)wrapApproxEqual_as_approx_equal, METH_VARARGS | METH_KEYWORDS, C("approx_equal(other:DoubleSpMatrix, tol:float=default) -> bool\n\nChecks if self is equal with other by calculating the Frobenius\n   norm of their difference.\n\nArgs:\n    other(DoubleSpMatrix): The matrix to check against\n    tol(float): the tolerance\n\nReturns:\n    True if ||(self-other)||_F <= tol * ||self||_F")},
  {C("limit_cond"), (PyCFunction)wrapLimitCond_as_limit_cond, METH_VARARGS | METH_KEYWORDS, C("limit_cond(maxCond:float=default, invert:bool=default) -> int\n\nPerforms self = P*diag(floor(s))*P^T, where s is the eigenvalues\n   and P is the eigenvectors.\n\nArgs:\n    MaxCond(float): Determines the flooring threshold (i.e. floor=max_eigen/MaxCond)\n\nRaises:\n    Error if matrix is not positive definite")},
  {C("limit_cond_double"), (PyCFunction)wrapLimitCondDouble_as_limit_cond_double, METH_VARARGS | METH_KEYWORDS, C("limit_cond_double(maxCond:float=default, invert:bool=default) -> int\n\nSame as LimitCond but the resulting operation has ``double'' precision.")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_NOARGS, C("trace() -> float\n\nReturns the trace of the matrix.")},
  {C("tridiagonalize_"), (PyCFunction)wrapTridiagonalize_as_tridiagonalize_, METH_VARARGS | METH_KEYWORDS, C("tridiagonalize_(Q:DoubleMatrixBase)\n\nTridiagonalize the matrix with an orthogonal transformation.\n   Performs  self = Q*self*Q^T for an orthogonal Q.\n\nArgs:\n    Q(DoubleMatrixBase): A matrix that must be orthogonal.")},
  {C("qr_"), (PyCFunction)wrapQr_as_qr_, METH_VARARGS | METH_KEYWORDS, C("qr_(Q:DoubleMatrixBase)\n\nThe symmetric QR algorithm. This is the symmetric QR algorithm,\n   from Golub and Van Loan 3rd ed., Algorithm 8.3.3.\n\nArgs:\n    Q(MatrixBase): A matrix")},
  {C("as_kaldi_PackedMatrix_double"), (PyCFunction)as_kaldi_PackedMatrix_double, METH_NOARGS, C("Upcast to ::kaldi::PackedMatrix<double>*")},
  {}
};

// DoubleSpMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleSpMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleSpMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sp_matrix.DoubleSpMatrix",         // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Double precision symmetric matrix.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleSpMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SpMatrix<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SpMatrix<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SpMatrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SpMatrix<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SpMatrix<double>* c = static_cast<::kaldi::SpMatrix<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SpMatrix<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleSpMatrix

// _trace_sp_sp(A:SpMatrix, B:SpMatrix) -> float
static PyObject* wrapTraceSpSp_as__trace_sp_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("A"),
      C("B"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_trace_sp_sp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_sp_sp", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_sp_sp", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceSpSp(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_sp_sp(A:DoubleSpMatrix, B:DoubleSpMatrix) -> float
static PyObject* wrapTraceSpSp_as__trace_double_sp_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("A"),
      C("B"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_trace_double_sp_sp", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_sp_sp", names[0], "::kaldi::SpMatrix<double>", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_sp_sp", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceSpSp(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal_sp_matrix(A:SpMatrix, B:SpMatrix, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal_sp_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_approx_equal_sp_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal_sp_matrix", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal_sp_matrix", names[1], "::kaldi::SpMatrix<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_approx_equal_sp_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _assert_equal_sp_matrix(A:SpMatrix, B:SpMatrix, tol:float=default)
static PyObject* wrapAssertEqual_as__assert_equal_sp_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_assert_equal_sp_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assert_equal_sp_matrix", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assert_equal_sp_matrix", names[1], "::kaldi::SpMatrix<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_assert_equal_sp_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _trace_sp_sp_lower(A:SpMatrix, B:SpMatrix) -> float
static PyObject* wrapTraceSpSpLower_as__trace_sp_sp_lower(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("A"),
      C("B"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_trace_sp_sp_lower", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_sp_sp_lower", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_sp_sp_lower", names[1], "::kaldi::SpMatrix<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceSpSpLower(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_sp_sp_lower(A:DoubleSpMatrix, B:DoubleSpMatrix) -> float
static PyObject* wrapTraceSpSpLower_as__trace_double_sp_sp_lower(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("A"),
      C("B"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_trace_double_sp_sp_lower", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SpMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_sp_sp_lower", names[0], "::kaldi::SpMatrix<double>", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_sp_sp_lower", names[1], "::kaldi::SpMatrix<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceSpSpLower(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_sp_mat(A:SpMatrix, B:MatrixBase) -> float
static PyObject* wrapTraceSpMat_as__trace_sp_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("A"),
      C("B"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_trace_sp_mat", names, &a[0], &a[1])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_sp_mat", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_sp_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceSpMat(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_mat_sp_mat(A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, C:MatrixBase, transC:MatrixTransposeType) -> float
static PyObject* wrapTraceMatSpMat_as__trace_mat_sp_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("C"),
      C("transC"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_trace_mat_sp_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_sp_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_sp_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_sp_mat", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_mat_sp_mat", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_mat_sp_mat", names[4], "::kaldi::MatrixTransposeType", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatSpMat(*arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_mat_sp_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, C:DoubleMatrixBase, transC:MatrixTransposeType) -> float
static PyObject* wrapTraceMatSpMat_as__trace_double_mat_sp_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("C"),
      C("transC"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_trace_double_mat_sp_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_sp_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_sp_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_sp_mat", names[2], "::kaldi::SpMatrix<double>", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_double_mat_sp_mat", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_double_mat_sp_mat", names[4], "::kaldi::MatrixTransposeType", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatSpMat(*arg1, std::move(arg2), *arg3, *arg4, std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_mat_sp_mat_sp(A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, C:MatrixBase, transC:MatrixTransposeType, D:SpMatrix) -> float
static PyObject* wrapTraceMatSpMatSp_as__trace_mat_sp_mat_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("C"),
      C("transC"),
      C("D"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_trace_mat_sp_mat_sp", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_sp_mat_sp", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_sp_mat_sp", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_sp_mat_sp", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_mat_sp_mat_sp", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_mat_sp_mat_sp", names[4], "::kaldi::MatrixTransposeType", a[4]);
  ::kaldi::SpMatrix<float>* arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_mat_sp_mat_sp", names[5], "::kaldi::SpMatrix<float>", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatSpMatSp(*arg1, std::move(arg2), *arg3, *arg4, std::move(arg5), *arg6);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_mat_sp_mat_sp(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, C:DoubleMatrixBase, transC:MatrixTransposeType, D:DoubleSpMatrix) -> float
static PyObject* wrapTraceMatSpMatSp_as__trace_double_mat_sp_mat_sp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("C"),
      C("transC"),
      C("D"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_trace_double_mat_sp_mat_sp", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_sp_mat_sp", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_sp_mat_sp", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::SpMatrix<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_sp_mat_sp", names[2], "::kaldi::SpMatrix<double>", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_double_mat_sp_mat_sp", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_double_mat_sp_mat_sp", names[4], "::kaldi::MatrixTransposeType", a[4]);
  ::kaldi::SpMatrix<double>* arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_double_mat_sp_mat_sp", names[5], "::kaldi::SpMatrix<double>", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatSpMatSp(*arg1, std::move(arg2), *arg3, *arg4, std::move(arg5), *arg6);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _vec_sp_vec(v1:VectorBase, M:SpMatrix, v2:VectorBase) -> float
static PyObject* wrapVecSpVec_as__vec_sp_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("v1"),
      C("M"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_vec_sp_vec", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_sp_vec", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_sp_vec", names[1], "::kaldi::SpMatrix<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_vec_sp_vec", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecSpVec(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _vec_sp_vec_double(v1:DoubleVectorBase, M:DoubleSpMatrix, v2:DoubleVectorBase) -> float
static PyObject* wrapVecSpVec_as__vec_sp_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("v1"),
      C("M"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_vec_sp_vec_double", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_sp_vec_double", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::SpMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_sp_vec_double", names[1], "::kaldi::SpMatrix<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_vec_sp_vec_double", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecSpVec(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pySolverOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SolverOptions> cpp;
};
static ::kaldi::SolverOptions* ThisPtr(PyObject*);

static PyObject* get_K(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->K, {});
}

static int set_K(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the K attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->K)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for K:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_eps(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->eps, {});
}

static int set_eps(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the eps attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->eps)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for eps:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_name(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->name, _1);
}

static int set_name(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the name attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->name)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for name:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_optimize_delta(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->optimize_delta, {});
}

static int set_optimize_delta(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the optimize_delta attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->optimize_delta)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for optimize_delta:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_diagonal_precondition(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->diagonal_precondition, {});
}

static int set_diagonal_precondition(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the diagonal_precondition attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->diagonal_precondition)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for diagonal_precondition:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_print_debug_output(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->print_debug_output, {});
}

static int set_print_debug_output(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the print_debug_output attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->print_debug_output)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for print_debug_output:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod solver_options_with_name(name:str) -> SolverOptions
static PyObject* wrapSolverOptions_as_solver_options_with_name(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("name"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:solver_options_with_name", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("solver_options_with_name", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::SolverOptions> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::SolverOptions>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// check()
static PyObject* wrapCheck_as_check(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SolverOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Check();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("K"), get_K, set_K, C("C++ ::kaldi::BaseFloat SolverOptions.K")},
  {C("eps"), get_eps, set_eps, C("C++ ::kaldi::BaseFloat SolverOptions.eps")},
  {C("name"), get_name, set_name, C("C++ ::std::string SolverOptions.name")},
  {C("optimize_delta"), get_optimize_delta, set_optimize_delta, C("C++ bool SolverOptions.optimize_delta")},
  {C("diagonal_precondition"), get_diagonal_precondition, set_diagonal_precondition, C("C++ bool SolverOptions.diagonal_precondition")},
  {C("print_debug_output"), get_print_debug_output, set_print_debug_output, C("C++ bool SolverOptions.print_debug_output")},
  {}
};

static PyMethodDef Methods[] = {
  {C("solver_options_with_name"), (PyCFunction)wrapSolverOptions_as_solver_options_with_name, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("solver_options_with_name(name:str) -> SolverOptions\n\nInitialize the class. Default values are:\n K = 1.0e+4,\n eps = 1.0e-40\n optimize_delta = true\n diagonal_precondition = false\nprint_debug_output = true")},
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_NOARGS, C("check()\n\nRaises error if K<10 or eps>1.0e-10")},
  {}
};

// SolverOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SolverOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SolverOptions __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sp_matrix.SolverOptions",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "This class describes the options for maximizing various quadratic objective functions.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SolverOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SolverOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SolverOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SolverOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SolverOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::SolverOptions* c = static_cast<::kaldi::SolverOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SolverOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySolverOptions

// solve_quadratic_problem(H:SpMatrix, g:VectorBase, opts:SolverOptions, x:VectorBase) -> float
static PyObject* wrapSolveQuadraticProblem_as_solve_quadratic_problem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("H"),
      C("g"),
      C("opts"),
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:solve_quadratic_problem", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("solve_quadratic_problem", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("solve_quadratic_problem", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::SolverOptions* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("solve_quadratic_problem", names[2], "::kaldi::SolverOptions", a[2]);
  ::kaldi::VectorBase<float> * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("solve_quadratic_problem", names[3], "::kaldi::VectorBase<float> *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SolveQuadraticProblem(*arg1, *arg2, *arg3, arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// solve_quadratic_matrix_problem(Q:SpMatrix, Y:MatrixBase, P:SpMatrix, opts:SolverOptions, M:MatrixBase) -> float
static PyObject* wrapSolveQuadraticMatrixProblem_as_solve_quadratic_matrix_problem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("Q"),
      C("Y"),
      C("P"),
      C("opts"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:solve_quadratic_matrix_problem", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::SpMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("solve_quadratic_matrix_problem", names[0], "::kaldi::SpMatrix<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("solve_quadratic_matrix_problem", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("solve_quadratic_matrix_problem", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::SolverOptions* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("solve_quadratic_matrix_problem", names[3], "::kaldi::SolverOptions", a[3]);
  ::kaldi::MatrixBase<float> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("solve_quadratic_matrix_problem", names[4], "::kaldi::MatrixBase<float> *", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SolveQuadraticMatrixProblem(*arg1, *arg2, *arg3, *arg4, arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// solve_double_quadratic_matrix_problem(G:MatrixBase, P1:SpMatrix, P2:SpMatrix, Q1:SpMatrix, Q2:SpMatrix, opts:SolverOptions, M:MatrixBase) -> float
static PyObject* wrapSolveDoubleQuadraticMatrixProblem_as_solve_double_quadratic_matrix_problem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("G"),
      C("P1"),
      C("P2"),
      C("Q1"),
      C("Q2"),
      C("opts"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:solve_double_quadratic_matrix_problem", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("solve_double_quadratic_matrix_problem", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("solve_double_quadratic_matrix_problem", names[1], "::kaldi::SpMatrix<float>", a[1]);
  ::kaldi::SpMatrix<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("solve_double_quadratic_matrix_problem", names[2], "::kaldi::SpMatrix<float>", a[2]);
  ::kaldi::SpMatrix<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("solve_double_quadratic_matrix_problem", names[3], "::kaldi::SpMatrix<float>", a[3]);
  ::kaldi::SpMatrix<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("solve_double_quadratic_matrix_problem", names[4], "::kaldi::SpMatrix<float>", a[4]);
  ::kaldi::SolverOptions* arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("solve_double_quadratic_matrix_problem", names[5], "::kaldi::SolverOptions", a[5]);
  ::kaldi::MatrixBase<float> * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("solve_double_quadratic_matrix_problem", names[6], "::kaldi::MatrixBase<float> *", a[6]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SolveDoubleQuadraticMatrixProblem(*arg1, *arg2, *arg3, *arg4, *arg5, *arg6, arg7);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_trace_sp_sp"), (PyCFunction)wrapTraceSpSp_as__trace_sp_sp, METH_VARARGS | METH_KEYWORDS, C("_trace_sp_sp(A:SpMatrix, B:SpMatrix) -> float\n\nCalculates the trace of A*B\n\nArgs:\n    A(SpMatrix): A matrix\n    B(SpMatrix): A matrix\n\nReturns:\n    The trace of A*B\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_trace_double_sp_sp"), (PyCFunction)wrapTraceSpSp_as__trace_double_sp_sp, METH_VARARGS | METH_KEYWORDS, C("_trace_double_sp_sp(A:DoubleSpMatrix, B:DoubleSpMatrix) -> float\n\nSame as TraceSpSp, when you have built Kaldi with double precision.")},
  {C("_approx_equal_sp_matrix"), (PyCFunction)wrapApproxEqual_as__approx_equal_sp_matrix, METH_VARARGS | METH_KEYWORDS, C("_approx_equal_sp_matrix(A:SpMatrix, B:SpMatrix, tol:float=default) -> bool\n\nComputes the Frobenius norm of the difference of matrix A and B\n   and returns True if it is less or equal than tol.\n\nArgs:\n    A(MatrixBase): A matrix\n    B(MatrixBase): A matrix\n    tol(float): The tolerance.\n\nReturns:\n    True ||A-B||_F <= tol\n\nRaises:\n    Error if size of a is different than size of b.")},
  {C("_assert_equal_sp_matrix"), (PyCFunction)wrapAssertEqual_as__assert_equal_sp_matrix, METH_VARARGS | METH_KEYWORDS, C("_assert_equal_sp_matrix(A:SpMatrix, B:SpMatrix, tol:float=default)\n\nComputes the Frobenius norm of the difference of matrix A and B\n   and checks if it is less or equal than tol. If the condition is\n   not satisfied it will raise an error.\n\nArgs:\n    A(MatrixBase): A matrix\n    B(MatrixBase): A matrix\n    tol(float): The tolerance.\n\nRaises:\n    Error if ||A-B||_F > tol")},
  {C("_trace_sp_sp_lower"), (PyCFunction)wrapTraceSpSpLower_as__trace_sp_sp_lower, METH_VARARGS | METH_KEYWORDS, C("_trace_sp_sp_lower(A:SpMatrix, B:SpMatrix) -> float\n\nComputes the trace of (A*B)")},
  {C("_trace_double_sp_sp_lower"), (PyCFunction)wrapTraceSpSpLower_as__trace_double_sp_sp_lower, METH_VARARGS | METH_KEYWORDS, C("_trace_double_sp_sp_lower(A:DoubleSpMatrix, B:DoubleSpMatrix) -> float\n\nComputes the trace of (A*B)")},
  {C("_trace_sp_mat"), (PyCFunction)wrapTraceSpMat_as__trace_sp_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_sp_mat(A:SpMatrix, B:MatrixBase) -> float\n\nReturns Trace(A*B)\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_trace_mat_sp_mat"), (PyCFunction)wrapTraceMatSpMat_as__trace_mat_sp_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_sp_mat(A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, C:MatrixBase, transC:MatrixTransposeType) -> float\n\nReturns tr(A*B*C)\n\nArgs:\n    A(MatrixBase): A matrix\n    transA(MatrixTransposeType): if kNoTrans(default) treat A as is,\n                                 if kTrans transpose A before operation\n    B(SpMatrix): A symmetric matrix\n    C(MatrixBase): A matrix\n    transC(MatrixTransposeType): if kNoTrans(default) treat C as is,\n                                 if kTrans transpose C before operation\n\nReturns:\n    The trace of A*B or A*B^T depending on the value of trans\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_trace_double_mat_sp_mat"), (PyCFunction)wrapTraceMatSpMat_as__trace_double_mat_sp_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_sp_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, C:DoubleMatrixBase, transC:MatrixTransposeType) -> float\n\nReturns tr(A*B*C)\n\nArgs:\n    A(MatrixBase): A matrix\n    transA(MatrixTransposeType): if kNoTrans(default) treat A as is,\n                                 if kTrans transpose A before operation\n    B(SpMatrix): A symmetric matrix\n    C(MatrixBase): A matrix\n    transC(MatrixTransposeType): if kNoTrans(default) treat C as is,\n                                 if kTrans transpose C before operation\n\nReturns:\n    The trace of A*B or A*B^T depending on the value of trans\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_trace_mat_sp_mat_sp"), (PyCFunction)wrapTraceMatSpMatSp_as__trace_mat_sp_mat_sp, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_sp_mat_sp(A:MatrixBase, transA:MatrixTransposeType, B:SpMatrix, C:MatrixBase, transC:MatrixTransposeType, D:SpMatrix) -> float\n\nReturns tr(A*B*C*D)\n\nArgs:\n    A(MatrixBase): A matrix\n    transA(MatrixTransposeType): if kNoTrans(default) treat A as is,\n                                 if kTrans transpose A before operation\n    B(SpMatrix): A symmetric matrix\n    C(MatrixBase): A matrix\n    transC(MatrixTransposeType): if kNoTrans(default) treat C as is,\n                                 if kTrans transpose C before operation\n    D(SpMatrix): A symmetric matrix\n\nReturns:\n    The trace of A*B or A*B^T depending on the value of trans\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_trace_double_mat_sp_mat_sp"), (PyCFunction)wrapTraceMatSpMatSp_as__trace_double_mat_sp_mat_sp, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_sp_mat_sp(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleSpMatrix, C:DoubleMatrixBase, transC:MatrixTransposeType, D:DoubleSpMatrix) -> float\n\nReturns tr(A*B*C*D)\n\nArgs:\n    A(MatrixBase): A matrix\n    transA(MatrixTransposeType): if kNoTrans(default) treat A as is,\n                                 if kTrans transpose A before operation\n    B(SpMatrix): A symmetric matrix\n    C(MatrixBase): A matrix\n    transC(MatrixTransposeType): if kNoTrans(default) treat C as is,\n                                 if kTrans transpose C before operation\n    D(SpMatrix): A symmetric matrix\n\nReturns:\n    The trace of A*B or A*B^T depending on the value of trans\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_vec_sp_vec"), (PyCFunction)wrapVecSpVec_as__vec_sp_vec, METH_VARARGS | METH_KEYWORDS, C("_vec_sp_vec(v1:VectorBase, M:SpMatrix, v2:VectorBase) -> float\n\nPerforms v1^T*M*v2.\n\nArgs:\n    v1(VectorBase): A vector\n    M(SpMatrix): A symmetric matrix\n    v2(VectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("_vec_sp_vec_double"), (PyCFunction)wrapVecSpVec_as__vec_sp_vec_double, METH_VARARGS | METH_KEYWORDS, C("_vec_sp_vec_double(v1:DoubleVectorBase, M:DoubleSpMatrix, v2:DoubleVectorBase) -> float\n\nPerforms v1^T*M*v2.\n\nArgs:\n    v1(VectorBase): A vector\n    M(SpMatrix): A symmetric matrix\n    v2(VectorBase): A vector\n\nRaises:\n    Error in case of dimension mismatch")},
  {C("solve_quadratic_problem"), (PyCFunction)wrapSolveQuadraticProblem_as_solve_quadratic_problem, METH_VARARGS | METH_KEYWORDS, C("solve_quadratic_problem(H:SpMatrix, g:VectorBase, opts:SolverOptions, x:VectorBase) -> float\n\nMaximizes the auxiliary function\n   Q(x) = x.*g - 0.5 x^T*H*x using a numerically stable method.\n   Assumes H positive semidefinite.\n\nArgs:\n    H(SpMatrix): A positive semidefinite number\n    g(VectorBase): A vector\n    opts(SolverOptions): Options for the solver\n    x(VectorBase): A vector\n\nReturns:\n   The objective-function change\n\nRaises:\n   Error in case of dimension mismatch")},
  {C("solve_quadratic_matrix_problem"), (PyCFunction)wrapSolveQuadraticMatrixProblem_as_solve_quadratic_matrix_problem, METH_VARARGS | METH_KEYWORDS, C("solve_quadratic_matrix_problem(Q:SpMatrix, Y:MatrixBase, P:SpMatrix, opts:SolverOptions, M:MatrixBase) -> float\n\nMaximizes the auxiliary function\n   Q(x) = tr(M^T*P*Y)-0.5*tr(P*M*Q*M^T)\n   Assumes Q and P positive semidefinite.\n\nArgs:\n    Q(SpMatrix): A positive semidefinite matrix\n    Y(MatrixBase): A matrix\n    P(SpMatrix): A positive semidefinite matrix\n    opts(SolverOptions): Options for the solver\n    M(MatrixBase): A matrix\n\nReturns:\n   The objective-function change\n\nRaises:\n   Error in case of dimension mismatch")},
  {C("solve_double_quadratic_matrix_problem"), (PyCFunction)wrapSolveDoubleQuadraticMatrixProblem_as_solve_double_quadratic_matrix_problem, METH_VARARGS | METH_KEYWORDS, C("solve_double_quadratic_matrix_problem(G:MatrixBase, P1:SpMatrix, P2:SpMatrix, Q1:SpMatrix, Q2:SpMatrix, opts:SolverOptions, M:MatrixBase) -> float\n\nMaximizes the auxiliary function\n   Q(M) = tr(M^T*G)-0.5*tr(P1*M*Q1 M^T)-0.5*tr(P2*M*Q2*M^T)\n   Assumes Q1, Q2, P1, and P2 are positive semidefinite.\n\nArgs:\n    Q(SpMatrix): A positive semidefinite matrix\n    Y(MatrixBase): A matrix\n    P(SpMatrix): A positive semidefinite matrix\n    opts(SolverOptions): Options for the solver\n    M(MatrixBase): A matrix\n\nReturns:\n   The objective-function change\n\nRaises:\n   Error in case of dimension mismatch")},
  {}
};

bool Ready() {
  PyObject* base_cls = ImportFQName("kaldi.matrix._packed_matrix.PackedMatrix");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.matrix._packed_matrix.PackedMatrix is not a new style class inheriting from object.");
    return false;
  }
  pySpMatrix::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pySpMatrix::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.matrix._packed_matrix.PackedMatrix is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pySpMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pySpMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.matrix._packed_matrix.DoublePackedMatrix");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.matrix._packed_matrix.DoublePackedMatrix is not a new style class inheriting from object.");
    return false;
  }
  pyDoubleSpMatrix::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyDoubleSpMatrix::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.matrix._packed_matrix.DoublePackedMatrix is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyDoubleSpMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleSpMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySolverOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pySolverOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_sp_matrix",  // module name
  "CLIF-generated module for matrix/sp-matrix.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_ext")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "SpMatrix", reinterpret_cast<PyObject*>(&pySpMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleSpMatrix", reinterpret_cast<PyObject*>(&pyDoubleSpMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SolverOptions", reinterpret_cast<PyObject*>(&pySolverOptions::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __sp__matrix_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// DoubleSpMatrix to/from ::kaldi::SpMatrix<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SpMatrix<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SpMatrix<double>* cpp = __sp__matrix_clifwrap::pyDoubleSpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SpMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<double>* cpp = __sp__matrix_clifwrap::pyDoubleSpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SpMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<double>* cpp = __sp__matrix_clifwrap::pyDoubleSpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleSpMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SpMatrix<double>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<double>* cpp = __sp__matrix_clifwrap::pyDoubleSpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SpMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<double>* cpp = __sp__matrix_clifwrap::pyDoubleSpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SpMatrix<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SpMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SpMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SpMatrix<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pyDoubleSpMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SpMatrix<double>>(c);
  return py;
}

// SolverOptions to/from ::kaldi::SolverOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SolverOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SolverOptions* cpp = __sp__matrix_clifwrap::pySolverOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SolverOptions>* c) {
  assert(c != nullptr);
  ::kaldi::SolverOptions* cpp = __sp__matrix_clifwrap::pySolverOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SolverOptions>* c) {
  assert(c != nullptr);
  ::kaldi::SolverOptions* cpp = __sp__matrix_clifwrap::pySolverOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SolverOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SolverOptions* c) {
  assert(c != nullptr);
  ::kaldi::SolverOptions* cpp = __sp__matrix_clifwrap::pySolverOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SolverOptions>* c) {
  assert(c != nullptr);
  ::kaldi::SolverOptions* cpp = __sp__matrix_clifwrap::pySolverOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SolverOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySolverOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SolverOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SolverOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySolverOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SolverOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SolverOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySolverOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SolverOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SolverOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySolverOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySolverOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SolverOptions>(c);
  return py;
}

// SpMatrix to/from ::kaldi::SpMatrix<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SpMatrix<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SpMatrix<float>* cpp = __sp__matrix_clifwrap::pySpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SpMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<float>* cpp = __sp__matrix_clifwrap::pySpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SpMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<float>* cpp = __sp__matrix_clifwrap::pySpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SpMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::SpMatrix<float>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<float>* cpp = __sp__matrix_clifwrap::pySpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::SpMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::SpMatrix<float>* cpp = __sp__matrix_clifwrap::pySpMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SpMatrix<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SpMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SpMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SpMatrix<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SpMatrix<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sp__matrix_clifwrap::pySpMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sp__matrix_clifwrap::pySpMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::SpMatrix<float>>(c);
  return py;
}

}  // namespace kaldi
