//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/lat/confidence.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "confidence-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __confidence_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _sentence_level_confidence_from_compact_lattice(clat:CompactLatticeVectorFst) -> (confidence:float, num_paths:int, best_sentence:list<int>, second_best_sentence:list<int>)
static PyObject* wrapSentenceLevelConfidence_as__sentence_level_confidence_from_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_sentence_level_confidence_from_compact_lattice", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_sentence_level_confidence_from_compact_lattice", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  int ret1{};
  ::std::vector< ::int32> ret2{};
  ::std::vector< ::int32> ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SentenceLevelConfidence(*arg1, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  return result_tuple;
}

// _sentence_level_confidence_from_lattice(clat:LatticeVectorFst) -> (confidence:float, num_paths:int, best_sentence:list<int>, second_best_sentence:list<int>)
static PyObject* wrapSentenceLevelConfidence_as__sentence_level_confidence_from_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_sentence_level_confidence_from_lattice", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_sentence_level_confidence_from_lattice", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  int ret1{};
  ::std::vector< ::int32> ret2{};
  ::std::vector< ::int32> ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SentenceLevelConfidence(*arg1, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_sentence_level_confidence_from_compact_lattice"), (PyCFunction)wrapSentenceLevelConfidence_as__sentence_level_confidence_from_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("_sentence_level_confidence_from_compact_lattice(clat:CompactLatticeVectorFst) -> (confidence:float, num_paths:int, best_sentence:list<int>, second_best_sentence:list<int>)\n  Calls C++ function\n  float ::kaldi::SentenceLevelConfidence(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >, int*, ::std::vector< ::int32>*, ::std::vector< ::int32>*)")},
  {C("_sentence_level_confidence_from_lattice"), (PyCFunction)wrapSentenceLevelConfidence_as__sentence_level_confidence_from_lattice, METH_VARARGS | METH_KEYWORDS, C("_sentence_level_confidence_from_lattice(clat:LatticeVectorFst) -> (confidence:float, num_paths:int, best_sentence:list<int>, second_best_sentence:list<int>)\n  Calls C++ function\n  float ::kaldi::SentenceLevelConfidence(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >, int*, ::std::vector< ::int32>*, ::std::vector< ::int32>*)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_confidence",  // module name
  "CLIF-generated module for lat/confidence.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __confidence_clifwrap
