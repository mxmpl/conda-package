//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/lat/lattice-functions.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "itf/options-itf-clifwrap.h"
#include "itf/decodable-itf-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "fstext/deterministic-fst-clifwrap.h"
#include "hmm/transition-model-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "lattice-functions-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __lattice__functions_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// get_per_frame_acoustic_costs(linear_lattice:LatticeVectorFst) -> Vector
static PyObject* wrapGetPerFrameAcousticCosts_as_get_per_frame_acoustic_costs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("linear_lattice"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_per_frame_acoustic_costs", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_per_frame_acoustic_costs", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  ::kaldi::Vector<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::GetPerFrameAcousticCosts(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _lattice_state_times(lat:LatticeVectorFst) -> (num_frames:int, times:list<int>)
static PyObject* wrapLatticeStateTimes_as__lattice_state_times(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_lattice_state_times", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_lattice_state_times", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  ::std::vector< ::int32> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LatticeStateTimes(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// _compact_lattice_state_times(clat:CompactLatticeVectorFst) -> (num_frames:int, times:list<int>)
static PyObject* wrapCompactLatticeStateTimes_as__compact_lattice_state_times(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_compact_lattice_state_times", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compact_lattice_state_times", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::std::vector< ::int32> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::CompactLatticeStateTimes(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// lattice_forward_backward(lat:LatticeVectorFst) -> (total_prob:float, arc_post:list<list<tuple<int, float>>>, acoustic_like_sum:float)
static PyObject* wrapLatticeForwardBackward_as_lattice_forward_backward(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:lattice_forward_backward", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lattice_forward_backward", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  ::kaldi::Posterior ret1{};
  double ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LatticeForwardBackward(*arg1, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

// compute_compact_lattice_alphas(clat:CompactLatticeVectorFst) -> (success:bool, alpha:list<float>)
static PyObject* wrapComputeCompactLatticeAlphas_as_compute_compact_lattice_alphas(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compute_compact_lattice_alphas", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_compact_lattice_alphas", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::std::vector<double> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ComputeCompactLatticeAlphas(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// compute_compact_lattice_betas(clat:CompactLatticeVectorFst) -> (success:bool, beta:list<float>)
static PyObject* wrapComputeCompactLatticeBetas_as_compute_compact_lattice_betas(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compute_compact_lattice_betas", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_compact_lattice_betas", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::std::vector<double> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ComputeCompactLatticeBetas(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _compute_lattice_alphas_and_betas(lat:LatticeVectorFst, viterbi:bool) -> (total_prob:float, alpha:list<float>, beta:list<float>)
static PyObject* wrapComputeLatticeAlphasAndBetas_as__compute_lattice_alphas_and_betas(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("lat"),
      C("viterbi"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_compute_lattice_alphas_and_betas", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compute_lattice_alphas_and_betas", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compute_lattice_alphas_and_betas", names[1], "bool", a[1]);
  ::std::vector<double> ret1{};
  ::std::vector<double> ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ComputeLatticeAlphasAndBetas(*arg1, std::move(arg2), &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

// _compute_compact_lattice_alphas_and_betas(clat:CompactLatticeVectorFst, viterbi:bool) -> (total_prob:float, alpha:list<float>, beta:list<float>)
static PyObject* wrapComputeLatticeAlphasAndBetas_as__compute_compact_lattice_alphas_and_betas(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("clat"),
      C("viterbi"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_compute_compact_lattice_alphas_and_betas", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compute_compact_lattice_alphas_and_betas", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compute_compact_lattice_alphas_and_betas", names[1], "bool", a[1]);
  ::std::vector<double> ret1{};
  ::std::vector<double> ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ComputeLatticeAlphasAndBetas(*arg1, std::move(arg2), &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

// _top_sort_lattice_if_needed(lat:LatticeVectorFst)
static PyObject* wrapTopSortLatticeIfNeeded_as__top_sort_lattice_if_needed(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_top_sort_lattice_if_needed", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_top_sort_lattice_if_needed", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::TopSortLatticeIfNeeded(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _top_sort_compact_lattice_if_needed(clat:CompactLatticeVectorFst)
static PyObject* wrapTopSortCompactLatticeIfNeeded_as__top_sort_compact_lattice_if_needed(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_top_sort_compact_lattice_if_needed", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_top_sort_compact_lattice_if_needed", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::TopSortCompactLatticeIfNeeded(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compact_lattice_depth(clat:CompactLatticeVectorFst) -> (depth:float, num_frames:int)
static PyObject* wrapCompactLatticeDepth_as_compact_lattice_depth(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compact_lattice_depth", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_depth", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  int ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::CompactLatticeDepth(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// compact_lattice_depth_per_frame(clat:CompactLatticeVectorFst) -> list<int>
static PyObject* wrapCompactLatticeDepthPerFrame_as_compact_lattice_depth_per_frame(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compact_lattice_depth_per_frame", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_depth_per_frame", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CompactLatticeDepthPerFrame(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compact_lattice_limit_depth(max_arcs_per_frame:int, clat:CompactLatticeVectorFst)
static PyObject* wrapCompactLatticeLimitDepth_as_compact_lattice_limit_depth(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("max_arcs_per_frame"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:compact_lattice_limit_depth", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_limit_depth", names[0], "int", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compact_lattice_limit_depth", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CompactLatticeLimitDepth(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// lattice_active_phones(lat:LatticeVectorFst, trans:TransitionModel, sil_phones:list<int>) -> list<set<int>>
static PyObject* wrapLatticeActivePhones_as_lattice_active_phones(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("lat"),
      C("trans"),
      C("sil_phones"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:lattice_active_phones", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lattice_active_phones", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  ::kaldi::TransitionModel* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("lattice_active_phones", names[1], "::kaldi::TransitionModel", a[1]);
  ::std::vector< ::int32> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("lattice_active_phones", names[2], "::std::vector< ::int32>", a[2]);
  ::std::vector< ::std::set< ::int32> > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::LatticeActivePhones(*arg1, *arg2, std::move(arg3), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// convert_lattice_to_phones(trans_model:TransitionModel, lat:LatticeVectorFst)
static PyObject* wrapConvertLatticeToPhones_as_convert_lattice_to_phones(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("trans_model"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:convert_lattice_to_phones", names, &a[0], &a[1])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_lattice_to_phones", names[0], "::kaldi::TransitionModel", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("convert_lattice_to_phones", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ConvertLatticeToPhones(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// convert_compact_lattice_to_phones(trans_model:TransitionModel, lat:CompactLatticeVectorFst)
static PyObject* wrapConvertCompactLatticeToPhones_as_convert_compact_lattice_to_phones(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("trans_model"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:convert_compact_lattice_to_phones", names, &a[0], &a[1])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_compact_lattice_to_phones", names[0], "::kaldi::TransitionModel", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("convert_compact_lattice_to_phones", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ConvertCompactLatticeToPhones(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _prune_lattice(beam:float, lat:LatticeVectorFst) -> bool
static PyObject* wrapPruneLattice_as__prune_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("beam"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_prune_lattice", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_prune_lattice", names[0], "float", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_prune_lattice", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::PruneLattice(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _prune_compact_lattice(beam:float, lat:CompactLatticeVectorFst) -> bool
static PyObject* wrapPruneLattice_as__prune_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("beam"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_prune_compact_lattice", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_prune_compact_lattice", names[0], "float", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_prune_compact_lattice", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::PruneLattice(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// lattice_boost(trans:TransitionModel, alignment:list<int>, silence_phones:list<int>, b:float, max_silence_error:float, lat:LatticeVectorFst) -> bool
static PyObject* wrapLatticeBoost_as_lattice_boost(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("trans"),
      C("alignment"),
      C("silence_phones"),
      C("b"),
      C("max_silence_error"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:lattice_boost", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lattice_boost", names[0], "::kaldi::TransitionModel", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("lattice_boost", names[1], "::std::vector< ::int32>", a[1]);
  ::std::vector< ::int32> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("lattice_boost", names[2], "::std::vector< ::int32>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("lattice_boost", names[3], "float", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("lattice_boost", names[4], "float", a[4]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("lattice_boost", names[5], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LatticeBoost(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), arg6);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// lattice_forward_backward_mpe_variants(trans:TransitionModel, silence_phones:list<int>, lat:LatticeVectorFst, num_ali:list<int>, criterion:str, one_silence_class:bool) -> (objf_val:float, post:list<list<tuple<int, float>>>)
static PyObject* wrapLatticeForwardBackwardMpeVariants_as_lattice_forward_backward_mpe_variants(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("trans"),
      C("silence_phones"),
      C("lat"),
      C("num_ali"),
      C("criterion"),
      C("one_silence_class"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:lattice_forward_backward_mpe_variants", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lattice_forward_backward_mpe_variants", names[0], "::kaldi::TransitionModel", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("lattice_forward_backward_mpe_variants", names[1], "::std::vector< ::int32>", a[1]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("lattice_forward_backward_mpe_variants", names[2], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[2]);
  ::std::vector< ::int32> arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("lattice_forward_backward_mpe_variants", names[3], "::std::vector< ::int32>", a[3]);
  ::std::string arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("lattice_forward_backward_mpe_variants", names[4], "::std::string", a[4]);
  bool arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("lattice_forward_backward_mpe_variants", names[5], "bool", a[5]);
  ::kaldi::Posterior ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LatticeForwardBackwardMpeVariants(*arg1, std::move(arg2), *arg3, std::move(arg4), std::move(arg5), std::move(arg6), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// lattice_forward_backward_mmi(trans:TransitionModel, lat:LatticeVectorFst, num_ali:list<int>, drop_frames:bool, convert_to_pdf_ids:bool, cancel:bool) -> (objf_val:float, post:list<list<tuple<int, float>>>)
static PyObject* wrapLatticeForwardBackwardMmi_as_lattice_forward_backward_mmi(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("trans"),
      C("lat"),
      C("num_ali"),
      C("drop_frames"),
      C("convert_to_pdf_ids"),
      C("cancel"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:lattice_forward_backward_mmi", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("lattice_forward_backward_mmi", names[0], "::kaldi::TransitionModel", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("lattice_forward_backward_mmi", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[1]);
  ::std::vector< ::int32> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("lattice_forward_backward_mmi", names[2], "::std::vector< ::int32>", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("lattice_forward_backward_mmi", names[3], "bool", a[3]);
  bool arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("lattice_forward_backward_mmi", names[4], "bool", a[4]);
  bool arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("lattice_forward_backward_mmi", names[5], "bool", a[5]);
  ::kaldi::Posterior ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LatticeForwardBackwardMmi(*arg1, *arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// compact_lattice_to_word_alignment(clat:CompactLatticeVectorFst) -> (success:bool, words:list<int>, begin_times:list<int>, lengths:list<int>)
static PyObject* wrapCompactLatticeToWordAlignment_as_compact_lattice_to_word_alignment(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compact_lattice_to_word_alignment", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_to_word_alignment", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::std::vector< ::int32> ret1{};
  ::std::vector< ::int32> ret2{};
  ::std::vector< ::int32> ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::CompactLatticeToWordAlignment(*arg1, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// compact_lattice_to_word_prons(tmodel:TransitionModel, clat:CompactLatticeVectorFst) -> (success:bool, words:list<int>, begin_times:list<int>, lengths:list<int>, prons:list<list<int>>, phone_lengths:list<list<int>>)
static PyObject* wrapCompactLatticeToWordProns_as_compact_lattice_to_word_prons(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("tmodel"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:compact_lattice_to_word_prons", names, &a[0], &a[1])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_to_word_prons", names[0], "::kaldi::TransitionModel", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compact_lattice_to_word_prons", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[1]);
  ::std::vector< ::int32> ret1{};
  ::std::vector< ::int32> ret2{};
  ::std::vector< ::int32> ret3{};
  ::std::vector< ::std::vector< ::int32> > ret4{};
  ::std::vector< ::std::vector< ::int32> > ret5{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::CompactLatticeToWordProns(*arg1, *arg2, &ret1, &ret2, &ret3, &ret4, &ret5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(6);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  if ((p=Clif_PyObjFrom(std::move(ret4), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 4, p);
  if ((p=Clif_PyObjFrom(std::move(ret5), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 5, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// compact_lattice_shortest_path(clat:CompactLatticeVectorFst) -> CompactLatticeVectorFst
static PyObject* wrapCompactLatticeShortestPath_as_compact_lattice_shortest_path(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compact_lattice_shortest_path", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_shortest_path", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CompactLatticeShortestPath(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.CompactLatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// add_word_ins_pen_to_compact_lattice(word_ins_penalty:float, clat:CompactLatticeVectorFst)
static PyObject* wrapAddWordInsPenToCompactLattice_as_add_word_ins_pen_to_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("word_ins_penalty"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_word_ins_pen_to_compact_lattice", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_word_ins_pen_to_compact_lattice", names[0], "float", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_word_ins_pen_to_compact_lattice", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AddWordInsPenToCompactLattice(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _rescore_lattice(decodable:DecodableInterface, lat:LatticeVectorFst) -> bool
static PyObject* wrapRescoreLattice_as__rescore_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("decodable"),
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_rescore_lattice", names, &a[0], &a[1])) return nullptr;
  ::kaldi::DecodableInterface * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_rescore_lattice", names[0], "::kaldi::DecodableInterface *", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_rescore_lattice", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::RescoreLattice(arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _rescore_compact_lattice(decodable:DecodableInterface, clat:CompactLatticeVectorFst) -> bool
static PyObject* wrapRescoreCompactLattice_as__rescore_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("decodable"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_rescore_compact_lattice", names, &a[0], &a[1])) return nullptr;
  ::kaldi::DecodableInterface * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_rescore_compact_lattice", names[0], "::kaldi::DecodableInterface *", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_rescore_compact_lattice", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::RescoreCompactLattice(arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _longest_sentence_length_in_lattice(lat:LatticeVectorFst) -> int
static PyObject* wrapLongestSentenceLength_as__longest_sentence_length_in_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_longest_sentence_length_in_lattice", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_longest_sentence_length_in_lattice", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LongestSentenceLength(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _longest_sentence_length_in_compact_lattice(lat:CompactLatticeVectorFst) -> int
static PyObject* wrapLongestSentenceLength_as__longest_sentence_length_in_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_longest_sentence_length_in_compact_lattice", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_longest_sentence_length_in_compact_lattice", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LongestSentenceLength(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// rescore_compact_lattice_speedup(tmodel:TransitionModel, speedup_factor:float, decodable:DecodableInterface, clat:CompactLatticeVectorFst) -> bool
static PyObject* wrapRescoreCompactLatticeSpeedup_as_rescore_compact_lattice_speedup(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("tmodel"),
      C("speedup_factor"),
      C("decodable"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:rescore_compact_lattice_speedup", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("rescore_compact_lattice_speedup", names[0], "::kaldi::TransitionModel", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("rescore_compact_lattice_speedup", names[1], "float", a[1]);
  ::kaldi::DecodableInterface * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("rescore_compact_lattice_speedup", names[2], "::kaldi::DecodableInterface *", a[2]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("rescore_compact_lattice_speedup", names[3], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::RescoreCompactLatticeSpeedup(*arg1, std::move(arg2), arg3, arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// compose_compact_lattice_deterministic(clat:CompactLatticeVectorFst, det_fst:StdDeterministicOnDemandFst) -> CompactLatticeVectorFst
static PyObject* wrapComposeCompactLatticeDeterministic_as_compose_compact_lattice_deterministic(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("clat"),
      C("det_fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:compose_compact_lattice_deterministic", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compose_compact_lattice_deterministic", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compose_compact_lattice_deterministic", names[1], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ComposeCompactLatticeDeterministic(*arg1, arg2, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.CompactLatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("get_per_frame_acoustic_costs"), (PyCFunction)wrapGetPerFrameAcousticCosts_as_get_per_frame_acoustic_costs, METH_VARARGS | METH_KEYWORDS, C("get_per_frame_acoustic_costs(linear_lattice:LatticeVectorFst) -> Vector\n\nExtracts per-frame log likelihoods from a linear lattice.\n\nThe size of output vector will be set to the number of non-epsilon\ninput symbols in `linear_lattice`. The elements of output vector will be\nset to the second elements of the lattice weights, which represent the\nacoustic costs; you may want to scale this vector afterward by\n-1/acoustic_scale to get the original loglikes. If there are acoustic\ncosts on input-epsilon arcs or the final-probs (and this should\nnot normally be the case in situations where it makes sense to call this\nfunction), they will be included to the cost of the preceding input\nsymbol, or the following input symbol for input-epsilons encountered\nprior to any input symbol.  If `linear_lattice` has no input symbols,\noutput vector will be set to the empty vector.")},
  {C("_lattice_state_times"), (PyCFunction)wrapLatticeStateTimes_as__lattice_state_times, METH_VARARGS | METH_KEYWORDS, C("_lattice_state_times(lat:LatticeVectorFst) -> (num_frames:int, times:list<int>)\n  Calls C++ function\n  int ::kaldi::LatticeStateTimes(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >, ::std::vector< ::int32>*)")},
  {C("_compact_lattice_state_times"), (PyCFunction)wrapCompactLatticeStateTimes_as__compact_lattice_state_times, METH_VARARGS | METH_KEYWORDS, C("_compact_lattice_state_times(clat:CompactLatticeVectorFst) -> (num_frames:int, times:list<int>)\n  Calls C++ function\n  int ::kaldi::CompactLatticeStateTimes(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >, ::std::vector< ::int32>*)")},
  {C("lattice_forward_backward"), (PyCFunction)wrapLatticeForwardBackward_as_lattice_forward_backward, METH_VARARGS | METH_KEYWORDS, C("lattice_forward_backward(lat:LatticeVectorFst) -> (total_prob:float, arc_post:list<list<tuple<int, float>>>, acoustic_like_sum:float)\n\nComputes lattice arc posteriors using forward-backward algorithm.\n\nReturns the total log-probability of the lattice, arc posteriors and the\nsum over the arcs, of the posterior of the arc times the acoustic\nlikelihood [i.e. negated acoustic score] on that arc. The arc posteriors\ncontain pairs of `(transition-id, weight)` for each frame.")},
  {C("compute_compact_lattice_alphas"), (PyCFunction)wrapComputeCompactLatticeAlphas_as_compute_compact_lattice_alphas, METH_VARARGS | METH_KEYWORDS, C("compute_compact_lattice_alphas(clat:CompactLatticeVectorFst) -> (success:bool, alpha:list<float>)\n\nComputes the forward scores (alpha) for compact lattice states.")},
  {C("compute_compact_lattice_betas"), (PyCFunction)wrapComputeCompactLatticeBetas_as_compute_compact_lattice_betas, METH_VARARGS | METH_KEYWORDS, C("compute_compact_lattice_betas(clat:CompactLatticeVectorFst) -> (success:bool, beta:list<float>)\n\nComputes the backward scores (beta) for compact lattice states.")},
  {C("_compute_lattice_alphas_and_betas"), (PyCFunction)wrapComputeLatticeAlphasAndBetas_as__compute_lattice_alphas_and_betas, METH_VARARGS | METH_KEYWORDS, C("_compute_lattice_alphas_and_betas(lat:LatticeVectorFst, viterbi:bool) -> (total_prob:float, alpha:list<float>, beta:list<float>)\n  Calls C++ function\n  double ::kaldi::ComputeLatticeAlphasAndBetas(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >, bool, ::std::vector<double>*, ::std::vector<double>*)")},
  {C("_compute_compact_lattice_alphas_and_betas"), (PyCFunction)wrapComputeLatticeAlphasAndBetas_as__compute_compact_lattice_alphas_and_betas, METH_VARARGS | METH_KEYWORDS, C("_compute_compact_lattice_alphas_and_betas(clat:CompactLatticeVectorFst, viterbi:bool) -> (total_prob:float, alpha:list<float>, beta:list<float>)\n  Calls C++ function\n  double ::kaldi::ComputeLatticeAlphasAndBetas(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >, bool, ::std::vector<double>*, ::std::vector<double>*)")},
  {C("_top_sort_lattice_if_needed"), (PyCFunction)wrapTopSortLatticeIfNeeded_as__top_sort_lattice_if_needed, METH_VARARGS | METH_KEYWORDS, C("_top_sort_lattice_if_needed(lat:LatticeVectorFst)\n  Calls C++ function\n  void ::kaldi::TopSortLatticeIfNeeded(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *)")},
  {C("_top_sort_compact_lattice_if_needed"), (PyCFunction)wrapTopSortCompactLatticeIfNeeded_as__top_sort_compact_lattice_if_needed, METH_VARARGS | METH_KEYWORDS, C("_top_sort_compact_lattice_if_needed(clat:CompactLatticeVectorFst)\n  Calls C++ function\n  void ::kaldi::TopSortCompactLatticeIfNeeded(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *)")},
  {C("compact_lattice_depth"), (PyCFunction)wrapCompactLatticeDepth_as_compact_lattice_depth, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_depth(clat:CompactLatticeVectorFst) -> (depth:float, num_frames:int)\n\nComputes the depth of the compact lattice.\n\nReturns the depth of the lattice, defined as the average number of arcs\n(or final-prob strings) crossing any given frame, and the number of\nframes. Lattice depth is ``1`` for empty lattices. Requires that the\nlattice is topologically sorted!")},
  {C("compact_lattice_depth_per_frame"), (PyCFunction)wrapCompactLatticeDepthPerFrame_as_compact_lattice_depth_per_frame, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_depth_per_frame(clat:CompactLatticeVectorFst) -> list<int>\n\nComputes the per-frame depth of the compact lattice.\n\nReturns the per-frame depth of the lattice, defined as the number of arcs\n(or final-prob strings) crossing any given frame. Requires that the\nlattice is topologically sorted!")},
  {C("compact_lattice_limit_depth"), (PyCFunction)wrapCompactLatticeLimitDepth_as_compact_lattice_limit_depth, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_limit_depth(max_arcs_per_frame:int, clat:CompactLatticeVectorFst)\n\nLimits the depth of the compact lattice.\n\nDoes not allow more than a specified number of arcs active on any given\nframe. This can be used to reduce the size of the \"very deep\" portions of\nthe lattice.")},
  {C("lattice_active_phones"), (PyCFunction)wrapLatticeActivePhones_as_lattice_active_phones, METH_VARARGS | METH_KEYWORDS, C("lattice_active_phones(lat:LatticeVectorFst, trans:TransitionModel, sil_phones:list<int>) -> list<set<int>>\n\nComputes the set of phones active on each frame.\n\nGiven a lattice, and a transition model to map pdf-ids to phones, outputs\nfor each frame the set of phones active on that frame.  If `sil_phones`\n(which must be sorted and uniq) is non-empty, it excludes phones in this\nlist.")},
  {C("convert_lattice_to_phones"), (PyCFunction)wrapConvertLatticeToPhones_as_convert_lattice_to_phones, METH_VARARGS | METH_KEYWORDS, C("convert_lattice_to_phones(trans_model:TransitionModel, lat:LatticeVectorFst)\n\nReplaces output symbols in lattice with phones.\n\nGiven a lattice, and a transition model to map pdf-ids to phones,\nreplaces the output symbols (presumably words), with phones. Uses the\n`trans_model` to work out the phone sequence.  Note that the phone labels\nare not exactly aligned with the phone boundaries. Inserted phone labels\ncoincide with any transition to the final, nonemitting state of a phone\n(this state always exists). This would be the last transition-id in the\nphone if reordering is not done (but this is typically not the case).\n\nSee Also:\n  :meth:`~kaldi.lat.align.phone_align_lattice`")},
  {C("convert_compact_lattice_to_phones"), (PyCFunction)wrapConvertCompactLatticeToPhones_as_convert_compact_lattice_to_phones, METH_VARARGS | METH_KEYWORDS, C("convert_compact_lattice_to_phones(trans_model:TransitionModel, lat:CompactLatticeVectorFst)\n\nReplaces transition-ids in compact lattice with phones.\n\nGiven a lattice, and a transition model to map pdf-ids to phones,\nreplaces the sequences of transition-ids with sequences of phones. Note\nthat this is different from :meth:`convert_lattice_to_phones`, in that it\nreplaces the transition-ids not the words.")},
  {C("_prune_lattice"), (PyCFunction)wrapPruneLattice_as__prune_lattice, METH_VARARGS | METH_KEYWORDS, C("_prune_lattice(beam:float, lat:LatticeVectorFst) -> bool\n  Calls C++ function\n  bool ::kaldi::PruneLattice(float, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *)")},
  {C("_prune_compact_lattice"), (PyCFunction)wrapPruneLattice_as__prune_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("_prune_compact_lattice(beam:float, lat:CompactLatticeVectorFst) -> bool\n  Calls C++ function\n  bool ::kaldi::PruneLattice(float, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *)")},
  {C("lattice_boost"), (PyCFunction)wrapLatticeBoost_as_lattice_boost, METH_VARARGS | METH_KEYWORDS, C("lattice_boost(trans:TransitionModel, alignment:list<int>, silence_phones:list<int>, b:float, max_silence_error:float, lat:LatticeVectorFst) -> bool\n\nBoosts graph scores in the lattice.\n\nBoosts LM probabilities by b * [number of frame errors]; equivalently,\nadds -b*[number of frame errors] to the graph-component of the cost of\neach arc/path. There is a frame error if a particular transition-id on a\nparticular frame corresponds to a phone not matching transcription's\nalignment for that frame. This is used in \"margin-inspired\"\ndiscriminative training, esp. Boosted MMI. The transition model is used to\nmap transition-ids in the lattice input-side to phones; the phones\nappearing in `silence_phones` are treated specially in that we replace\nthe frame error f (either zero or 1) for a frame, with the minimum of f\nor `max_silence_error`. In the normal case, `max_silence_error` would be\nzero. Note that `silence_phones` must be sorted and unique.\n\nRaises:\n  ValueError: In case of failure.")},
  {C("lattice_forward_backward_mpe_variants"), (PyCFunction)wrapLatticeForwardBackwardMpeVariants_as_lattice_forward_backward_mpe_variants, METH_VARARGS | METH_KEYWORDS, C("lattice_forward_backward_mpe_variants(trans:TransitionModel, silence_phones:list<int>, lat:LatticeVectorFst, num_ali:list<int>, criterion:str, one_silence_class:bool) -> (objf_val:float, post:list<list<tuple<int, float>>>)\n\nComputes lattice posteriors for MPFE (or SMBR).\n\nThis function computes either the MPFE (minimum phone frame error) or\nsMBR (state-level minimum bayes risk) forward-backward, depending on\nwhether `criterion` is `\"mpfe\"` or `\"smbr\"`.\n\nArgs:\n  trans (TransitionModel): The transition model. Used to map the\n    transition-ids to phones or pdfs.\n  silence_phones (List[int]): A list of integer ids of silence phones.\n    The silence frames i.e. the frames where num_ali corresponds to a\n    silence phones are treated specially. The behavior is determined by\n    'one_silence_class' being false (traditional behavior) or true.\n    Usually in our setup, several phones including the silence, vocalized\n    noise, non-spoken noise and unk are treated as \"silence phones\".\n  lat (LatticeVectorFst): The denominator lattice.\n  num_ali (List[int]): The numerator alignment.\n  criterion (str): The objective function. Must be \"mpfe\" or \"smbr\" for\n    MPFE (minimum phone frame error) or sMBR (state-level minimum bayes\n    risk) training.\n  one_silence_class (bool): Determines how the silence frames are\n    treated. Setting this to false gives the old traditional behavior,\n    where the silence frames (according to num_ali) are treated as\n    incorrect. However, this means that the insertions are not penalized\n    by the objective. Setting this to true gives the new behaviour, where\n    we treat silence as any other phone, except that all pdfs of silence\n    phones are collapsed into a single class for the frame-error\n    computation. This can possible reduce the insertions in the trained\n    model. This is closer to the WER metric that we actually care about,\n    since WER is generally computed after filtering out noises, but does\n    penalize insertions.\n\nReturns:\n  The objective function value (MPFE or sMBR criterion) and the\n  posteriors (which may be positive or negative).")},
  {C("lattice_forward_backward_mmi"), (PyCFunction)wrapLatticeForwardBackwardMmi_as_lattice_forward_backward_mmi, METH_VARARGS | METH_KEYWORDS, C("lattice_forward_backward_mmi(trans:TransitionModel, lat:LatticeVectorFst, num_ali:list<int>, drop_frames:bool, convert_to_pdf_ids:bool, cancel:bool) -> (objf_val:float, post:list<list<tuple<int, float>>>)\n\nComputes lattice posteriors for MMI.\n\nArgs:\n  trans (TransitionModel): The transition model. Used to map the\n    transition-ids to phones or pdfs.\n  lat (LatticeVectorFst): The denominator lattice\n  num_ali (List[int]): The numerator alignment\n  drop_frames (bool): If `True`, it will not compute any posteriors on\n    frames where the num and den have disjoint pdf-ids.\n  convert_to_pdf_ids (bool): If `True`, it will convert the output to be\n    at the level of pdf-ids, not transition-ids.\n  cancel (bool): If `true`, it will cancel out any positive and negative\n    parts from the same transition-id (or pdf-id, if `convert_to_pdf_ids\n    == True`).\n\nReturns:\n  The forward-backward likelihood of the lattice and the MMI posteriors\n  for transition-ids (or pdf-ids if `convert_to_pdf_ids == True`) at each\n  frame i.e. the difference between the numerator and denominator\n  posteriors.")},
  {C("compact_lattice_to_word_alignment"), (PyCFunction)wrapCompactLatticeToWordAlignment_as_compact_lattice_to_word_alignment, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_to_word_alignment(clat:CompactLatticeVectorFst) -> (success:bool, words:list<int>, begin_times:list<int>, lengths:list<int>)\n\nExtracts word alignment from a linear compact lattice.\n\nThis function takes a compact lattice that should only contain a single\nlinear sequence (e.g. output of :meth:`compact_lattice_shortest_path`),\nand that should have been processed so that the arcs align correctly with\nthe word boundaries (e.g. by :meth:`word_align_lattice`). It outputs 3\nlists of the same size, which represent, for each word in the lattice (in\nsequence), the word label and the begin time and length in frames. This\nis done even for zero (epsilon) words, generally corresponding to\noptional silence -- if you don't want them, just ignore them in the\noutput.\n\nRaises:\n  ValueError: If the lattice does not have the correct format (e.g. if\n  it is empty or if it is not linear).")},
  {C("compact_lattice_to_word_prons"), (PyCFunction)wrapCompactLatticeToWordProns_as_compact_lattice_to_word_prons, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_to_word_prons(tmodel:TransitionModel, clat:CompactLatticeVectorFst) -> (success:bool, words:list<int>, begin_times:list<int>, lengths:list<int>, prons:list<list<int>>, phone_lengths:list<list<int>>)\n\nExtracts word pronunciations from a linear compact lattice.\n\nThis function takes a compact lattice that should only contain a single\nlinear sequence (e.g. output of :meth:`compact_lattice_shortest_path`),\nand that should have been processed so that the arcs align correctly with\nthe word boundaries (e.g. by :meth:`word_align_lattice`).  It outputs 4\nvectors of the same size, which represent, for each word in the lattice\n(in sequence), the word label, the begin time, length in frames, and the\npronunciation (sequence of phones). This is done even for zero (epsilon)\nwords, corresponding to optional silences -- if you don't want them, just\nignore them in the output.\n\nRaises:\n  ValueError: If the lattice does not have the correct format (e.g. if\n  it is empty or if it is not linear).")},
  {C("compact_lattice_shortest_path"), (PyCFunction)wrapCompactLatticeShortestPath_as_compact_lattice_shortest_path, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_shortest_path(clat:CompactLatticeVectorFst) -> CompactLatticeVectorFst\n\nComputes the shortest path in an acyclic compact lattice.")},
  {C("add_word_ins_pen_to_compact_lattice"), (PyCFunction)wrapAddWordInsPenToCompactLattice_as_add_word_ins_pen_to_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("add_word_ins_pen_to_compact_lattice(word_ins_penalty:float, clat:CompactLatticeVectorFst)\n\nAdds the penalty term to the graph scores of arcs in the lattice.")},
  {C("_rescore_lattice"), (PyCFunction)wrapRescoreLattice_as__rescore_lattice, METH_VARARGS | METH_KEYWORDS, C("_rescore_lattice(decodable:DecodableInterface, lat:LatticeVectorFst) -> bool\n  Calls C++ function\n  bool ::kaldi::RescoreLattice(::kaldi::DecodableInterface *, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *)")},
  {C("_rescore_compact_lattice"), (PyCFunction)wrapRescoreCompactLattice_as__rescore_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("_rescore_compact_lattice(decodable:DecodableInterface, clat:CompactLatticeVectorFst) -> bool\n  Calls C++ function\n  bool ::kaldi::RescoreCompactLattice(::kaldi::DecodableInterface *, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *)")},
  {C("_longest_sentence_length_in_lattice"), (PyCFunction)wrapLongestSentenceLength_as__longest_sentence_length_in_lattice, METH_VARARGS | METH_KEYWORDS, C("_longest_sentence_length_in_lattice(lat:LatticeVectorFst) -> int\n  Calls C++ function\n  int ::kaldi::LongestSentenceLength(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >)")},
  {C("_longest_sentence_length_in_compact_lattice"), (PyCFunction)wrapLongestSentenceLength_as__longest_sentence_length_in_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("_longest_sentence_length_in_compact_lattice(lat:CompactLatticeVectorFst) -> int\n  Calls C++ function\n  int ::kaldi::LongestSentenceLength(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >)")},
  {C("rescore_compact_lattice_speedup"), (PyCFunction)wrapRescoreCompactLatticeSpeedup_as_rescore_compact_lattice_speedup, METH_VARARGS | METH_KEYWORDS, C("rescore_compact_lattice_speedup(tmodel:TransitionModel, speedup_factor:float, decodable:DecodableInterface, clat:CompactLatticeVectorFst) -> bool\n\nAdjusts acoustic scores in the compact lattice.\n\nThis function is like :meth:`rescore_lattice`, but it avoids computing\nprobabilities on most frames where all the pdf-ids are the same. It needs\nthe transition-model to work out whether two transition-ids map to the\nsame pdf-id, and it assumes that the lattice has transition-ids on it.\nThe naive thing would be to just set all probabilities to zero on frames\nwhere all the pdf-ids are the same (because this value won't affect the\nlattice posterior). But this would become confusing when we compute\ncorpus-level diagnostics such as the MMI objective function. Instead, for\n`speedup_factor = 100` (must be >= 1.0), with probability `1.0 /\nspeedup_factor` we compute those likelihoods and multiply them by\n`speedup_factor`; otherwise we set them to zero. This gives the right\nexpected probability so our corpus-level diagnostics will be about right.\n\nSee Also:\n  :meth:`rescore_lattice`")},
  {C("compose_compact_lattice_deterministic"), (PyCFunction)wrapComposeCompactLatticeDeterministic_as_compose_compact_lattice_deterministic, METH_VARARGS | METH_KEYWORDS, C("compose_compact_lattice_deterministic(clat:CompactLatticeVectorFst, det_fst:StdDeterministicOnDemandFst) -> CompactLatticeVectorFst\n\nComposes a compact lattice with a deterministic on-demand FST.\n\nThis function is used in language model rescoring. Composition affects\nonly graph costs. The output is another compact lattice.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_lattice_functions",  // module name
  "CLIF-generated module for lat/lattice-functions.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_decodable_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_deterministic_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_transition_model")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __lattice__functions_clifwrap
