//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/rnnlm/sampling-lm-estimate.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "itf/options-itf-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "sampling-lm-estimate-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __sampling__lm__estimate_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pySamplingLmEstimatorOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimatorOptions> cpp;
};
static ::kaldi::rnnlm::SamplingLmEstimatorOptions* ThisPtr(PyObject*);

static PyObject* get_vocab_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->vocab_size, {});
}

static int set_vocab_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the vocab_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->vocab_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for vocab_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_ngram_order(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ngram_order, {});
}

static int set_ngram_order(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ngram_order attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ngram_order)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ngram_order:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_discounting_constant(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->discounting_constant, {});
}

static int set_discounting_constant(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the discounting_constant attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->discounting_constant)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for discounting_constant:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_unigram_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->unigram_factor, {});
}

static int set_unigram_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the unigram_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->unigram_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for unigram_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_backoff_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->backoff_factor, {});
}

static int set_backoff_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the backoff_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->backoff_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for backoff_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_bos_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->bos_factor, {});
}

static int set_bos_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the bos_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->bos_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for bos_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_unigram_power(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->unigram_power, {});
}

static int set_unigram_power(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the unigram_power attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->unigram_power)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for unigram_power:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_bos_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->bos_symbol, {});
}

static int set_bos_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the bos_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->bos_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for bos_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_eos_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->eos_symbol, {});
}

static int set_eos_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the eos_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->eos_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for eos_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_brk_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->brk_symbol, {});
}

static int set_brk_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the brk_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->brk_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for brk_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// check()
static PyObject* wrapCheck_as_check(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Check();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("vocab_size"), get_vocab_size, set_vocab_size, C("The vocabulary size.\n\nIf set, must be set to the highest-numbered vocabulary word plus one;\notherwise this is worked out from the symbol table.")},
  {C("ngram_order"), get_ngram_order, set_ngram_order, C("Order for the n-gram model (must be >= 1), e.g. 3 means trigram")},
  {C("discounting_constant"), get_discounting_constant, set_discounting_constant, C("Constant for absolute discounting.\n\nIt should be in the range 0.8 to 1.0. Smaller values give a larger\nlanguage model.")},
  {C("unigram_factor"), get_unigram_factor, set_unigram_factor, C("The unigram factor.\n\nFactor by which p(w|h) for non-unigram history state h (with the backoff\nterm excluded) has to be greater than p(w|unigram-state) for us to\ninclude it in the model. Must be >0.0, will normally be >1.0.")},
  {C("backoff_factor"), get_backoff_factor, set_backoff_factor, C("The backoff factor.\n\nFactor by which p(w|h) for higher-than-bigram history state h (with the\nbackoff term excluded) has to be greater than p(w|backoff-state) for us\nto include it in the model (in addition to the `unigram_factor`\nconstraint). Must be >0.0 and < unigram-factor.")},
  {C("bos_factor"), get_bos_factor, set_bos_factor, C("The beginning of sentence factor.\n\nFactor by which p(w|h) for h == the BOS history state (with the backoff\nterm excluded) has to be higher than p(w|unigram-state) for us to\ninclude it in the model. Must be >0.0 and <= unigram-factor.")},
  {C("unigram_power"), get_unigram_power, set_unigram_power, C("The unigram power scalar.\n\nThis is an important configuration value. After all other stages of\nestimating the model, the unigram probabilities are taken to this power,\ne.g. 0.75, and then rescaled to sum to 1.0. There are both theoretical\nand practical reasons why we want to apply this power just to the unigram\nportion.")},
  {C("bos_symbol"), get_bos_symbol, set_bos_symbol, C("Integer id for the BOS word (<s>).")},
  {C("eos_symbol"), get_eos_symbol, set_eos_symbol, C("Integer id for the EOS word (</s>).")},
  {C("brk_symbol"), get_brk_symbol, set_brk_symbol, C("Integer id for the Break word (<brk>).\n\nNot needed but included for ease of scripting.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n\nRegisters options with an object implementing the options interface.\n\nArgs:\n  opts (OptionsItf): An object implementing the options interface.\n    Typically a command-line option parser.")},
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_NOARGS, C("check()\n\nValidates the options.\n\nRaises:\n  RuntimeError: If validation fails.")},
  {}
};

// SamplingLmEstimatorOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SamplingLmEstimatorOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SamplingLmEstimatorOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sampling_lm_estimate.SamplingLmEstimatorOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Options for sampling LM estimator.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SamplingLmEstimatorOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::SamplingLmEstimatorOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::SamplingLmEstimatorOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_SamplingLmEstimatorOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::SamplingLmEstimatorOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::SamplingLmEstimatorOptions* c = static_cast<::kaldi::rnnlm::SamplingLmEstimatorOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::SamplingLmEstimatorOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySamplingLmEstimatorOptions

namespace pySamplingLmEstimator {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimator> cpp;
};
static ::kaldi::rnnlm::SamplingLmEstimator* ThisPtr(PyObject*);

// __init__(config:SamplingLmEstimatorOptions)
static PyObject* wrapSamplingLmEstimator_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::rnnlm::SamplingLmEstimatorOptions", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::SamplingLmEstimator>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// process_line(corpus_weight:float, sentence:list<int>)
static PyObject* wrapProcessLine_as_process_line(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("corpus_weight"),
      C("sentence"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:process_line", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("process_line", names[0], "float", a[0]);
  ::std::vector< ::int32> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("process_line", names[1], "::std::vector< ::int32>", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimator* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ProcessLine(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// process(is:istream)
static PyObject* wrapProcess_as_process(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("is"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:process", names, &a[0])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("process", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimator* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Process(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// estimate(will_write_arpa:bool)
static PyObject* wrapEstimate_as_estimate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("will_write_arpa"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:estimate", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("estimate", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimator* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Estimate(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// print_as_arpa(os:ostream, symbols:SymbolTable)
static PyObject* wrapPrintAsArpa_as_print_as_arpa(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("symbols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:print_as_arpa", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("print_as_arpa", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::fst::SymbolTable* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("print_as_arpa", names[1], "::fst::SymbolTable", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLmEstimator* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->PrintAsArpa(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSamplingLmEstimator_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(config:SamplingLmEstimatorOptions)\n  Calls C++ function\n  void ::kaldi::rnnlm::SamplingLmEstimator::SamplingLmEstimator(::kaldi::rnnlm::SamplingLmEstimatorOptions)")},
  {C("process_line"), (PyCFunction)wrapProcessLine_as_process_line, METH_VARARGS | METH_KEYWORDS, C("process_line(corpus_weight:float, sentence:list<int>)\n\nProcesses one line of the input, adding it to the stored stats.\n\nArgs:\n  corpus_weight (float): Weight attached to the corpus from which this\n    data came. (Note: you shouldn't repeat sentences when providing\n    them to this class, although this is allowed during the actual\n    RNNLM training; instead, you should make sure that the multiplicity\n    that you use in the RNNLM for this corpus is reflected in\n    'corpus_weight'.)\n  sentence (List[int]): The sentence we are processing. It is not\n    expected to contain the BOS symbol, and should not be terminated by\n    the EOS symbol, although the EOS symbol is allowed internally\n    (where it can be used to separate a sequence of sentences from a\n    dialogue or other sequence of text, if you want to do this).")},
  {C("process"), (PyCFunction)wrapProcess_as_process, METH_VARARGS | METH_KEYWORDS, C("process(is:istream)\n\nProcesses the lines read from the input stream.\n\nLines will be of the format:\n  <weight> <possibly-empty-sequence-of-integers>\ne.g.:\n  1.0  2560 8991\n\nArgs:\n  is (istream): The input stream.")},
  {C("estimate"), (PyCFunction)wrapEstimate_as_estimate, METH_VARARGS | METH_KEYWORDS, C("estimate(will_write_arpa:bool)\n\nEstimates the language model (including the discounting).\n\nArgs:\n  will_write_arpa (bool): Whether to retain certain n-grams (required\n    in the ARPA file format) that would otherwise have been pruned.")},
  {C("print_as_arpa"), (PyCFunction)wrapPrintAsArpa_as_print_as_arpa, METH_VARARGS | METH_KEYWORDS, C("print_as_arpa(os:ostream, symbols:SymbolTable)\n\nPrints the LM in ARPA format.\n\nArgs:\n  os (ostream): The output stream to write the model to.\n  symbols (SymbolTable): The symbol table to map integers to words.")},
  {}
};

// SamplingLmEstimator __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SamplingLmEstimator __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SamplingLmEstimator __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sampling_lm_estimate.SamplingLmEstimator", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Sampling LM estimator.\n\nThis class is responsible for creating a backoff n-gram language model of\na type that's suitable for use in the importance sampling algorithm we\nuse for RNNLM training.  It's the type of language model that could in\nprinciple be written in ARPA format, but it's created in a special way.\nThere are a few characteristics of the importance sampling algorithm that\nmake it desirable to write a special purpose language model instead of\nusing a generic language model toolkit. These are:\n\n* When we sample, we sample from a distribution that is the average of a\n  fairly large number of history states N (e.g., N=128), that can be\n  treated as independently chosen for practical purposes (except that\n  sometimes they'll all be the BOS history, which is a special case).\n* The convergence of the sampling-based method won't be sensitive to\n  small differences in the probabilities of the distribution we sample\n  on.\n* It's important not to have too many words that are specifically\n  predicted from a typical history-state, or it makes the sampling\n  process slow.\n\nArgs:\n  config (SamplingLmEstimatorOptions): Options for sampling LM estimator.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSamplingLmEstimator_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::SamplingLmEstimator* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_SamplingLmEstimator"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::SamplingLmEstimator"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::SamplingLmEstimator* c = static_cast<::kaldi::rnnlm::SamplingLmEstimator*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::SamplingLmEstimator*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySamplingLmEstimator


// Initialize module

bool Ready() {
  if (PyType_Ready(&pySamplingLmEstimatorOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pySamplingLmEstimatorOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySamplingLmEstimator::wrapper_Type) < 0) return false;
  Py_INCREF(&pySamplingLmEstimator::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_sampling_lm_estimate",  // module name
  "CLIF-generated module for rnnlm/sampling-lm-estimate.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "SamplingLmEstimatorOptions", reinterpret_cast<PyObject*>(&pySamplingLmEstimatorOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SamplingLmEstimator", reinterpret_cast<PyObject*>(&pySamplingLmEstimator::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __sampling__lm__estimate_clifwrap

namespace kaldi { namespace rnnlm {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// SamplingLmEstimator to/from ::kaldi::rnnlm::SamplingLmEstimator conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::SamplingLmEstimator** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::SamplingLmEstimator* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimator::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::SamplingLmEstimator>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimator* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimator::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::SamplingLmEstimator>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimator* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimator::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SamplingLmEstimator instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::SamplingLmEstimator* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimator>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::SamplingLmEstimator> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimator>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::SamplingLmEstimator> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimator::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimator>(std::move(c));
  return py;
}

// SamplingLmEstimatorOptions to/from ::kaldi::rnnlm::SamplingLmEstimatorOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::SamplingLmEstimatorOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::SamplingLmEstimatorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::SamplingLmEstimatorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SamplingLmEstimatorOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::SamplingLmEstimatorOptions* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::SamplingLmEstimatorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLmEstimatorOptions* cpp = __sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::SamplingLmEstimatorOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimatorOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::SamplingLmEstimatorOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimatorOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::SamplingLmEstimatorOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLmEstimatorOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::SamplingLmEstimatorOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm__estimate_clifwrap::pySamplingLmEstimatorOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::SamplingLmEstimatorOptions>(c);
  return py;
}

} }  // namespace kaldi::rnnlm
