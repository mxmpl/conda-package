//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/rnnlm/sampling-lm.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "lm/arpa-file-parser-clifwrap.h"
#include "rnnlm/sampling-lm-estimate-clifwrap.h"
#include "sampling-lm-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __sampling__lm_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pySamplingLm {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::SamplingLm> cpp;
};
static ::kaldi::rnnlm::SamplingLm* ThisPtr(PyObject*);

// @classmethod from_options(options:ArpaParseOptions, symbols:SymbolTable) -> SamplingLm
static PyObject* wrapSamplingLm_as_from_options(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("options"),
      C("symbols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_options", names, &a[0], &a[1])) return nullptr;
  ::kaldi::ArpaParseOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_options", names[0], "::kaldi::ArpaParseOptions", a[0]);
  ::fst::SymbolTable * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_options", names[1], "::fst::SymbolTable *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::rnnlm::SamplingLm> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::rnnlm::SamplingLm>(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_estimator(estimator:SamplingLmEstimator) -> SamplingLm
static PyObject* wrapSamplingLm_as_from_estimator(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("estimator"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_estimator", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::SamplingLmEstimator* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_estimator", names[0], "::kaldi::rnnlm::SamplingLmEstimator", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::rnnlm::SamplingLm> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::rnnlm::SamplingLm>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_arpa(is:istream)
static PyObject* wrapRead_as_read_arpa(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("is"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:read_arpa", names, &a[0])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_arpa", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_unigram_distribution() -> list<float>
static PyObject* wrapGetUnigramDistribution_as_get_unigram_distribution(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::vector< ::kaldi::BaseFloat> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetUnigramDistribution();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_distribution(histories:list<tuple<list<int>, float>>) -> (unigram_prob:float, non_unigram_probs:dict<int, float>)
static PyObject* wrapGetDistribution_as_get_distribution(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("histories"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_distribution", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::SamplingLm::WeightedHistType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_distribution", names[0], "::kaldi::rnnlm::SamplingLm::WeightedHistType", a[0]);
  ::std::unordered_map< ::int32, ::kaldi::BaseFloat> ret1{};
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetDistribution(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// get_distribution_pairs(histories:list<tuple<list<int>, float>>) -> (unigram_prob:float, non_unigram_probs:list<tuple<int, float>>)
static PyObject* wrapGetDistribution_as_get_distribution_pairs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("histories"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_distribution_pairs", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::SamplingLm::WeightedHistType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_distribution_pairs", names[0], "::kaldi::rnnlm::SamplingLm::WeightedHistType", a[0]);
  ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> > ret1{};
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetDistribution(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// order() -> int
static PyObject* wrapOrder_as_order(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Order();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap(other:SamplingLm)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::SamplingLm * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::rnnlm::SamplingLm *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// vocab_size() -> int
static PyObject* wrapVocabSize_as_vocab_size(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::SamplingLm* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->VocabSize();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::ArpaFileParser*
static PyObject* as_kaldi_ArpaFileParser(PyObject* self) {
  ::kaldi::ArpaFileParser* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::ArpaFileParser"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_options"), (PyCFunction)wrapSamplingLm_as_from_options, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_options(options:ArpaParseOptions, symbols:SymbolTable) -> SamplingLm\n\nCreates a new sampling LM with the given options.\n\nARPA LM is read from the file specified in the options. Only text mode\nis supported.\n\nArgs:\n  options (ArpaParseOptions): The options for parsing ARPA LM files.\n  symbols (SymbolTable): The symbol table.")},
  {C("from_estimator"), (PyCFunction)wrapSamplingLm_as_from_estimator, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_estimator(estimator:SamplingLmEstimator) -> SamplingLm\n\nCreates a new sampling LM with the given estimator.\n\nThis constructor reads the object directly from a `SamplingLmEstimator`\ninstance, which is much faster than dealing with the ARPA format.  It\nalso allows us to avoid having to add a bunch of unnecessary n-grams to\nsatisfy the requirements of the ARPA file format. It assumes that you\nhave already called :meth:`estimator.estimate`.\n\nArgs:\n  estimator (SamplingLmEstimator): The sampling LM estimator.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the sampling LM to output stream.\n\nArgs:\n  os (ostream): The output C++ stream.\n  binary (bool): Whether the stream is binary.")},
  {C("read_arpa"), (PyCFunction)wrapRead_as_read_arpa, METH_VARARGS | METH_KEYWORDS, C("read_arpa(is:istream)\n\nReads the sampling LM from a file in ARPA format.\n\nArgs:\n  is (istream): The input C++ stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n\nReads the sampling LM from input stream.\n\nThis method does not read the ARPA format, it reads the special-purpose\nformat written by :meth:`write`.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n\nSee Also:\n  :meth:`read_arpa`.")},
  {C("get_unigram_distribution"), (PyCFunction)wrapGetUnigramDistribution_as_get_unigram_distribution, METH_NOARGS, C("get_unigram_distribution() -> list<float>\n\nGets unigram probabilities.\n\nThis method outputs the unigram distribution of all words represented\nby integers from 0 to maximum symbol id.\n\nReturns:\n  A list of floats representing the unigram distribution of all words.\n\nNote:\n  There can be gaps of integers for words in the ARPA LM, we set the\n  probabilities of words that are not in the ARPA LM to be 0.0, e.g.,\n  symbol id 0 which represents epsilon has probability 0.0")},
  {C("get_distribution"), (PyCFunction)wrapGetDistribution_as_get_distribution, METH_VARARGS | METH_KEYWORDS, C("get_distribution(histories:list<tuple<list<int>, float>>) -> (unigram_prob:float, non_unigram_probs:dict<int, float>)\n\nGets word probabilities given a list of histories.\n\nArgs:\n  histories (List[Tuple[List[int],float]]): A list of histories with\n    associated weights.\n\nReturns:\n  A scalar `unigram_prob` which is computed by summing all history\n  weights after scaling them with the corresponding backoff weights and\n  a dictionary mapping words to their corresponding probabilities given\n  the list of histories.\n\nNote:\n  The sum of the returned `unigram_prob` plus the second elements of\n  the output `non_unigram_probs` will not necessarily be equal to 1.0,\n  but it will be equal to the total of the weights of histories in\n  `histories`.\n\nSee Also:\n  :meth:`get_distribution_pairs`.")},
  {C("get_distribution_pairs"), (PyCFunction)wrapGetDistribution_as_get_distribution_pairs, METH_VARARGS | METH_KEYWORDS, C("get_distribution_pairs(histories:list<tuple<list<int>, float>>) -> (unigram_prob:float, non_unigram_probs:list<tuple<int, float>>)\n\nGets word probabilities given a list of histories.\n\nArgs:\n  histories (List[Tuple[List[int],float]]): A list of histories with\n    associated weights.\n\nReturns:\n  A scalar `unigram_prob` which is computed by summing all history\n  weights after scaling them with the corresponding backoff weights and\n  a list of pairs (word-id, weight), that's sorted and unique on\n  word-id, mapping words to their corresponding probabilities given the\n  list of histories.\n\nNote:\n  The sum of the returned `unigram_prob` plus the second elements of\n  the output `non_unigram_probs` will not necessarily be equal to 1.0,\n  but it will be equal to the total of the weights of histories in\n  `histories`.\n\nSee Also:\n  :meth:`get_distribution`.")},
  {C("order"), (PyCFunction)wrapOrder_as_order, METH_NOARGS, C("order() -> int\n\nGets n-gram order.\n\nReturns:\n  int: The n-gram order, e.g. 1 for a unigram LM, 2 for a bigram.")},
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:SamplingLm)\n\nSwaps contents with another sampling LM.\n\nArgs:\n  other (SamplingLm): The other sampling LM.")},
  {C("vocab_size"), (PyCFunction)wrapVocabSize_as_vocab_size, METH_NOARGS, C("vocab_size() -> int\n\nGets vocabulary size.\n\nReturns:\n  int: The vocabulary size, i.e. the highest-numbered word plus one.")},
  {C("as_kaldi_ArpaFileParser"), (PyCFunction)as_kaldi_ArpaFileParser, METH_NOARGS, C("Upcast to ::kaldi::ArpaFileParser*")},
  {}
};

// SamplingLm __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SamplingLm __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SamplingLm __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sampling_lm.SamplingLm",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Sampling LM.",                      // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SamplingLm takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::SamplingLm>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::SamplingLm* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_SamplingLm"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::SamplingLm"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::SamplingLm* c = static_cast<::kaldi::rnnlm::SamplingLm*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::SamplingLm*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySamplingLm


// Initialize module

bool Ready() {
  PyObject* base_cls = ImportFQName("kaldi.lm._arpa_file_parser.ArpaFileParser");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.lm._arpa_file_parser.ArpaFileParser is not a new style class inheriting from object.");
    return false;
  }
  pySamplingLm::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pySamplingLm::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.lm._arpa_file_parser.ArpaFileParser is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pySamplingLm::wrapper_Type) < 0) return false;
  Py_INCREF(&pySamplingLm::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_sampling_lm",  // module name
  "CLIF-generated module for rnnlm/sampling-lm.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_arpa_file_parser")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sampling_lm_estimate")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "SamplingLm", reinterpret_cast<PyObject*>(&pySamplingLm::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __sampling__lm_clifwrap

namespace kaldi { namespace rnnlm {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// SamplingLm to/from ::kaldi::rnnlm::SamplingLm conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::SamplingLm** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::SamplingLm* cpp = __sampling__lm_clifwrap::pySamplingLm::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::SamplingLm>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLm* cpp = __sampling__lm_clifwrap::pySamplingLm::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::SamplingLm>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLm* cpp = __sampling__lm_clifwrap::pySamplingLm::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SamplingLm instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::SamplingLm* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLm* cpp = __sampling__lm_clifwrap::pySamplingLm::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::SamplingLm>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::SamplingLm* cpp = __sampling__lm_clifwrap::pySamplingLm::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::SamplingLm* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm_clifwrap::pySamplingLm::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLm>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::SamplingLm> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm_clifwrap::pySamplingLm::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLm>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::SamplingLm> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sampling__lm_clifwrap::pySamplingLm::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::SamplingLm>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::SamplingLm& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__sampling__lm_clifwrap::pySamplingLm::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sampling__lm_clifwrap::pySamplingLm::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::SamplingLm>(c);
  return py;
}

} }  // namespace kaldi::rnnlm
