//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/ivector/ivector-extractor.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/sp-matrix-clifwrap.h"
#include "itf/options-itf-clifwrap.h"
#include "gmm/full-gmm-clifwrap.h"
#include "base/iostream-clifwrap.h"
#include "ivector-extractor-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __ivector__extractor_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyIvectorEstimationOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorEstimationOptions> cpp;
};
static ::kaldi::IvectorEstimationOptions* ThisPtr(PyObject*);

static PyObject* get_acoustic_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->acoustic_weight, {});
}

static int set_acoustic_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the acoustic_weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->acoustic_weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for acoustic_weight:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_count(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_count, {});
}

static int set_max_count(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_count attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_count)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_count:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorEstimationOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("acoustic_weight"), get_acoustic_weight, set_acoustic_weight, C("C++ double IvectorEstimationOptions.acoustic_weight")},
  {C("max_count"), get_max_count, set_max_count, C("C++ double IvectorEstimationOptions.max_count")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::IvectorEstimationOptions::Register(::kaldi::OptionsItf *)")},
  {}
};

// IvectorEstimationOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorEstimationOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorEstimationOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorEstimationOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Options for estimating iVectors, during both trainning and test.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorEstimationOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorEstimationOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorEstimationOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorEstimationOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorEstimationOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorEstimationOptions* c = static_cast<::kaldi::IvectorEstimationOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorEstimationOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorEstimationOptions

namespace pyIvectorExtractorUtteranceStats {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractorUtteranceStats> cpp;
};
static ::kaldi::IvectorExtractorUtteranceStats* ThisPtr(PyObject*);

// @classmethod new_with_params(num_gauss:int, feat_dim:int, need_2nd_order_stats:bool) -> IvectorExtractorUtteranceStats
static PyObject* wrapIvectorExtractorUtteranceStats_as_new_with_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("num_gauss"),
      C("feat_dim"),
      C("need_2nd_order_stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:new_with_params", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_with_params", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_with_params", names[1], "int", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("new_with_params", names[2], "bool", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::IvectorExtractorUtteranceStats> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::IvectorExtractorUtteranceStats>(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// acc_stats(feats:MatrixBase, post:list<list<tuple<int, float>>>)
static PyObject* wrapAccStats_as_acc_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("feats"),
      C("post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:acc_stats", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("acc_stats", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::Posterior arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("acc_stats", names[1], "::kaldi::Posterior", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorUtteranceStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AccStats(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorUtteranceStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_frames() -> float
static PyObject* wrapNumFrames_as_num_frames(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractorUtteranceStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumFrames();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("new_with_params"), (PyCFunction)wrapIvectorExtractorUtteranceStats_as_new_with_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new_with_params(num_gauss:int, feat_dim:int, need_2nd_order_stats:bool) -> IvectorExtractorUtteranceStats\n  Calls C++ function\n  std::unique_ptr<::kaldi::IvectorExtractorUtteranceStats> ::kaldi::IvectorExtractorUtteranceStats::IvectorExtractorUtteranceStats(int, int, bool)")},
  {C("acc_stats"), (PyCFunction)wrapAccStats_as_acc_stats, METH_VARARGS | METH_KEYWORDS, C("acc_stats(feats:MatrixBase, post:list<list<tuple<int, float>>>)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorUtteranceStats::AccStats(::kaldi::MatrixBase<float>, ::kaldi::Posterior)")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorUtteranceStats::Scale(double)")},
  {C("num_frames"), (PyCFunction)wrapNumFrames_as_num_frames, METH_NOARGS, C("num_frames() -> float\n  Calls C++ function\n  double ::kaldi::IvectorExtractorUtteranceStats::NumFrames()")},
  {}
};

// IvectorExtractorUtteranceStats __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractorUtteranceStats __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractorUtteranceStats", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Stats for a particular utterance, i.e., the sufficient stats for estimating an iVector", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractorUtteranceStats* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractorUtteranceStats"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractorUtteranceStats"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractorUtteranceStats* c = static_cast<::kaldi::IvectorExtractorUtteranceStats*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractorUtteranceStats*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractorUtteranceStats

namespace pyIvectorExtractorOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractorOptions> cpp;
};
static ::kaldi::IvectorExtractorOptions* ThisPtr(PyObject*);

static PyObject* get_ivector_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ivector_dim, {});
}

static int set_ivector_dim(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ivector_dim attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ivector_dim)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ivector_dim:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_iters(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_iters, {});
}

static int set_num_iters(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_iters attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_iters)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_iters:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_use_weights(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->use_weights, {});
}

static int set_use_weights(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the use_weights attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->use_weights)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for use_weights:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("ivector_dim"), get_ivector_dim, set_ivector_dim, C("C++ int IvectorExtractorOptions.ivector_dim")},
  {C("num_iters"), get_num_iters, set_num_iters, C("C++ int IvectorExtractorOptions.num_iters")},
  {C("use_weights"), get_use_weights, set_use_weights, C("C++ bool IvectorExtractorOptions.use_weights")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorOptions::Register(::kaldi::OptionsItf *)")},
  {}
};

// IvectorExtractorOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorExtractorOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractorOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractorOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::IvectorExtractorOptions", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorExtractorOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractorOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractorOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractorOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractorOptions* c = static_cast<::kaldi::IvectorExtractorOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractorOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractorOptions

namespace pyIvectorExtractor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractor> cpp;
};
static ::kaldi::IvectorExtractor* ThisPtr(PyObject*);

// @classmethod new_with_params(opts:IvectorExtractorOptions, fgmm:FullGmm) -> IvectorExtractor
static PyObject* wrapIvectorExtractor_as_new_with_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("opts"),
      C("fgmm"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:new_with_params", names, &a[0], &a[1])) return nullptr;
  ::kaldi::IvectorExtractorOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_with_params", names[0], "::kaldi::IvectorExtractorOptions", a[0]);
  ::kaldi::FullGmm* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_with_params", names[1], "::kaldi::FullGmm", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::IvectorExtractor> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::IvectorExtractor>(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_ivector_distribution(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix)
static PyObject* wrapGetIvectorDistribution_as_get_ivector_distribution(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("utt_stats"),
      C("mean"),
      C("var"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_ivector_distribution", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_ivector_distribution", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_ivector_distribution", names[1], "::kaldi::VectorBase<double> *", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_ivector_distribution", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetIvectorDistribution(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// prior_offset() -> float
static PyObject* wrapPriorOffset_as_prior_offset(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->PriorOffset();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_auxf(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float
static PyObject* wrapGetAuxf_as_get_auxf(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("utt_stats"),
      C("mean"),
      C("var"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:get_auxf", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_auxf", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_auxf", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (::kaldi::SpMatrix<double> *)nullptr;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_auxf", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = c->GetAuxf(*arg1, *arg2); break;
  case 3:
    ret0 = c->GetAuxf(*arg1, *arg2, arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_prior_auxf(mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float
static PyObject* wrapGetPriorAuxf_as_get_prior_auxf(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("mean"),
      C("var"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:get_prior_auxf", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_prior_auxf", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::SpMatrix<double> * arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (::kaldi::SpMatrix<double> *)nullptr;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_prior_auxf", names[1], "::kaldi::SpMatrix<double> *", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->GetPriorAuxf(*arg1); break;
  case 2:
    ret0 = c->GetPriorAuxf(*arg1, arg2); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_acoustic_auxf_variance(utt_stats:IvectorExtractorUtteranceStats) -> float
static PyObject* wrapGetAcousticAuxfVariance_as_get_acoustic_auxf_variance(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("utt_stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_acoustic_auxf_variance", names, &a[0])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_acoustic_auxf_variance", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetAcousticAuxfVariance(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_acoustic_auxf_mean(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float
static PyObject* wrapGetAcousticAuxfMean_as_get_acoustic_auxf_mean(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("utt_stats"),
      C("mean"),
      C("var"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:get_acoustic_auxf_mean", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_acoustic_auxf_mean", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_acoustic_auxf_mean", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (::kaldi::SpMatrix<double> *)nullptr;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_acoustic_auxf_mean", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = c->GetAcousticAuxfMean(*arg1, *arg2); break;
  case 3:
    ret0 = c->GetAcousticAuxfMean(*arg1, *arg2, arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_acoustic_auxf_gconst(utt_stats:IvectorExtractorUtteranceStats) -> float
static PyObject* wrapGetAcousticAuxfGconst_as_get_acoustic_auxf_gconst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("utt_stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_acoustic_auxf_gconst", names, &a[0])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_acoustic_auxf_gconst", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetAcousticAuxfGconst(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_acoustic_auxf_weight(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float
static PyObject* wrapGetAcousticAuxfWeight_as_get_acoustic_auxf_weight(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("utt_stats"),
      C("mean"),
      C("var"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:get_acoustic_auxf_weight", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_acoustic_auxf_weight", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_acoustic_auxf_weight", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (::kaldi::SpMatrix<double> *)nullptr;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_acoustic_auxf_weight", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = c->GetAcousticAuxfWeight(*arg1, *arg2); break;
  case 3:
    ret0 = c->GetAcousticAuxfWeight(*arg1, *arg2, arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_ivector_dist_mean(utt_stats:IvectorExtractorUtteranceStats, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)
static PyObject* wrapGetIvectorDistMean_as_get_ivector_dist_mean(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("utt_stats"),
      C("linear"),
      C("quadratic"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_ivector_dist_mean", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_ivector_dist_mean", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_ivector_dist_mean", names[1], "::kaldi::VectorBase<double> *", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_ivector_dist_mean", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetIvectorDistMean(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_ivector_dist_prior(utt_stats:IvectorExtractorUtteranceStats, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)
static PyObject* wrapGetIvectorDistPrior_as_get_ivector_dist_prior(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("utt_stats"),
      C("linear"),
      C("quadratic"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_ivector_dist_prior", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_ivector_dist_prior", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_ivector_dist_prior", names[1], "::kaldi::VectorBase<double> *", a[1]);
  ::kaldi::SpMatrix<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_ivector_dist_prior", names[2], "::kaldi::SpMatrix<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetIvectorDistPrior(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_ivector_dist_weight(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)
static PyObject* wrapGetIvectorDistWeight_as_get_ivector_dist_weight(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("utt_stats"),
      C("mean"),
      C("linear"),
      C("quadratic"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:get_ivector_dist_weight", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::IvectorExtractorUtteranceStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_ivector_dist_weight", names[0], "::kaldi::IvectorExtractorUtteranceStats", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_ivector_dist_weight", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::VectorBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_ivector_dist_weight", names[2], "::kaldi::VectorBase<double> *", a[2]);
  ::kaldi::SpMatrix<double> * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_ivector_dist_weight", names[3], "::kaldi::SpMatrix<double> *", a[3]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetIvectorDistWeight(*arg1, *arg2, arg3, arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// feat_dim() -> int
static PyObject* wrapFeatDim_as_feat_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FeatDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// ivector_dim() -> int
static PyObject* wrapIvectorDim_as_ivector_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IvectorDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_gauss() -> int
static PyObject* wrapNumGauss_as_num_gauss(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumGauss();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// ivector_dependent_weights() -> bool
static PyObject* wrapIvectorDependentWeights_as_ivector_dependent_weights(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IvectorDependentWeights();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(os:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("new_with_params"), (PyCFunction)wrapIvectorExtractor_as_new_with_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new_with_params(opts:IvectorExtractorOptions, fgmm:FullGmm) -> IvectorExtractor\n  Calls C++ function\n  std::unique_ptr<::kaldi::IvectorExtractor> ::kaldi::IvectorExtractor::IvectorExtractor(::kaldi::IvectorExtractorOptions, ::kaldi::FullGmm)")},
  {C("get_ivector_distribution"), (PyCFunction)wrapGetIvectorDistribution_as_get_ivector_distribution, METH_VARARGS | METH_KEYWORDS, C("get_ivector_distribution(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix)\n\nGets the distribution over ivectors (or the Gaussian approximation).\n\nArgs:\n  utt_stats (:class:`IvectorExtractorUtteranceStats`): stats for a particular utterance\n  mean (:class:`kaldi.matrix.VectorBase`): output means \n  var (:class::`kaldi.matrix.packed.SpMatrix`): None if not needed, else must be the correct dimension (:meth:`ivector_dim`)")},
  {C("prior_offset"), (PyCFunction)wrapPriorOffset_as_prior_offset, METH_NOARGS, C("prior_offset() -> float\n\nOffset of first dimension.")},
  {C("get_auxf"), (PyCFunction)wrapGetAuxf_as_get_auxf, METH_VARARGS | METH_KEYWORDS, C("get_auxf(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float\n\nReturns the data-dependent part of the log-likelihood objective function, summed over frames.")},
  {C("get_prior_auxf"), (PyCFunction)wrapGetPriorAuxf_as_get_prior_auxf, METH_VARARGS | METH_KEYWORDS, C("get_prior_auxf(mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float\n\nReturns the prior-related part of the log-likelihood objective function.")},
  {C("get_acoustic_auxf_variance"), (PyCFunction)wrapGetAcousticAuxfVariance_as_get_acoustic_auxf_variance, METH_VARARGS | METH_KEYWORDS, C("get_acoustic_auxf_variance(utt_stats:IvectorExtractorUtteranceStats) -> float\n\nReturns just the part of the acoustic auxf that relates to the variance of the utt_stats.")},
  {C("get_acoustic_auxf_mean"), (PyCFunction)wrapGetAcousticAuxfMean_as_get_acoustic_auxf_mean, METH_VARARGS | METH_KEYWORDS, C("get_acoustic_auxf_mean(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float\n\nReturns just the part of the acoustic auxf that relates to the speaker-dependent means")},
  {C("get_acoustic_auxf_gconst"), (PyCFunction)wrapGetAcousticAuxfGconst_as_get_acoustic_auxf_gconst, METH_VARARGS | METH_KEYWORDS, C("get_acoustic_auxf_gconst(utt_stats:IvectorExtractorUtteranceStats) -> float\n\nReturns the part of the acoustic auxf that relates to the gconsts of the Gaussian.")},
  {C("get_acoustic_auxf_weight"), (PyCFunction)wrapGetAcousticAuxfWeight_as_get_acoustic_auxf_weight, METH_VARARGS | METH_KEYWORDS, C("get_acoustic_auxf_weight(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, var:DoubleSpMatrix=default) -> float\n\nReturns the part of the acoustic auxf that relates to the Gaussian-specific weights.")},
  {C("get_ivector_dist_mean"), (PyCFunction)wrapGetIvectorDistMean_as_get_ivector_dist_mean, METH_VARARGS | METH_KEYWORDS, C("get_ivector_dist_mean(utt_stats:IvectorExtractorUtteranceStats, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)\n\nGet the linear and quadratic terms in the distribution over iVectors")},
  {C("get_ivector_dist_prior"), (PyCFunction)wrapGetIvectorDistPrior_as_get_ivector_dist_prior, METH_VARARGS | METH_KEYWORDS, C("get_ivector_dist_prior(utt_stats:IvectorExtractorUtteranceStats, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)\n\nGets the linear and quadratic terms in the distribution over iVectors that arise from the prior.")},
  {C("get_ivector_dist_weight"), (PyCFunction)wrapGetIvectorDistWeight_as_get_ivector_dist_weight, METH_VARARGS | METH_KEYWORDS, C("get_ivector_dist_weight(utt_stats:IvectorExtractorUtteranceStats, mean:DoubleVectorBase, linear:DoubleVectorBase, quadratic:DoubleSpMatrix)\n\nGets the linear and quadratic terms in the distribution over iVectors that arise from the weights")},
  {C("feat_dim"), (PyCFunction)wrapFeatDim_as_feat_dim, METH_NOARGS, C("feat_dim() -> int\n  Calls C++ function\n  int ::kaldi::IvectorExtractor::FeatDim()")},
  {C("ivector_dim"), (PyCFunction)wrapIvectorDim_as_ivector_dim, METH_NOARGS, C("ivector_dim() -> int\n  Calls C++ function\n  int ::kaldi::IvectorExtractor::IvectorDim()")},
  {C("num_gauss"), (PyCFunction)wrapNumGauss_as_num_gauss, METH_NOARGS, C("num_gauss() -> int\n  Calls C++ function\n  int ::kaldi::IvectorExtractor::NumGauss()")},
  {C("ivector_dependent_weights"), (PyCFunction)wrapIvectorDependentWeights_as_ivector_dependent_weights, METH_NOARGS, C("ivector_dependent_weights() -> bool\n  Calls C++ function\n  bool ::kaldi::IvectorExtractor::IvectorDependentWeights()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::IvectorExtractor::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(os:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::IvectorExtractor::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// IvectorExtractor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorExtractor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::IvectorExtractor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorExtractor takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractor>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractor"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractor* c = static_cast<::kaldi::IvectorExtractor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractor

namespace pyOnlineIvectorEstimationStats {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OnlineIvectorEstimationStats> cpp;
};
static ::kaldi::OnlineIvectorEstimationStats* ThisPtr(PyObject*);

// @classmethod new_with_params(ivector_dim:int, prior_offset:float, max_count:float) -> OnlineIvectorEstimationStats
static PyObject* wrapOnlineIvectorEstimationStats_as_new_with_params(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("ivector_dim"),
      C("prior_offset"),
      C("max_count"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:new_with_params", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_with_params", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_with_params", names[1], "float", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("new_with_params", names[2], "float", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::OnlineIvectorEstimationStats> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::OnlineIvectorEstimationStats>(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod new_with_other(other:OnlineIvectorEstimationStats) -> OnlineIvectorEstimationStats
static PyObject* wrapOnlineIvectorEstimationStats_as_new_with_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:new_with_other", names, &a[0])) return nullptr;
  ::kaldi::OnlineIvectorEstimationStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_with_other", names[0], "::kaldi::OnlineIvectorEstimationStats", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::OnlineIvectorEstimationStats> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::OnlineIvectorEstimationStats>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// acc_stats(extractor:IvectorExtractor, feature:VectorBase, gauss_post:list<tuple<int, float>>)
static PyObject* wrapAccStats_as_acc_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("extractor"),
      C("feature"),
      C("gauss_post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:acc_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::IvectorExtractor* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("acc_stats", names[0], "::kaldi::IvectorExtractor", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("acc_stats", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> > arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("acc_stats", names[2], "::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >", a[2]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AccStats(*arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// ivector_dim() -> int
static PyObject* wrapIvectorDim_as_ivector_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IvectorDim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_ivector(num_cg_iters:int, ivector:DoubleVectorBase)
static PyObject* wrapGetIvector_as_get_ivector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("num_cg_iters"),
      C("ivector"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_ivector", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_ivector", names[0], "int", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_ivector", names[1], "::kaldi::VectorBase<double> *", a[1]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetIvector(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_frames() -> float
static PyObject* wrapNumFrames_as_num_frames(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumFrames();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prior_offset() -> float
static PyObject* wrapPriorOffset_as_prior_offset(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->PriorOffset();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// objf_change(ivector:DoubleVectorBase) -> float
static PyObject* wrapObjfChange_as_objf_change(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ivector"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:objf_change", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("objf_change", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ObjfChange(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// count() -> float
static PyObject* wrapCount_as_count(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Count();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// scale(scale:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(os:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::OnlineIvectorEstimationStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("new_with_params"), (PyCFunction)wrapOnlineIvectorEstimationStats_as_new_with_params, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new_with_params(ivector_dim:int, prior_offset:float, max_count:float) -> OnlineIvectorEstimationStats\n  Calls C++ function\n  std::unique_ptr<::kaldi::OnlineIvectorEstimationStats> ::kaldi::OnlineIvectorEstimationStats::OnlineIvectorEstimationStats(int, float, float)")},
  {C("new_with_other"), (PyCFunction)wrapOnlineIvectorEstimationStats_as_new_with_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new_with_other(other:OnlineIvectorEstimationStats) -> OnlineIvectorEstimationStats\n  Calls C++ function\n  std::unique_ptr<::kaldi::OnlineIvectorEstimationStats> ::kaldi::OnlineIvectorEstimationStats::OnlineIvectorEstimationStats(::kaldi::OnlineIvectorEstimationStats)")},
  {C("acc_stats"), (PyCFunction)wrapAccStats_as_acc_stats, METH_VARARGS | METH_KEYWORDS, C("acc_stats(extractor:IvectorExtractor, feature:VectorBase, gauss_post:list<tuple<int, float>>)\n  Calls C++ function\n  void ::kaldi::OnlineIvectorEstimationStats::AccStats(::kaldi::IvectorExtractor, ::kaldi::VectorBase<float>, ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >)")},
  {C("ivector_dim"), (PyCFunction)wrapIvectorDim_as_ivector_dim, METH_NOARGS, C("ivector_dim() -> int\n  Calls C++ function\n  int ::kaldi::OnlineIvectorEstimationStats::IvectorDim()")},
  {C("get_ivector"), (PyCFunction)wrapGetIvector_as_get_ivector, METH_VARARGS | METH_KEYWORDS, C("get_ivector(num_cg_iters:int, ivector:DoubleVectorBase)\n\nGets the current estimate of the iVector.")},
  {C("num_frames"), (PyCFunction)wrapNumFrames_as_num_frames, METH_NOARGS, C("num_frames() -> float\n  Calls C++ function\n  double ::kaldi::OnlineIvectorEstimationStats::NumFrames()")},
  {C("prior_offset"), (PyCFunction)wrapPriorOffset_as_prior_offset, METH_NOARGS, C("prior_offset() -> float\n  Calls C++ function\n  double ::kaldi::OnlineIvectorEstimationStats::PriorOffset()")},
  {C("objf_change"), (PyCFunction)wrapObjfChange_as_objf_change, METH_VARARGS | METH_KEYWORDS, C("objf_change(ivector:DoubleVectorBase) -> float\n\nReturns the change in objective function per frame from using the default value.")},
  {C("count"), (PyCFunction)wrapCount_as_count, METH_NOARGS, C("count() -> float\n  Calls C++ function\n  double ::kaldi::OnlineIvectorEstimationStats::Count()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(scale:float)\n  Calls C++ function\n  void ::kaldi::OnlineIvectorEstimationStats::Scale(double)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::OnlineIvectorEstimationStats::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(os:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::OnlineIvectorEstimationStats::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// OnlineIvectorEstimationStats __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OnlineIvectorEstimationStats __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.OnlineIvectorEstimationStats", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::OnlineIvectorEstimationStats", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OnlineIvectorEstimationStats* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OnlineIvectorEstimationStats"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OnlineIvectorEstimationStats"));
      if (!PyErr_Occurred()) {
        ::kaldi::OnlineIvectorEstimationStats* c = static_cast<::kaldi::OnlineIvectorEstimationStats*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OnlineIvectorEstimationStats*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOnlineIvectorEstimationStats

// estimate_ivectors_online(feats:Matrix, post:list<list<tuple<int, float>>>, extractor:IvectorExtractor, ivector_period:int, num_cg_iters:int, max_count:float) -> (objf_improvement:float, ivectors:Matrix)
static PyObject* wrapEstimateIvectorsOnline_as_estimate_ivectors_online(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("feats"),
      C("post"),
      C("extractor"),
      C("ivector_period"),
      C("num_cg_iters"),
      C("max_count"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:estimate_ivectors_online", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::Matrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("estimate_ivectors_online", names[0], "::kaldi::Matrix<float>", a[0]);
  ::kaldi::Posterior arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("estimate_ivectors_online", names[1], "::kaldi::Posterior", a[1]);
  ::kaldi::IvectorExtractor* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("estimate_ivectors_online", names[2], "::kaldi::IvectorExtractor", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("estimate_ivectors_online", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("estimate_ivectors_online", names[4], "int", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("estimate_ivectors_online", names[5], "float", a[5]);
  ::kaldi::Matrix<float> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::EstimateIvectorsOnline(*arg1, std::move(arg2), *arg3, std::move(arg4), std::move(arg5), std::move(arg6), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

namespace pyIvectorExtractorStatsOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractorStatsOptions> cpp;
};
static ::kaldi::IvectorExtractorStatsOptions* ThisPtr(PyObject*);

static PyObject* get_update_variances(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->update_variances, {});
}

static int set_update_variances(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the update_variances attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->update_variances)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for update_variances:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_compute_auxf(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->compute_auxf, {});
}

static int set_compute_auxf(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the compute_auxf attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->compute_auxf)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for compute_auxf:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_samples_for_weights(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_samples_for_weights, {});
}

static int set_num_samples_for_weights(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_samples_for_weights attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_samples_for_weights)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_samples_for_weights:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cache_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->cache_size, {});
}

static int set_cache_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cache_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cache_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cache_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStatsOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("update_variances"), get_update_variances, set_update_variances, C("C++ bool IvectorExtractorStatsOptions.update_variances")},
  {C("compute_auxf"), get_compute_auxf, set_compute_auxf, C("C++ bool IvectorExtractorStatsOptions.compute_auxf")},
  {C("num_samples_for_weights"), get_num_samples_for_weights, set_num_samples_for_weights, C("C++ ::int32 IvectorExtractorStatsOptions.num_samples_for_weights")},
  {C("cache_size"), get_cache_size, set_cache_size, C("C++ int IvectorExtractorStatsOptions.cache_size")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorStatsOptions::Register(::kaldi::OptionsItf *)")},
  {}
};

// IvectorExtractorStatsOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorExtractorStatsOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractorStatsOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractorStatsOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::IvectorExtractorStatsOptions", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorExtractorStatsOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorStatsOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractorStatsOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractorStatsOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractorStatsOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractorStatsOptions* c = static_cast<::kaldi::IvectorExtractorStatsOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractorStatsOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractorStatsOptions

namespace pyIvectorExtractorEstimationOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractorEstimationOptions> cpp;
};
static ::kaldi::IvectorExtractorEstimationOptions* ThisPtr(PyObject*);

static PyObject* get_variance_floor_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->variance_floor_factor, {});
}

static int set_variance_floor_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the variance_floor_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->variance_floor_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for variance_floor_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_gaussian_min_count(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->gaussian_min_count, {});
}

static int set_gaussian_min_count(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the gaussian_min_count attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->gaussian_min_count)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for gaussian_min_count:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_threads(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_threads, {});
}

static int set_num_threads(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_threads attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_threads)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_threads:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_diagonalize(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->diagonalize, {});
}

static int set_diagonalize(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the diagonalize attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->diagonalize)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for diagonalize:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorEstimationOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("variance_floor_factor"), get_variance_floor_factor, set_variance_floor_factor, C("C++ double IvectorExtractorEstimationOptions.variance_floor_factor")},
  {C("gaussian_min_count"), get_gaussian_min_count, set_gaussian_min_count, C("C++ double IvectorExtractorEstimationOptions.gaussian_min_count")},
  {C("num_threads"), get_num_threads, set_num_threads, C("C++ ::int32 IvectorExtractorEstimationOptions.num_threads")},
  {C("diagonalize"), get_diagonalize, set_diagonalize, C("C++ bool IvectorExtractorEstimationOptions.diagonalize")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorEstimationOptions::Register(::kaldi::OptionsItf *)")},
  {}
};

// IvectorExtractorEstimationOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorExtractorEstimationOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractorEstimationOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractorEstimationOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::IvectorExtractorEstimationOptions", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorExtractorEstimationOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorEstimationOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractorEstimationOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractorEstimationOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractorEstimationOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractorEstimationOptions* c = static_cast<::kaldi::IvectorExtractorEstimationOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractorEstimationOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractorEstimationOptions

namespace pyIvectorExtractorStats {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::IvectorExtractorStats> cpp;
};
static ::kaldi::IvectorExtractorStats* ThisPtr(PyObject*);

// @classmethod new(extractor:IvectorExtractor, stats_opts:IvectorExtractorStatsOptions) -> IvectorExtractorStats
static PyObject* wrapIvectorExtractorStats_as_new(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("extractor"),
      C("stats_opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:new", names, &a[0], &a[1])) return nullptr;
  ::kaldi::IvectorExtractor* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new", names[0], "::kaldi::IvectorExtractor", a[0]);
  ::kaldi::IvectorExtractorStatsOptions* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new", names[1], "::kaldi::IvectorExtractorStatsOptions", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::IvectorExtractorStats> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::IvectorExtractorStats>(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add(other:IvectorExtractorStats)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add", names, &a[0])) return nullptr;
  ::kaldi::IvectorExtractorStats* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "::kaldi::IvectorExtractorStats", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// acc_stats_for_utterance(extractor:IvectorExtractor, feats:MatrixBase, post:list<list<tuple<int, float>>>)
static PyObject* wrapAccStatsForUtterance_as_acc_stats_for_utterance(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("extractor"),
      C("feats"),
      C("post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:acc_stats_for_utterance", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::IvectorExtractor* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("acc_stats_for_utterance", names[0], "::kaldi::IvectorExtractor", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("acc_stats_for_utterance", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::Posterior arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("acc_stats_for_utterance", names[2], "::kaldi::Posterior", a[2]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AccStatsForUtterance(*arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(os:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// update(opts:IvectorExtractorEstimationOptions, extractor:IvectorExtractor) -> float
static PyObject* wrapUpdate_as_update(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("opts"),
      C("extractor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:update", names, &a[0], &a[1])) return nullptr;
  ::kaldi::IvectorExtractorEstimationOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("update", names[0], "::kaldi::IvectorExtractorEstimationOptions", a[0]);
  ::kaldi::IvectorExtractor * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("update", names[1], "::kaldi::IvectorExtractor *", a[1]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Update(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// auxf_per_frame() -> float
static PyObject* wrapAuxfPerFrame_as_auxf_per_frame(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->AuxfPerFrame();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// ivector_variance_diagnostic(extractor:IvectorExtractor)
static PyObject* wrapIvectorVarianceDiagnostic_as_ivector_variance_diagnostic(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("extractor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:ivector_variance_diagnostic", names, &a[0])) return nullptr;
  ::kaldi::IvectorExtractor* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("ivector_variance_diagnostic", names[0], "::kaldi::IvectorExtractor", a[0]);
  // Call actual C++ method.
  ::kaldi::IvectorExtractorStats* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->IvectorVarianceDiagnostic(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("new"), (PyCFunction)wrapIvectorExtractorStats_as_new, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("new(extractor:IvectorExtractor, stats_opts:IvectorExtractorStatsOptions) -> IvectorExtractorStats\n  Calls C++ function\n  std::unique_ptr<::kaldi::IvectorExtractorStats> ::kaldi::IvectorExtractorStats::IvectorExtractorStats(::kaldi::IvectorExtractor, ::kaldi::IvectorExtractorStatsOptions)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(other:IvectorExtractorStats)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorStats::Add(::kaldi::IvectorExtractorStats)")},
  {C("acc_stats_for_utterance"), (PyCFunction)wrapAccStatsForUtterance_as_acc_stats_for_utterance, METH_VARARGS | METH_KEYWORDS, C("acc_stats_for_utterance(extractor:IvectorExtractor, feats:MatrixBase, post:list<list<tuple<int, float>>>)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorStats::AccStatsForUtterance(::kaldi::IvectorExtractor, ::kaldi::MatrixBase<float>, ::kaldi::Posterior)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorStats::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(os:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::IvectorExtractorStats::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("update"), (PyCFunction)wrapUpdate_as_update, METH_VARARGS | METH_KEYWORDS, C("update(opts:IvectorExtractorEstimationOptions, extractor:IvectorExtractor) -> float\n\nReturns the objf improvement per frame")},
  {C("auxf_per_frame"), (PyCFunction)wrapAuxfPerFrame_as_auxf_per_frame, METH_NOARGS, C("auxf_per_frame() -> float\n  Calls C++ function\n  double ::kaldi::IvectorExtractorStats::AuxfPerFrame()")},
  {C("ivector_variance_diagnostic"), (PyCFunction)wrapIvectorVarianceDiagnostic_as_ivector_variance_diagnostic, METH_VARARGS | METH_KEYWORDS, C("ivector_variance_diagnostic(extractor:IvectorExtractor)\n\nPrints the proportion of the variance explained by the Ivector model versus the Gaussians.")},
  {}
};

// IvectorExtractorStats __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IvectorExtractorStats __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IvectorExtractorStats __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_ivector_extractor.IvectorExtractorStats", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::IvectorExtractorStats", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IvectorExtractorStats takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorStats>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::IvectorExtractorStats* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_IvectorExtractorStats"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::IvectorExtractorStats"));
      if (!PyErr_Occurred()) {
        ::kaldi::IvectorExtractorStats* c = static_cast<::kaldi::IvectorExtractorStats*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::IvectorExtractorStats*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIvectorExtractorStats


// Initialize module

static PyMethodDef Methods[] = {
  {C("estimate_ivectors_online"), (PyCFunction)wrapEstimateIvectorsOnline_as_estimate_ivectors_online, METH_VARARGS | METH_KEYWORDS, C("estimate_ivectors_online(feats:Matrix, post:list<list<tuple<int, float>>>, extractor:IvectorExtractor, ivector_period:int, num_cg_iters:int, max_count:float) -> (objf_improvement:float, ivectors:Matrix)\n\nObtains periodically an estimate of the iVector including all frames up to that point.")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyIvectorEstimationOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorEstimationOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractorUtteranceStats::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractorUtteranceStats::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractorOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractorOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractor::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyOnlineIvectorEstimationStats::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOnlineIvectorEstimationStats::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractorStatsOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractorStatsOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractorEstimationOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractorEstimationOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIvectorExtractorStats::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIvectorExtractorStats::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_ivector_extractor",  // module name
  "CLIF-generated module for ivector/ivector-extractor.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sp_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_full_gmm")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "IvectorEstimationOptions", reinterpret_cast<PyObject*>(&pyIvectorEstimationOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractorUtteranceStats", reinterpret_cast<PyObject*>(&pyIvectorExtractorUtteranceStats::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractorOptions", reinterpret_cast<PyObject*>(&pyIvectorExtractorOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractor", reinterpret_cast<PyObject*>(&pyIvectorExtractor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OnlineIvectorEstimationStats", reinterpret_cast<PyObject*>(&pyOnlineIvectorEstimationStats::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractorStatsOptions", reinterpret_cast<PyObject*>(&pyIvectorExtractorStatsOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractorEstimationOptions", reinterpret_cast<PyObject*>(&pyIvectorExtractorEstimationOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IvectorExtractorStats", reinterpret_cast<PyObject*>(&pyIvectorExtractorStats::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __ivector__extractor_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// IvectorEstimationOptions to/from ::kaldi::IvectorEstimationOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorEstimationOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorEstimationOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorEstimationOptions* c) {
  assert(c != nullptr);
  ::kaldi::IvectorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorEstimationOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorEstimationOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorEstimationOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorEstimationOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorEstimationOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorEstimationOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorEstimationOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorEstimationOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorEstimationOptions>(c);
  return py;
}

// IvectorExtractor to/from ::kaldi::IvectorExtractor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractor* cpp = __ivector__extractor_clifwrap::pyIvectorExtractor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractor>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractor* cpp = __ivector__extractor_clifwrap::pyIvectorExtractor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractor>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractor* cpp = __ivector__extractor_clifwrap::pyIvectorExtractor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractor* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractor* cpp = __ivector__extractor_clifwrap::pyIvectorExtractor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorExtractor>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractor* cpp = __ivector__extractor_clifwrap::pyIvectorExtractor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorExtractor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractor>(c);
  return py;
}

// IvectorExtractorEstimationOptions to/from ::kaldi::IvectorExtractorEstimationOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorEstimationOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractorEstimationOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorEstimationOptions* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorExtractorEstimationOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorEstimationOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractorEstimationOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorEstimationOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractorEstimationOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorEstimationOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractorEstimationOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorEstimationOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorExtractorEstimationOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorEstimationOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorEstimationOptions>(c);
  return py;
}

// IvectorExtractorOptions to/from ::kaldi::IvectorExtractorOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractorOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractorOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorOptions* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorExtractorOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractorOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractorOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractorOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorExtractorOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorOptions>(c);
  return py;
}

// IvectorExtractorStats to/from ::kaldi::IvectorExtractorStats conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorStats** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractorStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractorStats>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractorStats>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractorStats instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractorStats* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStats>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractorStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStats>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractorStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStats>(std::move(c));
  return py;
}

// IvectorExtractorStatsOptions to/from ::kaldi::IvectorExtractorStatsOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorStatsOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractorStatsOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractorStatsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStatsOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractorStatsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStatsOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractorStatsOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorStatsOptions* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStatsOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorExtractorStatsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorStatsOptions* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractorStatsOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStatsOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractorStatsOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStatsOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractorStatsOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorStatsOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorExtractorStatsOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorStatsOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorStatsOptions>(c);
  return py;
}

// IvectorExtractorUtteranceStats to/from ::kaldi::IvectorExtractorUtteranceStats conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorUtteranceStats** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::IvectorExtractorUtteranceStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::IvectorExtractorUtteranceStats>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorUtteranceStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::IvectorExtractorUtteranceStats>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorUtteranceStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IvectorExtractorUtteranceStats instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::IvectorExtractorUtteranceStats* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorUtteranceStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::IvectorExtractorUtteranceStats>* c) {
  assert(c != nullptr);
  ::kaldi::IvectorExtractorUtteranceStats* cpp = __ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::IvectorExtractorUtteranceStats* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorUtteranceStats>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::IvectorExtractorUtteranceStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorUtteranceStats>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::IvectorExtractorUtteranceStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::IvectorExtractorUtteranceStats>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::IvectorExtractorUtteranceStats& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyIvectorExtractorUtteranceStats::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::IvectorExtractorUtteranceStats>(c);
  return py;
}

// OnlineIvectorEstimationStats to/from ::kaldi::OnlineIvectorEstimationStats conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineIvectorEstimationStats** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OnlineIvectorEstimationStats* cpp = __ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OnlineIvectorEstimationStats>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineIvectorEstimationStats* cpp = __ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OnlineIvectorEstimationStats>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineIvectorEstimationStats* cpp = __ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OnlineIvectorEstimationStats instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineIvectorEstimationStats* c) {
  assert(c != nullptr);
  ::kaldi::OnlineIvectorEstimationStats* cpp = __ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::OnlineIvectorEstimationStats>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineIvectorEstimationStats* cpp = __ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OnlineIvectorEstimationStats* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineIvectorEstimationStats>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OnlineIvectorEstimationStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineIvectorEstimationStats>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OnlineIvectorEstimationStats> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineIvectorEstimationStats>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::OnlineIvectorEstimationStats& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper_Type, NULL, NULL);
  reinterpret_cast<__ivector__extractor_clifwrap::pyOnlineIvectorEstimationStats::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::OnlineIvectorEstimationStats>(c);
  return py;
}

}  // namespace kaldi
