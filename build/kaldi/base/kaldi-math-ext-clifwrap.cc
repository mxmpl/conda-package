//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/base/kaldi-math-ext.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/kaldi-math-clifwrap.h"
#include "kaldi-math-ext-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__math__ext_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// isnan(arg:float) -> bool
static PyObject* wrapFLOAT_KALDI_ISNAN_as_isnan(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:isnan", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("isnan", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::FLOAT_KALDI_ISNAN(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_isnan(arg:float) -> bool
static PyObject* wrapDOUBLE_KALDI_ISNAN_as_double_isnan(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_isnan", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_isnan", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::DOUBLE_KALDI_ISNAN(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// isinf(arg:float) -> bool
static PyObject* wrapFLOAT_KALDI_ISINF_as_isinf(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:isinf", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("isinf", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::FLOAT_KALDI_ISINF(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_isinf(arg:float) -> bool
static PyObject* wrapDOUBLE_KALDI_ISINF_as_double_isinf(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_isinf", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_isinf", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::DOUBLE_KALDI_ISINF(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// isfinite(arg:float) -> bool
static PyObject* wrapFLOAT_KALDI_ISFINITE_as_isfinite(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:isfinite", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("isfinite", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::FLOAT_KALDI_ISFINITE(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_isfinite(arg:float) -> bool
static PyObject* wrapDOUBLE_KALDI_ISFINITE_as_double_isfinite(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arg"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_isfinite", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_isfinite", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::DOUBLE_KALDI_ISFINITE(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sqr(x:float) -> float
static PyObject* wrapFLOAT_KALDI_SQR_as_sqr(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sqr", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sqr", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::FLOAT_KALDI_SQR(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_sqr(x:float) -> float
static PyObject* wrapDOUBLE_KALDI_SQR_as_double_sqr(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_sqr", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_sqr", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::DOUBLE_KALDI_SQR(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_zero_float() -> float
static PyObject* wrapGetkLogZeroFloat_as_log_zero_float(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::GetkLogZeroFloat();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_zero_double() -> float
static PyObject* wrapGetkLogZeroDouble_as_log_zero_double(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::GetkLogZeroDouble();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// exp(x:float) -> float
static PyObject* wrapFloatExp_as_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:exp", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("exp", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatExp(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_exp(x:float) -> float
static PyObject* wrapDoubleExp_as_double_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_exp", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_exp", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleExp(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log(x:float) -> float
static PyObject* wrapFloatLog_as_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:log", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatLog(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_log(x:float) -> float
static PyObject* wrapDoubleLog_as_double_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_log", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_log", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleLog(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log1p(x:float) -> float
static PyObject* wrapFloatLog1p_as_log1p(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:log1p", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log1p", names[0], "float", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatLog1p(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_log1p(x:float) -> float
static PyObject* wrapDoubleLog1p_as_double_log1p(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:double_log1p", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_log1p", names[0], "double", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleLog1p(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_add(x:float, y:float) -> float
static PyObject* wrapFloatLogAdd_as_log_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:log_add", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_add", names[0], "float", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("log_add", names[1], "float", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatLogAdd(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_log_add(x:float, y:float) -> float
static PyObject* wrapDoubleLogAdd_as_double_log_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:double_log_add", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_log_add", names[0], "double", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("double_log_add", names[1], "double", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleLogAdd(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_sub(x:float, y:float) -> float
static PyObject* wrapFloatLogSub_as_log_sub(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:log_sub", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_sub", names[0], "float", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("log_sub", names[1], "float", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatLogSub(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_log_sub(x:float, y:float) -> float
static PyObject* wrapDoubleLogSub_as_double_log_sub(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:double_log_sub", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_log_sub", names[0], "double", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("double_log_sub", names[1], "double", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleLogSub(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// hypot(x:float, y:float) -> float
static PyObject* wrapFloatHypot_as_hypot(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:hypot", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("hypot", names[0], "float", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("hypot", names[1], "float", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::FloatHypot(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// double_hypot(x:float, y:float) -> float
static PyObject* wrapDoubleHypot_as_double_hypot(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:double_hypot", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("double_hypot", names[0], "double", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("double_hypot", names[1], "double", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::DoubleHypot(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("isnan"), (PyCFunction)wrapFLOAT_KALDI_ISNAN_as_isnan, METH_VARARGS | METH_KEYWORDS, C("isnan(arg:float) -> bool\n  Calls C++ function\n  bool ::FLOAT_KALDI_ISNAN(float)")},
  {C("double_isnan"), (PyCFunction)wrapDOUBLE_KALDI_ISNAN_as_double_isnan, METH_VARARGS | METH_KEYWORDS, C("double_isnan(arg:float) -> bool\n  Calls C++ function\n  bool ::DOUBLE_KALDI_ISNAN(double)")},
  {C("isinf"), (PyCFunction)wrapFLOAT_KALDI_ISINF_as_isinf, METH_VARARGS | METH_KEYWORDS, C("isinf(arg:float) -> bool\n  Calls C++ function\n  bool ::FLOAT_KALDI_ISINF(float)")},
  {C("double_isinf"), (PyCFunction)wrapDOUBLE_KALDI_ISINF_as_double_isinf, METH_VARARGS | METH_KEYWORDS, C("double_isinf(arg:float) -> bool\n  Calls C++ function\n  bool ::DOUBLE_KALDI_ISINF(double)")},
  {C("isfinite"), (PyCFunction)wrapFLOAT_KALDI_ISFINITE_as_isfinite, METH_VARARGS | METH_KEYWORDS, C("isfinite(arg:float) -> bool\n  Calls C++ function\n  bool ::FLOAT_KALDI_ISFINITE(float)")},
  {C("double_isfinite"), (PyCFunction)wrapDOUBLE_KALDI_ISFINITE_as_double_isfinite, METH_VARARGS | METH_KEYWORDS, C("double_isfinite(arg:float) -> bool\n  Calls C++ function\n  bool ::DOUBLE_KALDI_ISFINITE(double)")},
  {C("sqr"), (PyCFunction)wrapFLOAT_KALDI_SQR_as_sqr, METH_VARARGS | METH_KEYWORDS, C("sqr(x:float) -> float\n  Calls C++ function\n  float ::FLOAT_KALDI_SQR(float)")},
  {C("double_sqr"), (PyCFunction)wrapDOUBLE_KALDI_SQR_as_double_sqr, METH_VARARGS | METH_KEYWORDS, C("double_sqr(x:float) -> float\n  Calls C++ function\n  double ::DOUBLE_KALDI_SQR(double)")},
  {C("log_zero_float"), (PyCFunction)wrapGetkLogZeroFloat_as_log_zero_float, METH_NOARGS, C("log_zero_float() -> float\n  Calls C++ function\n  float ::kaldi::GetkLogZeroFloat()")},
  {C("log_zero_double"), (PyCFunction)wrapGetkLogZeroDouble_as_log_zero_double, METH_NOARGS, C("log_zero_double() -> float\n  Calls C++ function\n  double ::kaldi::GetkLogZeroDouble()")},
  {C("exp"), (PyCFunction)wrapFloatExp_as_exp, METH_VARARGS | METH_KEYWORDS, C("exp(x:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatExp(float)")},
  {C("double_exp"), (PyCFunction)wrapDoubleExp_as_double_exp, METH_VARARGS | METH_KEYWORDS, C("double_exp(x:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleExp(double)")},
  {C("log"), (PyCFunction)wrapFloatLog_as_log, METH_VARARGS | METH_KEYWORDS, C("log(x:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatLog(float)")},
  {C("double_log"), (PyCFunction)wrapDoubleLog_as_double_log, METH_VARARGS | METH_KEYWORDS, C("double_log(x:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleLog(double)")},
  {C("log1p"), (PyCFunction)wrapFloatLog1p_as_log1p, METH_VARARGS | METH_KEYWORDS, C("log1p(x:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatLog1p(float)")},
  {C("double_log1p"), (PyCFunction)wrapDoubleLog1p_as_double_log1p, METH_VARARGS | METH_KEYWORDS, C("double_log1p(x:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleLog1p(double)")},
  {C("log_add"), (PyCFunction)wrapFloatLogAdd_as_log_add, METH_VARARGS | METH_KEYWORDS, C("log_add(x:float, y:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatLogAdd(float, float)")},
  {C("double_log_add"), (PyCFunction)wrapDoubleLogAdd_as_double_log_add, METH_VARARGS | METH_KEYWORDS, C("double_log_add(x:float, y:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleLogAdd(double, double)")},
  {C("log_sub"), (PyCFunction)wrapFloatLogSub_as_log_sub, METH_VARARGS | METH_KEYWORDS, C("log_sub(x:float, y:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatLogSub(float, float)")},
  {C("double_log_sub"), (PyCFunction)wrapDoubleLogSub_as_double_log_sub, METH_VARARGS | METH_KEYWORDS, C("double_log_sub(x:float, y:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleLogSub(double, double)")},
  {C("hypot"), (PyCFunction)wrapFloatHypot_as_hypot, METH_VARARGS | METH_KEYWORDS, C("hypot(x:float, y:float) -> float\n  Calls C++ function\n  float ::kaldi::FloatHypot(float, float)")},
  {C("double_hypot"), (PyCFunction)wrapDoubleHypot_as_double_hypot, METH_VARARGS | METH_KEYWORDS, C("double_hypot(x:float, y:float) -> float\n  Calls C++ function\n  double ::kaldi::DoubleHypot(double, double)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_math_ext",  // module name
  "CLIF-generated module for base/kaldi-math-ext.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_kaldi_math")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__math__ext_clifwrap
