//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/base/sstream.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "sstream-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __sstream_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyistringstream {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> cpp;
};
static ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject*);

// @classmethod from_str(str:str) -> istringstream
static PyObject* wrapbasic_istringstream_as_from_str(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_str", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_str", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// to_str() -> str
static PyObject* wrapstr_as_to_str(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// to_bytes() -> bytes
static PyObject* wrapstr_as_to_bytes(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::std::basic_istream<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_istream_char__std_char_traits_char(PyObject* self) {
  ::std::basic_istream<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_istream<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::basic_ios<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_ios_char__std_char_traits_char(PyObject* self) {
  ::std::basic_ios<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_ios<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::ios_base*
static PyObject* as_std_ios_base(PyObject* self) {
  ::std::ios_base* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::ios_base"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_str"), (PyCFunction)wrapbasic_istringstream_as_from_str, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_str(str:str) -> istringstream\n\nCreates a new input string stream.")},
  {C("to_str"), (PyCFunction)wrapstr_as_to_str, METH_NOARGS, C("to_str() -> str\n\nReturns stream contents as a unicode string.")},
  {C("to_bytes"), (PyCFunction)wrapstr_as_to_bytes, METH_NOARGS, C("to_bytes() -> bytes\n\nReturns stream contents as a bytes object.")},
  {C("as_std_basic_istream_char__std_char_traits_char"), (PyCFunction)as_std_basic_istream_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_istream<char, ::std::char_traits<char> >*")},
  {C("as_std_basic_ios_char__std_char_traits_char"), (PyCFunction)as_std_basic_ios_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_ios<char, ::std::char_traits<char> >*")},
  {C("as_std_ios_base"), (PyCFunction)as_std_ios_base, METH_NOARGS, C("Upcast to ::std::ios_base*")},
  {}
};

// istringstream __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// istringstream __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// istringstream __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sstream.istringstream",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Input string stream.",              // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "istringstream takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_std_basic_istringstream_char__std_char_traits_char___std_allocator_char"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >"));
      if (!PyErr_Occurred()) {
        ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = static_cast<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyistringstream

namespace pyostringstream {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> cpp;
};
static ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject*);

// @classmethod from_str(str:str) -> ostringstream
static PyObject* wrapbasic_ostringstream_as_from_str(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_str", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_str", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// to_str() -> str
static PyObject* wrapstr_as_to_str(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// to_bytes() -> bytes
static PyObject* wrapstr_as_to_bytes(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::std::basic_ostream<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_ostream_char__std_char_traits_char(PyObject* self) {
  ::std::basic_ostream<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_ostream<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::basic_ios<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_ios_char__std_char_traits_char(PyObject* self) {
  ::std::basic_ios<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_ios<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::ios_base*
static PyObject* as_std_ios_base(PyObject* self) {
  ::std::ios_base* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::ios_base"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_str"), (PyCFunction)wrapbasic_ostringstream_as_from_str, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_str(str:str) -> ostringstream\n\nCreates a new output string stream.")},
  {C("to_str"), (PyCFunction)wrapstr_as_to_str, METH_NOARGS, C("to_str() -> str\n\nReturns stream contents as a unicode string.")},
  {C("to_bytes"), (PyCFunction)wrapstr_as_to_bytes, METH_NOARGS, C("to_bytes() -> bytes\n\nReturns stream contents as a bytes object.")},
  {C("as_std_basic_ostream_char__std_char_traits_char"), (PyCFunction)as_std_basic_ostream_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_ostream<char, ::std::char_traits<char> >*")},
  {C("as_std_basic_ios_char__std_char_traits_char"), (PyCFunction)as_std_basic_ios_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_ios<char, ::std::char_traits<char> >*")},
  {C("as_std_ios_base"), (PyCFunction)as_std_ios_base, METH_NOARGS, C("Upcast to ::std::ios_base*")},
  {}
};

// ostringstream __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ostringstream __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ostringstream __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sstream.ostringstream",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Output string stream.",             // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ostringstream takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_std_basic_ostringstream_char__std_char_traits_char___std_allocator_char"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >"));
      if (!PyErr_Occurred()) {
        ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = static_cast<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyostringstream

namespace pystringstream {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> cpp;
};
static ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject*);

// @classmethod from_str(str:str) -> stringstream
static PyObject* wrapbasic_stringstream_as_from_str(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_str", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_str", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// to_str() -> str
static PyObject* wrapstr_as_to_str(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// to_bytes() -> bytes
static PyObject* wrapstr_as_to_bytes(PyObject* self) {
  // Call actual C++ method.
  ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->str();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::std::basic_iostream<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_iostream_char__std_char_traits_char(PyObject* self) {
  ::std::basic_iostream<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_iostream<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::basic_istream<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_istream_char__std_char_traits_char(PyObject* self) {
  ::std::basic_istream<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_istream<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::basic_ostream<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_ostream_char__std_char_traits_char(PyObject* self) {
  ::std::basic_ostream<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_ostream<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::basic_ios<char, ::std::char_traits<char> >*
static PyObject* as_std_basic_ios_char__std_char_traits_char(PyObject* self) {
  ::std::basic_ios<char, ::std::char_traits<char> >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::basic_ios<char, ::std::char_traits<char> >"), nullptr);
}

// Implicit cast this as ::std::ios_base*
static PyObject* as_std_ios_base(PyObject* self) {
  ::std::ios_base* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::std::ios_base"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_str"), (PyCFunction)wrapbasic_stringstream_as_from_str, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_str(str:str) -> stringstream\n\nCreates a new input/output string stream.")},
  {C("to_str"), (PyCFunction)wrapstr_as_to_str, METH_NOARGS, C("to_str() -> str\n\nReturns stream contents as a unicode string.")},
  {C("to_bytes"), (PyCFunction)wrapstr_as_to_bytes, METH_NOARGS, C("to_bytes() -> bytes\n\nReturns stream contents as a bytes object.")},
  {C("as_std_basic_iostream_char__std_char_traits_char"), (PyCFunction)as_std_basic_iostream_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_iostream<char, ::std::char_traits<char> >*")},
  {C("as_std_basic_istream_char__std_char_traits_char"), (PyCFunction)as_std_basic_istream_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_istream<char, ::std::char_traits<char> >*")},
  {C("as_std_basic_ostream_char__std_char_traits_char"), (PyCFunction)as_std_basic_ostream_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_ostream<char, ::std::char_traits<char> >*")},
  {C("as_std_basic_ios_char__std_char_traits_char"), (PyCFunction)as_std_basic_ios_char__std_char_traits_char, METH_NOARGS, C("Upcast to ::std::basic_ios<char, ::std::char_traits<char> >*")},
  {C("as_std_ios_base"), (PyCFunction)as_std_ios_base, METH_NOARGS, C("Upcast to ::std::ios_base*")},
  {}
};

// stringstream __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// stringstream __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// stringstream __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_sstream.stringstream",             // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Input/output string stream.",       // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "stringstream takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_std_basic_stringstream_char__std_char_traits_char___std_allocator_char"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >"));
      if (!PyErr_Occurred()) {
        ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c = static_cast<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pystringstream


// Initialize module

bool Ready() {
  PyObject* base_cls = ImportFQName("kaldi.base._iostream.istream");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.istream is not a new style class inheriting from object.");
    return false;
  }
  pyistringstream::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyistringstream::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.istream is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyistringstream::wrapper_Type) < 0) return false;
  Py_INCREF(&pyistringstream::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.base._iostream.ostream");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.ostream is not a new style class inheriting from object.");
    return false;
  }
  pyostringstream::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pyostringstream::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.ostream is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pyostringstream::wrapper_Type) < 0) return false;
  Py_INCREF(&pyostringstream::wrapper_Type);  // For PyModule_AddObject to steal.
  base_cls = ImportFQName("kaldi.base._iostream.iostream");
  if (base_cls == nullptr) return false;
  if (!PyObject_TypeCheck(base_cls, &PyType_Type)) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.iostream is not a new style class inheriting from object.");
    return false;
  }
  pystringstream::wrapper_Type.tp_base = reinterpret_cast<PyTypeObject*>(base_cls);
  // Check that base_cls is a *statically* allocated PyType.
  if (pystringstream::wrapper_Type.tp_base->tp_alloc == PyType_GenericAlloc) {
    Py_DECREF(base_cls);
    PyErr_SetString(PyExc_TypeError, "Base class kaldi.base._iostream.iostream is a dynamic (Python defined) class.");
    return false;
  }
  if (PyType_Ready(&pystringstream::wrapper_Type) < 0) return false;
  Py_INCREF(&pystringstream::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_sstream",  // module name
  "C++ std::sstream wrapper.\n\nThis module provides the wrappers needed for working with C++ std::sstream\ninstances. The wrappers for input and/or output stream types do not expose any\nmembers other than construction from a string and returning stream contents as\na unicode string (or bytes object) since we do not want to work with them\ndirectly in Python. They can be used for wrapping methods and functions that\naccept or return sstream objects.", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "istringstream", reinterpret_cast<PyObject*>(&pyistringstream::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ostringstream", reinterpret_cast<PyObject*>(&pyostringstream::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "stringstream", reinterpret_cast<PyObject*>(&pystringstream::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __sstream_clifwrap

namespace std {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// istringstream to/from ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> > conversion

bool Clif_PyObjAs(PyObject* py, ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyistringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyistringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sstream_clifwrap::pyistringstream::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyistringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sstream_clifwrap::pyistringstream::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert istringstream instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyistringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyistringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyistringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyistringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyistringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyistringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_istringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(c));
  return py;
}

// ostringstream to/from ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> > conversion

bool Clif_PyObjAs(PyObject* py, ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyostringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyostringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sstream_clifwrap::pyostringstream::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pyostringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sstream_clifwrap::pyostringstream::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ostringstream instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyostringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyostringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyostringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyostringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pyostringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pyostringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_ostringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(c));
  return py;
}

// stringstream to/from ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> > conversion

bool Clif_PyObjAs(PyObject* py, ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pystringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pystringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__sstream_clifwrap::pystringstream::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>* c) {
  assert(c != nullptr);
  ::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* cpp = __sstream_clifwrap::pystringstream::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__sstream_clifwrap::pystringstream::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert stringstream instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pystringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pystringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pystringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pystringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__sstream_clifwrap::pystringstream::wrapper_Type, NULL, NULL);
  reinterpret_cast<__sstream_clifwrap::pystringstream::wrapper*>(py)->cpp = ::clif::Instance<::std::basic_stringstream<char, ::std::char_traits<char>, ::std::allocator<char> >>(std::move(c));
  return py;
}

}  // namespace std
