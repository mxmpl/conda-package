//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/base/kaldi-error.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "kaldi-error-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__error_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// get_verbose_level() -> int
static PyObject* wrapGetVerboseLevel_as_get_verbose_level(PyObject* self) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::GetVerboseLevel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_verbose_level(i:int)
static PyObject* wrapSetVerboseLevel_as_set_verbose_level(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("i"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_verbose_level", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_verbose_level", names[0], "int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::SetVerboseLevel(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_abort_on_assert_failure(a:bool)
static PyObject* wrapSetAbortOnAssertFailure_as_set_abort_on_assert_failure(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("a"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_abort_on_assert_failure", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_abort_on_assert_failure", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::SetAbortOnAssertFailure(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_print_stack_trace_on_error(p:bool)
static PyObject* wrapSetPrintStackTraceOnError_as_set_print_stack_trace_on_error(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("p"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_print_stack_trace_on_error", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_print_stack_trace_on_error", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::SetPrintStackTraceOnError(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("get_verbose_level"), (PyCFunction)wrapGetVerboseLevel_as_get_verbose_level, METH_NOARGS, C("get_verbose_level() -> int\n\nReturns the verbose level.")},
  {C("set_verbose_level"), (PyCFunction)wrapSetVerboseLevel_as_set_verbose_level, METH_VARARGS | METH_KEYWORDS, C("set_verbose_level(i:int)\n\nSets the verbose level.")},
  {C("set_abort_on_assert_failure"), (PyCFunction)wrapSetAbortOnAssertFailure_as_set_abort_on_assert_failure, METH_VARARGS | METH_KEYWORDS, C("set_abort_on_assert_failure(a:bool)\n\nEnables/disables the call to abort in case of assertion failure.")},
  {C("set_print_stack_trace_on_error"), (PyCFunction)wrapSetPrintStackTraceOnError_as_set_print_stack_trace_on_error, METH_VARARGS | METH_KEYWORDS, C("set_print_stack_trace_on_error(p:bool)\n\nEnables/disables the printing of stack trace in case of an error.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_error",  // module name
  "CLIF-generated module for base/kaldi-error.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  return module;
}

}  // namespace __kaldi__error_clifwrap
