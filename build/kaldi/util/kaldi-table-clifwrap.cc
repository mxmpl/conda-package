//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/util/kaldi-table.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/compressed-matrix-clifwrap.h"
#include "feat/wave-reader-clifwrap.h"
#include "nnet3/nnet-example-clifwrap.h"
#include "rnnlm/rnnlm-example-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "lat/kaldi-lattice.h"
#include "kaldi-table-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__table_clifwrap {
using namespace clif;
using namespace kaldi::rnnlm;
using namespace kaldi::nnet3;
using namespace kaldi;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


// Create Python Enum object (cached in _WspecifierType) for ::kaldi::WspecifierType
static PyObject* wrapWspecifierType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(4);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::WspecifierType>::type>(::kaldi::WspecifierType::kNoWspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ARCHIVE_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::WspecifierType>::type>(::kaldi::WspecifierType::kArchiveWspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SCRIPT_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::WspecifierType>::type>(::kaldi::WspecifierType::kScriptWspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("BOTH_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::WspecifierType>::type>(::kaldi::WspecifierType::kBothWspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  py = PyUnicode_FromString("WspecifierType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _WspecifierType{};  // set by above func in Init()

namespace pyWspecifierOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::WspecifierOptions> cpp;
};
static ::kaldi::WspecifierOptions* ThisPtr(PyObject*);

static PyObject* get_binary(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->binary, {});
}

static int set_binary(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the binary attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->binary)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for binary:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_flush(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->flush, {});
}

static int set_flush(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the flush attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->flush)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for flush:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_permissive(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->permissive, {});
}

static int set_permissive(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the permissive attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->permissive)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for permissive:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("binary"), get_binary, set_binary, C("Write table in binary format.")},
  {C("flush"), get_flush, set_flush, C("Flush the stream after writing each entry.")},
  {C("permissive"), get_permissive, set_permissive, C("Ignore absent script file entries.")},
  {}
};

// WspecifierOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// WspecifierOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// WspecifierOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.WspecifierOptions",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Write specifier options.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "WspecifierOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::WspecifierOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::WspecifierOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_WspecifierOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::WspecifierOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::WspecifierOptions* c = static_cast<::kaldi::WspecifierOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::WspecifierOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyWspecifierOptions

// classify_wspecifier(wspecifier:str) -> (wspecifier_type:WspecifierType, archive_wxfilename:str, script_wxfilename:str, opts:WspecifierOptions)
static PyObject* wrapClassifyWspecifier_as_classify_wspecifier(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:classify_wspecifier", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("classify_wspecifier", names[0], "::std::string", a[0]);
  ::std::string ret1{};
  ::std::string ret2{};
  ::kaldi::WspecifierOptions ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::WspecifierType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ClassifyWspecifier(std::move(arg1), &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), _1)) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), _1)) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  return result_tuple;
}

// read_script_file(rxfilename:str, print_warnings:bool) -> (success:bool, script_out:list<tuple<str, str>>)
static PyObject* wrapReadScriptFile_as_read_script_file(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("rxfilename"),
      C("print_warnings"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_script_file", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_script_file", names[0], "::std::string", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_script_file", names[1], "bool", a[1]);
  ::std::vector< ::std::pair< ::std::string, ::std::string> > ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ReadScriptFile(std::move(arg1), std::move(arg2), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {{_1,_1}})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// write_script_file(wxfilename:str, script:list<tuple<str, str>>) -> bool
static PyObject* wrapWriteScriptFile_as_write_script_file(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("wxfilename"),
      C("script"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_script_file", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_script_file", names[0], "::std::string", a[0]);
  ::std::vector< ::std::pair< ::std::string, ::std::string> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_script_file", names[1], "::std::vector< ::std::pair< ::std::string, ::std::string> >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::WriteScriptFile(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyRspecifierOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RspecifierOptions> cpp;
};
static ::kaldi::RspecifierOptions* ThisPtr(PyObject*);

static PyObject* get_once(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->once, {});
}

static int set_once(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the once attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->once)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for once:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_sorted(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->sorted, {});
}

static int set_sorted(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the sorted attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->sorted)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for sorted:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_called_sorted(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->called_sorted, {});
}

static int set_called_sorted(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the called_sorted attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->called_sorted)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for called_sorted:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_permissive(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->permissive, {});
}

static int set_permissive(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the permissive attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->permissive)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for permissive:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_background(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->background, {});
}

static int set_background(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the background attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->background)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for background:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("once"), get_once, set_once, C("Each key in the table will be queried only once.")},
  {C("sorted"), get_sorted, set_sorted, C("Table keys are in sorted order.")},
  {C("called_sorted"), get_called_sorted, set_called_sorted, C("Table keys/values will be accessed in sorted order. Implies `once`.")},
  {C("permissive"), get_permissive, set_permissive, C("If a table cannot be read, act as if its keys were never there.")},
  {C("background"), get_background, set_background, C("Read ahead to the next object in a background thread.")},
  {}
};

// RspecifierOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RspecifierOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RspecifierOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RspecifierOptions",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Read specifier options.",           // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RspecifierOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RspecifierOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RspecifierOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RspecifierOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RspecifierOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::RspecifierOptions* c = static_cast<::kaldi::RspecifierOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RspecifierOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRspecifierOptions

// Create Python Enum object (cached in _RspecifierType) for ::kaldi::RspecifierType
static PyObject* wrapRspecifierType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::RspecifierType>::type>(::kaldi::RspecifierType::kNoRspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ARCHIVE_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::RspecifierType>::type>(::kaldi::RspecifierType::kArchiveRspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SCRIPT_SPECIFIER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::RspecifierType>::type>(::kaldi::RspecifierType::kScriptRspecifier)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("RspecifierType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _RspecifierType{};  // set by above func in Init()

// classify_rspecifier(rspecifier:str) -> (rspecifier_type:RspecifierType, rxfilename:str, opts:RspecifierOptions)
static PyObject* wrapClassifyRspecifier_as_classify_rspecifier(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:classify_rspecifier", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("classify_rspecifier", names[0], "::std::string", a[0]);
  ::std::string ret1{};
  ::kaldi::RspecifierOptions ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::RspecifierType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ClassifyRspecifier(std::move(arg1), &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), _1)) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}

namespace pySequentialVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> Vector
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> Vector\n  Calls C++ function\n  ::kaldi::Vector<float> ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {}
};

// SequentialVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_Vector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialVectorReader

namespace pySequentialDoubleVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> DoubleVector
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> DoubleVector\n  Calls C++ function\n  ::kaldi::Vector<double> ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {}
};

// SequentialDoubleVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialDoubleVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialDoubleVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialDoubleVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialDoubleVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_Vector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialDoubleVectorReader

namespace pySequentialMatrixReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> Matrix
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> Matrix\n  Calls C++ function\n  ::kaldi::Matrix<float> ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {}
};

// SequentialMatrixReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialMatrixReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialMatrixReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialMatrixReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialMatrixReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_Matrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialMatrixReader

namespace pySequentialDoubleMatrixReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> DoubleMatrix
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> DoubleMatrix\n  Calls C++ function\n  ::kaldi::Matrix<double> ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {}
};

// SequentialDoubleMatrixReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialDoubleMatrixReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialDoubleMatrixReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialDoubleMatrixReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialDoubleMatrixReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_Matrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialDoubleMatrixReader

namespace pySequentialWaveReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> WaveData
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::WaveData ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::WaveHolder>::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> WaveData\n  Calls C++ function\n  ::kaldi::WaveData ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::WaveHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::WaveHolder>::Close()")},
  {}
};

// SequentialWaveReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialWaveReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialWaveReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialWaveReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialWaveReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_WaveHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::WaveHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialWaveReader

namespace pySequentialLatticeReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> LatticeVectorFst
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.LatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> LatticeVectorFst\n  Calls C++ function\n  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::LatticeHolder>::Close()")},
  {}
};

// SequentialLatticeReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialLatticeReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialLatticeReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialLatticeReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialLatticeReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_LatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialLatticeReader

namespace pySequentialCompactLatticeReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> CompactLatticeVectorFst
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.CompactLatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> CompactLatticeVectorFst\n  Calls C++ function\n  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::CompactLatticeHolder>::Close()")},
  {}
};

// SequentialCompactLatticeReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialCompactLatticeReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialCompactLatticeReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialCompactLatticeReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialCompactLatticeReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_CompactLatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialCompactLatticeReader

namespace pySequentialIntReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> int
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> int\n  Calls C++ function\n  int ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<int> >::Close()")},
  {}
};

// SequentialIntReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialIntReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialIntReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialIntReader",  // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialIntReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialIntReader

namespace pySequentialFloatReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> float
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> float\n  Calls C++ function\n  float ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<float> >::Close()")},
  {}
};

// SequentialFloatReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialFloatReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialFloatReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialFloatReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialFloatReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialFloatReader

namespace pySequentialDoubleReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> float
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> float\n  Calls C++ function\n  double ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<double> >::Close()")},
  {}
};

// SequentialDoubleReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialDoubleReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialDoubleReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialDoubleReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialDoubleReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicHolder_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialDoubleReader

namespace pySequentialBoolReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> bool
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicHolder<bool> >::Close()")},
  {}
};

// SequentialBoolReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialBoolReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialBoolReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialBoolReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialBoolReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicHolder_bool"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialBoolReader

namespace pySequentialIntVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> list<int>
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SequentialTableReader<BasicVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> list<int>\n  Calls C++ function\n  ::kaldi::SequentialTableReader<BasicVectorHolder<int> >::T ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorHolder<int> >::Close()")},
  {}
};

// SequentialIntVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialIntVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialIntVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialIntVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialIntVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialIntVectorReader

namespace pySequentialIntVectorVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> list<list<int>>
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SequentialTableReader<BasicVectorVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> list<list<int>>\n  Calls C++ function\n  ::kaldi::SequentialTableReader<BasicVectorVectorHolder<int> >::T ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {}
};

// SequentialIntVectorVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialIntVectorVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialIntVectorVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialIntVectorVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialIntVectorVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicVectorVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialIntVectorVectorReader

namespace pySequentialIntPairVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> list<tuple<int, int>>
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SequentialTableReader<BasicPairVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> list<tuple<int, int>>\n  Calls C++ function\n  ::kaldi::SequentialTableReader<BasicPairVectorHolder<int> >::T ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {}
};

// SequentialIntPairVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialIntPairVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialIntPairVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialIntPairVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialIntPairVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicPairVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialIntPairVectorReader

namespace pySequentialFloatPairVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> list<tuple<float, float>>
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::SequentialTableReader<BasicPairVectorHolder<float> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> list<tuple<float, float>>\n  Calls C++ function\n  ::kaldi::SequentialTableReader<BasicPairVectorHolder<float> >::T ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {}
};

// SequentialFloatPairVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialFloatPairVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialFloatPairVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialFloatPairVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialFloatPairVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_BasicPairVectorHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialFloatPairVectorReader

namespace pyRandomAccessVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> Vector
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> Vector\n  Calls C++ function\n  ::kaldi::Vector<float> ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {}
};

// RandomAccessVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_KaldiObjectHolder__kaldi_Vector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessVectorReader

namespace pyRandomAccessDoubleVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> DoubleVector
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> DoubleVector\n  Calls C++ function\n  ::kaldi::Vector<double> ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {}
};

// RandomAccessDoubleVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessDoubleVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessDoubleVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessDoubleVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessDoubleVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_KaldiObjectHolder__kaldi_Vector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessDoubleVectorReader

namespace pyRandomAccessMatrixReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> Matrix
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> Matrix\n  Calls C++ function\n  ::kaldi::Matrix<float> ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {}
};

// RandomAccessMatrixReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessMatrixReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessMatrixReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessMatrixReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessMatrixReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_KaldiObjectHolder__kaldi_Matrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessMatrixReader

namespace pyRandomAccessDoubleMatrixReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> DoubleMatrix
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> DoubleMatrix\n  Calls C++ function\n  ::kaldi::Matrix<double> ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {}
};

// RandomAccessDoubleMatrixReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessDoubleMatrixReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessDoubleMatrixReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessDoubleMatrixReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessDoubleMatrixReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_KaldiObjectHolder__kaldi_Matrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessDoubleMatrixReader

namespace pyRandomAccessWaveReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> WaveData
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::WaveData ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> WaveData\n  Calls C++ function\n  ::kaldi::WaveData ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::WaveHolder>::Close()")},
  {}
};

// RandomAccessWaveReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessWaveReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessWaveReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessWaveReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessWaveReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_WaveHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessWaveReader

namespace pyRandomAccessLatticeReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> LatticeVectorFst
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.LatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> LatticeVectorFst\n  Calls C++ function\n  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::LatticeHolder>::Close()")},
  {}
};

// RandomAccessLatticeReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessLatticeReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessLatticeReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessLatticeReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessLatticeReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_LatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessLatticeReader

namespace pyRandomAccessCompactLatticeReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> CompactLatticeVectorFst
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.CompactLatticeVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> CompactLatticeVectorFst\n  Calls C++ function\n  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::CompactLatticeHolder>::Close()")},
  {}
};

// RandomAccessCompactLatticeReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessCompactLatticeReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessCompactLatticeReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessCompactLatticeReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessCompactLatticeReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_CompactLatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessCompactLatticeReader

namespace pyRandomAccessIntReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> int
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> int\n  Calls C++ function\n  int ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<int> >::Close()")},
  {}
};

// RandomAccessIntReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessIntReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessIntReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessIntReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessIntReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessIntReader

namespace pyRandomAccessFloatReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> float
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> float\n  Calls C++ function\n  float ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<float> >::Close()")},
  {}
};

// RandomAccessFloatReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessFloatReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessFloatReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessFloatReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessFloatReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessFloatReader

namespace pyRandomAccessDoubleReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> float
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> float\n  Calls C++ function\n  double ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<double> >::Close()")},
  {}
};

// RandomAccessDoubleReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessDoubleReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessDoubleReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessDoubleReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessDoubleReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicHolder_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessDoubleReader

namespace pyRandomAccessBoolReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> bool
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicHolder<bool> >::Close()")},
  {}
};

// RandomAccessBoolReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessBoolReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessBoolReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessBoolReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessBoolReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicHolder_bool"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessBoolReader

namespace pyRandomAccessIntVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> list<int>
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::RandomAccessTableReader<BasicVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> list<int>\n  Calls C++ function\n  ::kaldi::RandomAccessTableReader<BasicVectorHolder<int> >::T ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorHolder<int> >::Close()")},
  {}
};

// RandomAccessIntVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessIntVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessIntVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessIntVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessIntVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessIntVectorReader

namespace pyRandomAccessIntVectorVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> list<list<int>>
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::RandomAccessTableReader<BasicVectorVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> list<list<int>>\n  Calls C++ function\n  ::kaldi::RandomAccessTableReader<BasicVectorVectorHolder<int> >::T ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {}
};

// RandomAccessIntVectorVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessIntVectorVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessIntVectorVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessIntVectorVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessIntVectorVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicVectorVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessIntVectorVectorReader

namespace pyRandomAccessIntPairVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> list<tuple<int, int>>
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::RandomAccessTableReader<BasicPairVectorHolder<int> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> list<tuple<int, int>>\n  Calls C++ function\n  ::kaldi::RandomAccessTableReader<BasicPairVectorHolder<int> >::T ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {}
};

// RandomAccessIntPairVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessIntPairVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessIntPairVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessIntPairVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessIntPairVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicPairVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessIntPairVectorReader

namespace pyRandomAccessFloatPairVectorReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> list<tuple<float, float>>
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::RandomAccessTableReader<BasicPairVectorHolder<float> >::T ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> list<tuple<float, float>>\n  Calls C++ function\n  ::kaldi::RandomAccessTableReader<BasicPairVectorHolder<float> >::T ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {}
};

// RandomAccessFloatPairVectorReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessFloatPairVectorReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessFloatPairVectorReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessFloatPairVectorReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessFloatPairVectorReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_BasicPairVectorHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessFloatPairVectorReader

namespace pyRandomAccessVectorReaderMapped {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> cpp;
};
static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject*);

// open(table_rspecifier:str, map_rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("table_rspecifier"),
      C("map_rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:open", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("open", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> Vector
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(table_rspecifier:str, map_rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Open(::std::string, ::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> Vector\n  Calls C++ function\n  ::kaldi::Vector<float> ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {}
};

// RandomAccessVectorReaderMapped __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessVectorReaderMapped __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessVectorReaderMapped __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessVectorReaderMapped", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessVectorReaderMapped takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReaderMapped__kaldi_KaldiObjectHolder__kaldi_Vector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = static_cast<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessVectorReaderMapped

namespace pyRandomAccessDoubleVectorReaderMapped {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> cpp;
};
static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject*);

// open(table_rspecifier:str, map_rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("table_rspecifier"),
      C("map_rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:open", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("open", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> DoubleVector
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Vector<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._vector_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(table_rspecifier:str, map_rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Open(::std::string, ::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> DoubleVector\n  Calls C++ function\n  ::kaldi::Vector<double> ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {}
};

// RandomAccessDoubleVectorReaderMapped __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessDoubleVectorReaderMapped __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessDoubleVectorReaderMapped __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessDoubleVectorReaderMapped", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessDoubleVectorReaderMapped takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReaderMapped__kaldi_KaldiObjectHolder__kaldi_Vector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = static_cast<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessDoubleVectorReaderMapped

namespace pyRandomAccessMatrixReaderMapped {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> cpp;
};
static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject*);

// open(table_rspecifier:str, map_rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("table_rspecifier"),
      C("map_rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:open", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("open", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> Matrix
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(table_rspecifier:str, map_rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Open(::std::string, ::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> Matrix\n  Calls C++ function\n  ::kaldi::Matrix<float> ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {}
};

// RandomAccessMatrixReaderMapped __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessMatrixReaderMapped __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessMatrixReaderMapped __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessMatrixReaderMapped", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessMatrixReaderMapped takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReaderMapped__kaldi_KaldiObjectHolder__kaldi_Matrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = static_cast<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessMatrixReaderMapped

namespace pyRandomAccessDoubleMatrixReaderMapped {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> cpp;
};
static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject*);

// open(table_rspecifier:str, map_rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("table_rspecifier"),
      C("map_rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:open", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("open", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> DoubleMatrix
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::Matrix<double> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.matrix._matrix_wrapper");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(table_rspecifier:str, map_rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Open(::std::string, ::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> DoubleMatrix\n  Calls C++ function\n  ::kaldi::Matrix<double> ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {}
};

// RandomAccessDoubleMatrixReaderMapped __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessDoubleMatrixReaderMapped __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessDoubleMatrixReaderMapped __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessDoubleMatrixReaderMapped", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessDoubleMatrixReaderMapped takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReaderMapped__kaldi_KaldiObjectHolder__kaldi_Matrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = static_cast<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessDoubleMatrixReaderMapped

namespace pyRandomAccessFloatReaderMapped {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >> cpp;
};
static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject*);

// open(table_rspecifier:str, map_rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("table_rspecifier"),
      C("map_rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:open", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("open", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> float
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(table_rspecifier:str, map_rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::Open(::std::string, ::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> float\n  Calls C++ function\n  float ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReaderMapped<kaldi::BasicHolder<float> >::Close()")},
  {}
};

// RandomAccessFloatReaderMapped __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessFloatReaderMapped __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessFloatReaderMapped __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessFloatReaderMapped", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessFloatReaderMapped takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReaderMapped__kaldi_BasicHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c = static_cast<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessFloatReaderMapped

namespace pyVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:Vector)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::Vector<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::Vector<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:Vector)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Write(::std::string, ::kaldi::Vector<float>)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<float> > >::Close()")},
  {}
};

// VectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// VectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// VectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.VectorWriter",         // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "VectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_Vector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyVectorWriter

namespace pyDoubleVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:DoubleVector)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::Vector<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::Vector<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:DoubleVector)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Write(::std::string, ::kaldi::Vector<double>)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Vector<double> > >::Close()")},
  {}
};

// DoubleVectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleVectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleVectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.DoubleVectorWriter",   // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleVectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_Vector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleVectorWriter

namespace pyMatrixWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:Matrix)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::Matrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::Matrix<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:Matrix)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Write(::std::string, ::kaldi::Matrix<float>)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<float> > >::Close()")},
  {}
};

// MatrixWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// MatrixWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.MatrixWriter",         // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "MatrixWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_Matrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixWriter

namespace pyDoubleMatrixWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:DoubleMatrix)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::Matrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::Matrix<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:DoubleMatrix)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Write(::std::string, ::kaldi::Matrix<double>)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::Matrix<double> > >::Close()")},
  {}
};

// DoubleMatrixWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleMatrixWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleMatrixWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.DoubleMatrixWriter",   // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleMatrixWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_Matrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleMatrixWriter

namespace pyCompressedMatrixWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:CompressedMatrix)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::CompressedMatrix* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::CompressedMatrix", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:CompressedMatrix)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::Write(::std::string, ::kaldi::CompressedMatrix)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::CompressedMatrix> >::Close()")},
  {}
};

// CompressedMatrixWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompressedMatrixWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompressedMatrixWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.CompressedMatrixWriter", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CompressedMatrixWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_CompressedMatrix"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompressedMatrixWriter

namespace pyWaveWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::WaveHolder>> cpp;
};
static ::kaldi::TableWriter< ::kaldi::WaveHolder>* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:WaveData)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::WaveData* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::WaveData", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::WaveHolder>::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::WaveHolder>::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:WaveData)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::WaveHolder>::Write(::std::string, ::kaldi::WaveData)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::WaveHolder>::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::WaveHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::WaveHolder>::Close()")},
  {}
};

// WaveWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// WaveWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// WaveWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.WaveWriter",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::WaveHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "WaveWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::WaveHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::WaveHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_WaveHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::WaveHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::WaveHolder>* c = static_cast<::kaldi::TableWriter< ::kaldi::WaveHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::WaveHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyWaveWriter

namespace pyLatticeWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::LatticeHolder>> cpp;
};
static ::kaldi::TableWriter< ::kaldi::LatticeHolder>* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:LatticeVectorFst)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::LatticeHolder>::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::LatticeHolder>::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:LatticeVectorFst)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::LatticeHolder>::Write(::std::string, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::LatticeHolder>::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::LatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::LatticeHolder>::Close()")},
  {}
};

// LatticeWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LatticeWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LatticeWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.LatticeWriter",        // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::LatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LatticeWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::LatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::LatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_LatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::LatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::LatticeHolder>* c = static_cast<::kaldi::TableWriter< ::kaldi::LatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::LatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLatticeWriter

namespace pyCompactLatticeWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>> cpp;
};
static ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:CompactLatticeVectorFst)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:CompactLatticeVectorFst)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::Write(::std::string, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::CompactLatticeHolder>::Close()")},
  {}
};

// CompactLatticeWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompactLatticeWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompactLatticeWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.CompactLatticeWriter", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CompactLatticeWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_CompactLatticeHolder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c = static_cast<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompactLatticeWriter

namespace pyIntWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:int)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<int> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<int> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:int)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<int> >::Write(::std::string, int)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<int> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<int> >::Close()")},
  {}
};

// IntWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IntWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IntWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.IntWriter",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IntWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIntWriter

namespace pyFloatWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:float)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<float> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<float> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:float)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<float> >::Write(::std::string, double)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<float> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<float> >::Close()")},
  {}
};

// FloatWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// FloatWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// FloatWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.FloatWriter",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "FloatWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyFloatWriter

namespace pyDoubleWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:float)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<double> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<double> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:float)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<double> >::Write(::std::string, double)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<double> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<double> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<double> >::Close()")},
  {}
};

// DoubleWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.DoubleWriter",         // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicHolder_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicHolder<double> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleWriter

namespace pyBoolWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:bool)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::Write(::std::string, bool)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicHolder<bool> >::Close()")},
  {}
};

// BoolWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// BoolWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// BoolWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.BoolWriter",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "BoolWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicHolder_bool"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyBoolWriter

namespace pyIntVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:list<int>)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::TableWriter<BasicVectorHolder<int> >::T arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::TableWriter<BasicVectorHolder<int> >::T", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:list<int>)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::Write(::std::string, ::kaldi::TableWriter<BasicVectorHolder<int> >::T)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorHolder<int> >::Close()")},
  {}
};

// IntVectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IntVectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IntVectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.IntVectorWriter",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IntVectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIntVectorWriter

namespace pyIntVectorVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:list<list<int>>)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::TableWriter<BasicVectorVectorHolder<int> >::T arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::TableWriter<BasicVectorVectorHolder<int> >::T", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:list<list<int>>)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::Write(::std::string, ::kaldi::TableWriter<BasicVectorVectorHolder<int> >::T)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicVectorVectorHolder<int> >::Close()")},
  {}
};

// IntVectorVectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IntVectorVectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IntVectorVectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.IntVectorVectorWriter", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IntVectorVectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicVectorVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIntVectorVectorWriter

namespace pyIntPairVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:list<tuple<int, int>>)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::TableWriter<BasicPairVectorHolder<int> >::T arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::TableWriter<BasicPairVectorHolder<int> >::T", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:list<tuple<int, int>>)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::Write(::std::string, ::kaldi::TableWriter<BasicPairVectorHolder<int> >::T)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<int> >::Close()")},
  {}
};

// IntPairVectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IntPairVectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IntPairVectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.IntPairVectorWriter",  // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IntPairVectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicPairVectorHolder_int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIntPairVectorWriter

namespace pyFloatPairVectorWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:list<tuple<float, float>>)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::TableWriter<BasicPairVectorHolder<float> >::T arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::TableWriter<BasicPairVectorHolder<float> >::T", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:list<tuple<float, float>>)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::Write(::std::string, ::kaldi::TableWriter<BasicPairVectorHolder<float> >::T)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::BasicPairVectorHolder<float> >::Close()")},
  {}
};

// FloatPairVectorWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// FloatPairVectorWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// FloatPairVectorWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.FloatPairVectorWriter", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "FloatPairVectorWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_BasicPairVectorHolder_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c = static_cast<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyFloatPairVectorWriter

namespace pySequentialNnetExampleReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> NnetExample
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::NnetExample ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> NnetExample\n  Calls C++ function\n  ::kaldi::nnet3::NnetExample ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {}
};

// SequentialNnetExampleReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialNnetExampleReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialNnetExampleReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialNnetExampleReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialNnetExampleReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_nnet3_NnetExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialNnetExampleReader

namespace pyRandomAccessNnetExampleReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> cpp;
};
static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// has_key(key:str) -> bool
static PyObject* wrapHasKey_as_has_key(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:has_key", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("has_key", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HasKey(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// value(key:str) -> NnetExample
static PyObject* wrapValue_as_value(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:value", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("value", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::NnetExample ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Open(::std::string)")},
  {C("has_key"), (PyCFunction)wrapHasKey_as_has_key, METH_VARARGS | METH_KEYWORDS, C("has_key(key:str) -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::HasKey(::std::string)")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_VARARGS | METH_KEYWORDS, C("value(key:str) -> NnetExample\n  Calls C++ function\n  ::kaldi::nnet3::NnetExample ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Value(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::RandomAccessTableReader<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {}
};

// RandomAccessNnetExampleReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RandomAccessNnetExampleReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RandomAccessNnetExampleReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RandomAccessNnetExampleReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RandomAccessNnetExampleReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_RandomAccessTableReader__kaldi_KaldiObjectHolder__kaldi_nnet3_NnetExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = static_cast<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRandomAccessNnetExampleReader

namespace pyNnetExampleWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:NnetExample)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::nnet3::NnetExample* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::nnet3::NnetExample", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:NnetExample)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Write(::std::string, ::kaldi::nnet3::NnetExample)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::nnet3::NnetExample> >::Close()")},
  {}
};

// NnetExampleWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NnetExampleWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NnetExampleWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.NnetExampleWriter",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NnetExampleWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_nnet3_NnetExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNnetExampleWriter

namespace pySequentialRnnlmExampleReader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> cpp;
};
static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* ThisPtr(PyObject*);

// open(rspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("rspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// done() -> bool
static PyObject* wrapDone_as_done(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Done();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// key() -> str
static PyObject* wrapKey_as_key(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Key();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

// free_current()
static PyObject* wrapFreeCurrent_as_free_current(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FreeCurrent();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// value() -> RnnlmExample
static PyObject* wrapValue_as_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::rnnlm::RnnlmExample ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Value();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// next()
static PyObject* wrapNext_as_next(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Next();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(rspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Open(::std::string)")},
  {C("done"), (PyCFunction)wrapDone_as_done, METH_NOARGS, C("done() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Done()")},
  {C("key"), (PyCFunction)wrapKey_as_key, METH_NOARGS, C("key() -> str\n  Calls C++ function\n  ::std::string ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Key()")},
  {C("free_current"), (PyCFunction)wrapFreeCurrent_as_free_current, METH_NOARGS, C("free_current()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::FreeCurrent()")},
  {C("value"), (PyCFunction)wrapValue_as_value, METH_NOARGS, C("value() -> RnnlmExample\n  Calls C++ function\n  ::kaldi::rnnlm::RnnlmExample ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Value()")},
  {C("next"), (PyCFunction)wrapNext_as_next, METH_NOARGS, C("next()\n  Calls C++ function\n  void ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Next()")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::IsOpen()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::SequentialTableReader<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Close()")},
  {}
};

// SequentialRnnlmExampleReader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SequentialRnnlmExampleReader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SequentialRnnlmExampleReader __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.SequentialRnnlmExampleReader", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SequentialRnnlmExampleReader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SequentialTableReader__kaldi_KaldiObjectHolder__kaldi_rnnlm_RnnlmExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = static_cast<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySequentialRnnlmExampleReader

namespace pyRnnlmExampleWriter {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> cpp;
};
static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* ThisPtr(PyObject*);

// open(wspecifier:str) -> bool
static PyObject* wrapOpen_as_open(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("wspecifier"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:open", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("open", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Open(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_open() -> bool
static PyObject* wrapIsOpen_as_is_open(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsOpen();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(key:str, value:RnnlmExample)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("key"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  ::kaldi::rnnlm::RnnlmExample* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::kaldi::rnnlm::RnnlmExample", a[1]);
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// flush()
static PyObject* wrapFlush_as_flush(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Flush();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// close() -> bool
static PyObject* wrapClose_as_close(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __exit__@() -> bool
static PyObject* wrapClose_as___exit__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Close();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  Py_XDECREF(result_tuple);
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("open"), (PyCFunction)wrapOpen_as_open, METH_VARARGS | METH_KEYWORDS, C("open(wspecifier:str) -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Open(::std::string)")},
  {C("is_open"), (PyCFunction)wrapIsOpen_as_is_open, METH_NOARGS, C("is_open() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::IsOpen()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(key:str, value:RnnlmExample)\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Write(::std::string, ::kaldi::rnnlm::RnnlmExample)")},
  {C("flush"), (PyCFunction)wrapFlush_as_flush, METH_NOARGS, C("flush()\n  Calls C++ function\n  void ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Flush()")},
  {C("close"), (PyCFunction)wrapClose_as_close, METH_NOARGS, C("close() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Close()")},
  {C("__exit__"), (PyCFunction)wrapClose_as___exit__, METH_VARARGS | METH_KEYWORDS, C("__exit__@() -> bool\n  Calls C++ function\n  bool ::kaldi::TableWriter<kaldi::KaldiObjectHolder<kaldi::rnnlm::RnnlmExample> >::Close()")},
  {}
};

// RnnlmExampleWriter __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmExampleWriter __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmExampleWriter __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_table.RnnlmExampleWriter",   // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RnnlmExampleWriter takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_TableWriter__kaldi_KaldiObjectHolder__kaldi_rnnlm_RnnlmExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >"));
      if (!PyErr_Occurred()) {
        ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c = static_cast<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmExampleWriter


// Initialize module

static PyMethodDef Methods[] = {
  {C("classify_wspecifier"), (PyCFunction)wrapClassifyWspecifier_as_classify_wspecifier, METH_VARARGS | METH_KEYWORDS, C("classify_wspecifier(wspecifier:str) -> (wspecifier_type:WspecifierType, archive_wxfilename:str, script_wxfilename:str, opts:WspecifierOptions)\n\nDecomposes the wspecifier string into its components.\n\nReturns:\n  A tuple containing `(wspecifier type, archive filename, script\n  filename, wspecifier options)`.")},
  {C("read_script_file"), (PyCFunction)wrapReadScriptFile_as_read_script_file, METH_VARARGS | METH_KEYWORDS, C("read_script_file(rxfilename:str, print_warnings:bool) -> (success:bool, script_out:list<tuple<str, str>>)\n\nReads a script file into a list of string pairs.\n\nThe script (.scp) file format is::\n\n  key1 xfilename1\n  key2 xfilename2\n  ...\n\nwhere xfilenames are either rxfilenames or wxfilenames.\n\nArgs:\n  rxfilename (str): Extended filename for reading the script file.\n  print_warnings (bool): Whether to print out warning messages that\n    explain the script file errors.\n\nReturns:\n  A list of `(key, xfilename)` pairs.\n\nRaises:\n  ValueError: If the script file format is not valid.")},
  {C("write_script_file"), (PyCFunction)wrapWriteScriptFile_as_write_script_file, METH_VARARGS | METH_KEYWORDS, C("write_script_file(wxfilename:str, script:list<tuple<str, str>>) -> bool\n\nWrites a list of string pairs as a script file.\n\nArgs:\n  wxfilename (str): Extended filename for writing the script file.\n\nReturns:\n  True on success, False otherwise.")},
  {C("classify_rspecifier"), (PyCFunction)wrapClassifyRspecifier_as_classify_rspecifier, METH_VARARGS | METH_KEYWORDS, C("classify_rspecifier(rspecifier:str) -> (rspecifier_type:RspecifierType, rxfilename:str, opts:RspecifierOptions)\n\nDecomposes the rspecifier string into its components.\n\nReturns:\n  A tuple containing `(rspecifier type, extended filename, rspecifier\n  options)`.")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyWspecifierOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyWspecifierOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRspecifierOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRspecifierOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialDoubleVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialDoubleVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialMatrixReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialMatrixReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialDoubleMatrixReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialDoubleMatrixReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialWaveReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialWaveReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialLatticeReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialLatticeReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialCompactLatticeReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialCompactLatticeReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialIntReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialIntReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialFloatReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialFloatReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialDoubleReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialDoubleReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialBoolReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialBoolReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialIntVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialIntVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialIntVectorVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialIntVectorVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialIntPairVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialIntPairVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialFloatPairVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialFloatPairVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessDoubleVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessDoubleVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessMatrixReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessMatrixReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessDoubleMatrixReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessDoubleMatrixReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessWaveReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessWaveReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessLatticeReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessLatticeReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessCompactLatticeReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessCompactLatticeReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessIntReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessIntReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessFloatReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessFloatReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessDoubleReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessDoubleReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessBoolReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessBoolReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessIntVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessIntVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessIntVectorVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessIntVectorVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessIntPairVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessIntPairVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessFloatPairVectorReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessFloatPairVectorReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessVectorReaderMapped::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessVectorReaderMapped::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessDoubleVectorReaderMapped::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessDoubleVectorReaderMapped::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessMatrixReaderMapped::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessMatrixReaderMapped::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessFloatReaderMapped::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessFloatReaderMapped::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyMatrixWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyMatrixWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleMatrixWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleMatrixWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompressedMatrixWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompressedMatrixWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyWaveWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyWaveWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLatticeWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLatticeWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompactLatticeWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompactLatticeWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIntWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIntWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyFloatWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyFloatWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyBoolWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyBoolWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIntVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIntVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIntVectorVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIntVectorVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIntPairVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIntPairVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyFloatPairVectorWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyFloatPairVectorWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialNnetExampleReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialNnetExampleReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRandomAccessNnetExampleReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRandomAccessNnetExampleReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetExampleWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetExampleWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySequentialRnnlmExampleReader::wrapper_Type) < 0) return false;
  Py_INCREF(&pySequentialRnnlmExampleReader::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRnnlmExampleWriter::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmExampleWriter::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_table",  // module name
  "CLIF-generated module for util/kaldi-table.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_compressed_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_wave_reader")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_example")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_rnnlm_example")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "WspecifierType", (_WspecifierType=wrapWspecifierType())) < 0) goto err;
  if (PyModule_AddObject(module, "WspecifierOptions", reinterpret_cast<PyObject*>(&pyWspecifierOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RspecifierOptions", reinterpret_cast<PyObject*>(&pyRspecifierOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RspecifierType", (_RspecifierType=wrapRspecifierType())) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialVectorReader", reinterpret_cast<PyObject*>(&pySequentialVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialDoubleVectorReader", reinterpret_cast<PyObject*>(&pySequentialDoubleVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialMatrixReader", reinterpret_cast<PyObject*>(&pySequentialMatrixReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialDoubleMatrixReader", reinterpret_cast<PyObject*>(&pySequentialDoubleMatrixReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialWaveReader", reinterpret_cast<PyObject*>(&pySequentialWaveReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialLatticeReader", reinterpret_cast<PyObject*>(&pySequentialLatticeReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialCompactLatticeReader", reinterpret_cast<PyObject*>(&pySequentialCompactLatticeReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialIntReader", reinterpret_cast<PyObject*>(&pySequentialIntReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialFloatReader", reinterpret_cast<PyObject*>(&pySequentialFloatReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialDoubleReader", reinterpret_cast<PyObject*>(&pySequentialDoubleReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialBoolReader", reinterpret_cast<PyObject*>(&pySequentialBoolReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialIntVectorReader", reinterpret_cast<PyObject*>(&pySequentialIntVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialIntVectorVectorReader", reinterpret_cast<PyObject*>(&pySequentialIntVectorVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialIntPairVectorReader", reinterpret_cast<PyObject*>(&pySequentialIntPairVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialFloatPairVectorReader", reinterpret_cast<PyObject*>(&pySequentialFloatPairVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessDoubleVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessDoubleVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessMatrixReader", reinterpret_cast<PyObject*>(&pyRandomAccessMatrixReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessDoubleMatrixReader", reinterpret_cast<PyObject*>(&pyRandomAccessDoubleMatrixReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessWaveReader", reinterpret_cast<PyObject*>(&pyRandomAccessWaveReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessLatticeReader", reinterpret_cast<PyObject*>(&pyRandomAccessLatticeReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessCompactLatticeReader", reinterpret_cast<PyObject*>(&pyRandomAccessCompactLatticeReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessIntReader", reinterpret_cast<PyObject*>(&pyRandomAccessIntReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessFloatReader", reinterpret_cast<PyObject*>(&pyRandomAccessFloatReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessDoubleReader", reinterpret_cast<PyObject*>(&pyRandomAccessDoubleReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessBoolReader", reinterpret_cast<PyObject*>(&pyRandomAccessBoolReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessIntVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessIntVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessIntVectorVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessIntVectorVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessIntPairVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessIntPairVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessFloatPairVectorReader", reinterpret_cast<PyObject*>(&pyRandomAccessFloatPairVectorReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessVectorReaderMapped", reinterpret_cast<PyObject*>(&pyRandomAccessVectorReaderMapped::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessDoubleVectorReaderMapped", reinterpret_cast<PyObject*>(&pyRandomAccessDoubleVectorReaderMapped::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessMatrixReaderMapped", reinterpret_cast<PyObject*>(&pyRandomAccessMatrixReaderMapped::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessDoubleMatrixReaderMapped", reinterpret_cast<PyObject*>(&pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessFloatReaderMapped", reinterpret_cast<PyObject*>(&pyRandomAccessFloatReaderMapped::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "VectorWriter", reinterpret_cast<PyObject*>(&pyVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleVectorWriter", reinterpret_cast<PyObject*>(&pyDoubleVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "MatrixWriter", reinterpret_cast<PyObject*>(&pyMatrixWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleMatrixWriter", reinterpret_cast<PyObject*>(&pyDoubleMatrixWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompressedMatrixWriter", reinterpret_cast<PyObject*>(&pyCompressedMatrixWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "WaveWriter", reinterpret_cast<PyObject*>(&pyWaveWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LatticeWriter", reinterpret_cast<PyObject*>(&pyLatticeWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompactLatticeWriter", reinterpret_cast<PyObject*>(&pyCompactLatticeWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IntWriter", reinterpret_cast<PyObject*>(&pyIntWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "FloatWriter", reinterpret_cast<PyObject*>(&pyFloatWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleWriter", reinterpret_cast<PyObject*>(&pyDoubleWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "BoolWriter", reinterpret_cast<PyObject*>(&pyBoolWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IntVectorWriter", reinterpret_cast<PyObject*>(&pyIntVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IntVectorVectorWriter", reinterpret_cast<PyObject*>(&pyIntVectorVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IntPairVectorWriter", reinterpret_cast<PyObject*>(&pyIntPairVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "FloatPairVectorWriter", reinterpret_cast<PyObject*>(&pyFloatPairVectorWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialNnetExampleReader", reinterpret_cast<PyObject*>(&pySequentialNnetExampleReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RandomAccessNnetExampleReader", reinterpret_cast<PyObject*>(&pyRandomAccessNnetExampleReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "NnetExampleWriter", reinterpret_cast<PyObject*>(&pyNnetExampleWriter::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SequentialRnnlmExampleReader", reinterpret_cast<PyObject*>(&pySequentialRnnlmExampleReader::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RnnlmExampleWriter", reinterpret_cast<PyObject*>(&pyRnnlmExampleWriter::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__table_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// BoolWriter to/from ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyBoolWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyBoolWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyBoolWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyBoolWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyBoolWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert BoolWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyBoolWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyBoolWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyBoolWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyBoolWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyBoolWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyBoolWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<bool> >>(std::move(c));
  return py;
}

// CompactLatticeWriter to/from ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyCompactLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyCompactLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyCompactLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompactLatticeWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompactLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::CompactLatticeHolder>>(std::move(c));
  return py;
}

// CompressedMatrixWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* cpp = __kaldi__table_clifwrap::pyCompressedMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* cpp = __kaldi__table_clifwrap::pyCompressedMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* cpp = __kaldi__table_clifwrap::pyCompressedMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompressedMatrixWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyCompressedMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::CompressedMatrix> >>(std::move(c));
  return py;
}

// DoubleMatrixWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleMatrixWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(std::move(c));
  return py;
}

// DoubleVectorWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyDoubleVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleVectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(std::move(c));
  return py;
}

// DoubleWriter to/from ::kaldi::TableWriter< ::kaldi::BasicHolder<double> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyDoubleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyDoubleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyDoubleWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyDoubleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyDoubleWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicHolder<double> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyDoubleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyDoubleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<double> >>(std::move(c));
  return py;
}

// FloatPairVectorWriter to/from ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert FloatPairVectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<float> >>(std::move(c));
  return py;
}

// FloatWriter to/from ::kaldi::TableWriter< ::kaldi::BasicHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyFloatWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyFloatWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyFloatWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert FloatWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyFloatWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyFloatWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<float> >>(std::move(c));
  return py;
}

// IntPairVectorWriter to/from ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntPairVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IntPairVectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntPairVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicPairVectorHolder<int> >>(std::move(c));
  return py;
}

// IntVectorVectorWriter to/from ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IntVectorVectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorVectorHolder<int> >>(std::move(c));
  return py;
}

// IntVectorWriter to/from ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IntVectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicVectorHolder<int> >>(std::move(c));
  return py;
}

// IntWriter to/from ::kaldi::TableWriter< ::kaldi::BasicHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyIntWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyIntWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyIntWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IntWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::BasicHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyIntWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyIntWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::BasicHolder<int> >>(std::move(c));
  return py;
}

// LatticeWriter to/from ::kaldi::TableWriter< ::kaldi::LatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::LatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyLatticeWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyLatticeWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyLatticeWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LatticeWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::LatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::LatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::LatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyLatticeWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyLatticeWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::LatticeHolder>>(std::move(c));
  return py;
}

// MatrixWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyMatrixWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyMatrixWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyMatrixWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert MatrixWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyMatrixWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyMatrixWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(std::move(c));
  return py;
}

// RandomAccessBoolReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyRandomAccessBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyRandomAccessBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pyRandomAccessBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessBoolReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<bool> >>(std::move(c));
  return py;
}

// RandomAccessCompactLatticeReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessCompactLatticeReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::CompactLatticeHolder>>(std::move(c));
  return py;
}

// RandomAccessDoubleMatrixReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessDoubleMatrixReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(std::move(c));
  return py;
}

// RandomAccessDoubleMatrixReaderMapped to/from ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessDoubleMatrixReaderMapped instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(std::move(c));
  return py;
}

// RandomAccessDoubleReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessDoubleReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<double> >>(std::move(c));
  return py;
}

// RandomAccessDoubleVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessDoubleVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(std::move(c));
  return py;
}

// RandomAccessDoubleVectorReaderMapped to/from ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessDoubleVectorReaderMapped instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessDoubleVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(std::move(c));
  return py;
}

// RandomAccessFloatPairVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessFloatPairVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<float> >>(std::move(c));
  return py;
}

// RandomAccessFloatReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessFloatReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<float> >>(std::move(c));
  return py;
}

// RandomAccessFloatReaderMapped to/from ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessFloatReaderMapped instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessFloatReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::BasicHolder<float> >>(std::move(c));
  return py;
}

// RandomAccessIntPairVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessIntPairVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicPairVectorHolder<int> >>(std::move(c));
  return py;
}

// RandomAccessIntReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessIntReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicHolder<int> >>(std::move(c));
  return py;
}

// RandomAccessIntVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessIntVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorHolder<int> >>(std::move(c));
  return py;
}

// RandomAccessIntVectorVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessIntVectorVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(std::move(c));
  return py;
}

// RandomAccessLatticeReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessLatticeReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::LatticeHolder>>(std::move(c));
  return py;
}

// RandomAccessMatrixReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessMatrixReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(std::move(c));
  return py;
}

// RandomAccessMatrixReaderMapped to/from ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessMatrixReaderMapped instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessMatrixReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(std::move(c));
  return py;
}

// RandomAccessVectorReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(std::move(c));
  return py;
}

// RandomAccessVectorReaderMapped to/from ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessVectorReaderMapped instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessVectorReaderMapped::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReaderMapped< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(std::move(c));
  return py;
}

// RandomAccessWaveReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyRandomAccessWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessWaveReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::WaveHolder>>(std::move(c));
  return py;
}

// RspecifierOptions to/from ::kaldi::RspecifierOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RspecifierOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RspecifierOptions* cpp = __kaldi__table_clifwrap::pyRspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::RspecifierOptions* cpp = __kaldi__table_clifwrap::pyRspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::RspecifierOptions* cpp = __kaldi__table_clifwrap::pyRspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RspecifierOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::RspecifierOptions* c) {
  assert(c != nullptr);
  ::kaldi::RspecifierOptions* cpp = __kaldi__table_clifwrap::pyRspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::RspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::RspecifierOptions* cpp = __kaldi__table_clifwrap::pyRspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RspecifierOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RspecifierOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RspecifierOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RspecifierOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RspecifierOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RspecifierOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::RspecifierOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRspecifierOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::RspecifierOptions>(c);
  return py;
}

// RspecifierType:IntEnum to/from enum ::kaldi::RspecifierType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RspecifierType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __kaldi__table_clifwrap::_RspecifierType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum RspecifierType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::RspecifierType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::RspecifierType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::RspecifierType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__kaldi__table_clifwrap::_RspecifierType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::RspecifierType>::type>(c)), nullptr);
}

// SequentialBoolReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pySequentialBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pySequentialBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialBoolReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* cpp = __kaldi__table_clifwrap::pySequentialBoolReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialBoolReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialBoolReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialBoolReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialBoolReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<bool> >>(std::move(c));
  return py;
}

// SequentialCompactLatticeReader to/from ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialCompactLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialCompactLatticeReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialCompactLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::CompactLatticeHolder>>(std::move(c));
  return py;
}

// SequentialDoubleMatrixReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialDoubleMatrixReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<double> > >>(std::move(c));
  return py;
}

// SequentialDoubleReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pySequentialDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pySequentialDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* cpp = __kaldi__table_clifwrap::pySequentialDoubleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialDoubleReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<double> >>(std::move(c));
  return py;
}

// SequentialDoubleVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* cpp = __kaldi__table_clifwrap::pySequentialDoubleVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialDoubleVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialDoubleVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<double> > >>(std::move(c));
  return py;
}

// SequentialFloatPairVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialFloatPairVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<float> >>(std::move(c));
  return py;
}

// SequentialFloatReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* cpp = __kaldi__table_clifwrap::pySequentialFloatReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialFloatReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialFloatReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialFloatReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<float> >>(std::move(c));
  return py;
}

// SequentialIntPairVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntPairVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialIntPairVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntPairVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicPairVectorHolder<int> >>(std::move(c));
  return py;
}

// SequentialIntReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialIntReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicHolder<int> >>(std::move(c));
  return py;
}

// SequentialIntVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialIntVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorHolder<int> >>(std::move(c));
  return py;
}

// SequentialIntVectorVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* cpp = __kaldi__table_clifwrap::pySequentialIntVectorVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialIntVectorVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialIntVectorVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::BasicVectorVectorHolder<int> >>(std::move(c));
  return py;
}

// SequentialLatticeReader to/from ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* cpp = __kaldi__table_clifwrap::pySequentialLatticeReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialLatticeReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialLatticeReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::LatticeHolder>>(std::move(c));
  return py;
}

// SequentialMatrixReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pySequentialMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pySequentialMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* cpp = __kaldi__table_clifwrap::pySequentialMatrixReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialMatrixReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialMatrixReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Matrix<float> > >>(std::move(c));
  return py;
}

// SequentialVectorReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pySequentialVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pySequentialVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialVectorReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pySequentialVectorReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialVectorReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialVectorReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialVectorReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialVectorReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(std::move(c));
  return py;
}

// SequentialWaveReader to/from ::kaldi::SequentialTableReader< ::kaldi::WaveHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pySequentialWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pySequentialWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialWaveReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pySequentialWaveReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialWaveReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialWaveReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::WaveHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialWaveReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialWaveReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::WaveHolder>>(std::move(c));
  return py;
}

// VectorWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyVectorWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* cpp = __kaldi__table_clifwrap::pyVectorWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyVectorWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert VectorWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyVectorWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyVectorWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::Vector<float> > >>(std::move(c));
  return py;
}

// WaveWriter to/from ::kaldi::TableWriter< ::kaldi::WaveHolder> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::WaveHolder>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyWaveWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyWaveWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyWaveWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::WaveHolder>>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::WaveHolder>* cpp = __kaldi__table_clifwrap::pyWaveWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyWaveWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert WaveWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::WaveHolder>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWaveWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWaveWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::WaveHolder>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWaveWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWaveWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::WaveHolder>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::WaveHolder>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWaveWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWaveWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::WaveHolder>>(std::move(c));
  return py;
}

// WspecifierOptions to/from ::kaldi::WspecifierOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::WspecifierOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::WspecifierOptions* cpp = __kaldi__table_clifwrap::pyWspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::WspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::WspecifierOptions* cpp = __kaldi__table_clifwrap::pyWspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::WspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::WspecifierOptions* cpp = __kaldi__table_clifwrap::pyWspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert WspecifierOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::WspecifierOptions* c) {
  assert(c != nullptr);
  ::kaldi::WspecifierOptions* cpp = __kaldi__table_clifwrap::pyWspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::WspecifierOptions>* c) {
  assert(c != nullptr);
  ::kaldi::WspecifierOptions* cpp = __kaldi__table_clifwrap::pyWspecifierOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::WspecifierOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WspecifierOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::WspecifierOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WspecifierOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::WspecifierOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WspecifierOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::WspecifierOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyWspecifierOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyWspecifierOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::WspecifierOptions>(c);
  return py;
}

// WspecifierType:IntEnum to/from enum ::kaldi::WspecifierType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::WspecifierType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __kaldi__table_clifwrap::_WspecifierType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum WspecifierType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::WspecifierType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::WspecifierType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::WspecifierType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__kaldi__table_clifwrap::_WspecifierType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::WspecifierType>::type>(c)), nullptr);
}

}  // namespace kaldi

namespace kaldi { namespace nnet3 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// NnetExampleWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyNnetExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyNnetExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyNnetExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetExampleWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyNnetExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(std::move(c));
  return py;
}

// RandomAccessNnetExampleReader to/from ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RandomAccessNnetExampleReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRandomAccessNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::RandomAccessTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(std::move(c));
  return py;
}

// SequentialNnetExampleReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pySequentialNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pySequentialNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* cpp = __kaldi__table_clifwrap::pySequentialNnetExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialNnetExampleReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialNnetExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::nnet3::NnetExample> >>(std::move(c));
  return py;
}

} }  // namespace kaldi::nnet3

namespace kaldi { namespace rnnlm {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// RnnlmExampleWriter to/from ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pyRnnlmExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pyRnnlmExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pyRnnlmExampleWriter::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmExampleWriter instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pyRnnlmExampleWriter::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::TableWriter< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(std::move(c));
  return py;
}

// SequentialRnnlmExampleReader to/from ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> > conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pySequentialRnnlmExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pySequentialRnnlmExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>* c) {
  assert(c != nullptr);
  ::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* cpp = __kaldi__table_clifwrap::pySequentialRnnlmExampleReader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SequentialRnnlmExampleReader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__table_clifwrap::pySequentialRnnlmExampleReader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SequentialTableReader< ::kaldi::KaldiObjectHolder< ::kaldi::rnnlm::RnnlmExample> >>(std::move(c));
  return py;
}

} }  // namespace kaldi::rnnlm
