//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/transform/cmvn.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "cmvn-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __cmvn_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// init_cmvn_stats(dim:int, stats:DoubleMatrix)
static PyObject* wrapInitCmvnStats_as_init_cmvn_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dim"),
      C("stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:init_cmvn_stats", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("init_cmvn_stats", names[0], "int", a[0]);
  ::kaldi::Matrix<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("init_cmvn_stats", names[1], "::kaldi::Matrix<double> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::InitCmvnStats(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// acc_cmvn_stats_single_frame(feat:VectorBase, weight:float, stats:DoubleMatrixBase)
static PyObject* wrapAccCmvnStats_as_acc_cmvn_stats_single_frame(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("feat"),
      C("weight"),
      C("stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:acc_cmvn_stats_single_frame", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("acc_cmvn_stats_single_frame", names[0], "::kaldi::VectorBase<float>", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("acc_cmvn_stats_single_frame", names[1], "float", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("acc_cmvn_stats_single_frame", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AccCmvnStats(*arg1, std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// acc_cmvn_stats(feats:MatrixBase, weights:VectorBase, stats:DoubleMatrixBase)
static PyObject* wrapAccCmvnStats_as_acc_cmvn_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("feats"),
      C("weights"),
      C("stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:acc_cmvn_stats", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("acc_cmvn_stats", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::VectorBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("acc_cmvn_stats", names[1], "::kaldi::VectorBase<float> *", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("acc_cmvn_stats", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AccCmvnStats(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_cmvn(stats:DoubleMatrixBase, norm_vars:bool, feats:MatrixBase)
static PyObject* wrapApplyCmvn_as_apply_cmvn(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("stats"),
      C("norm_vars"),
      C("feats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:apply_cmvn", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_cmvn", names[0], "::kaldi::MatrixBase<double>", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_cmvn", names[1], "bool", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("apply_cmvn", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ApplyCmvn(*arg1, std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_cmvn_reverse(stats:DoubleMatrixBase, norm_vars:bool, feats:MatrixBase)
static PyObject* wrapApplyCmvnReverse_as_apply_cmvn_reverse(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("stats"),
      C("norm_vars"),
      C("feats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:apply_cmvn_reverse", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_cmvn_reverse", names[0], "::kaldi::MatrixBase<double>", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_cmvn_reverse", names[1], "bool", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("apply_cmvn_reverse", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ApplyCmvnReverse(*arg1, std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// fake_stats_for_some_dims(dims:list<int>, stats:DoubleMatrixBase)
static PyObject* wrapFakeStatsForSomeDims_as_fake_stats_for_some_dims(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("dims"),
      C("stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:fake_stats_for_some_dims", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("fake_stats_for_some_dims", names[0], "::std::vector< ::int32>", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("fake_stats_for_some_dims", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::FakeStatsForSomeDims(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("init_cmvn_stats"), (PyCFunction)wrapInitCmvnStats_as_init_cmvn_stats, METH_VARARGS | METH_KEYWORDS, C("init_cmvn_stats(dim:int, stats:DoubleMatrix)\n  Calls C++ function\n  void ::kaldi::InitCmvnStats(int, ::kaldi::Matrix<double> *)")},
  {C("acc_cmvn_stats_single_frame"), (PyCFunction)wrapAccCmvnStats_as_acc_cmvn_stats_single_frame, METH_VARARGS | METH_KEYWORDS, C("acc_cmvn_stats_single_frame(feat:VectorBase, weight:float, stats:DoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::AccCmvnStats(::kaldi::VectorBase<float>, float, ::kaldi::MatrixBase<double> *)")},
  {C("acc_cmvn_stats"), (PyCFunction)wrapAccCmvnStats_as_acc_cmvn_stats, METH_VARARGS | METH_KEYWORDS, C("acc_cmvn_stats(feats:MatrixBase, weights:VectorBase, stats:DoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::AccCmvnStats(::kaldi::MatrixBase<float>, ::kaldi::VectorBase<float> *, ::kaldi::MatrixBase<double> *)")},
  {C("apply_cmvn"), (PyCFunction)wrapApplyCmvn_as_apply_cmvn, METH_VARARGS | METH_KEYWORDS, C("apply_cmvn(stats:DoubleMatrixBase, norm_vars:bool, feats:MatrixBase)\n  Calls C++ function\n  void ::kaldi::ApplyCmvn(::kaldi::MatrixBase<double>, bool, ::kaldi::MatrixBase<float> *)")},
  {C("apply_cmvn_reverse"), (PyCFunction)wrapApplyCmvnReverse_as_apply_cmvn_reverse, METH_VARARGS | METH_KEYWORDS, C("apply_cmvn_reverse(stats:DoubleMatrixBase, norm_vars:bool, feats:MatrixBase)\n  Calls C++ function\n  void ::kaldi::ApplyCmvnReverse(::kaldi::MatrixBase<double>, bool, ::kaldi::MatrixBase<float> *)")},
  {C("fake_stats_for_some_dims"), (PyCFunction)wrapFakeStatsForSomeDims_as_fake_stats_for_some_dims, METH_VARARGS | METH_KEYWORDS, C("fake_stats_for_some_dims(dims:list<int>, stats:DoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::FakeStatsForSomeDims(::std::vector< ::int32>, ::kaldi::MatrixBase<double> *)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_cmvn",  // module name
  "CLIF-generated module for transform/cmvn.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __cmvn_clifwrap
