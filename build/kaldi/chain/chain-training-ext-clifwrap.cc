//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/chain/chain-training-ext.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "cudamatrix/cu-matrix-clifwrap.h"
#include "chain/chain-den-graph-clifwrap.h"
#include "chain/chain-training-clifwrap.h"
#include "chain/chain-supervision-clifwrap.h"
#include "chain-training-ext-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __chain__training__ext_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// compute_chain_objf_and_deriv(opts:ChainTrainingOptions, den_graph:DenominatorGraph, supervision:Supervision, nnet_output:CuMatrixBase, nnet_output_deriv:CuMatrixBase, xent_output_deriv:CuMatrix) -> (objf:float, l2_term:float, weight:float)
static PyObject* wrapComputeChainObjfAndDerivExt_as_compute_chain_objf_and_deriv(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("opts"),
      C("den_graph"),
      C("supervision"),
      C("nnet_output"),
      C("nnet_output_deriv"),
      C("xent_output_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:compute_chain_objf_and_deriv", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::chain::ChainTrainingOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compute_chain_objf_and_deriv", names[0], "::kaldi::chain::ChainTrainingOptions", a[0]);
  ::kaldi::chain::DenominatorGraph* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compute_chain_objf_and_deriv", names[1], "::kaldi::chain::DenominatorGraph", a[1]);
  ::kaldi::chain::Supervision* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("compute_chain_objf_and_deriv", names[2], "::kaldi::chain::Supervision", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("compute_chain_objf_and_deriv", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float> * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("compute_chain_objf_and_deriv", names[4], "::kaldi::CuMatrixBase<float> *", a[4]);
  ::kaldi::CuMatrix<float> * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("compute_chain_objf_and_deriv", names[5], "::kaldi::CuMatrix<float> *", a[5]);
  float ret0{};
  float ret1{};
  float ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::chain::ComputeChainObjfAndDerivExt(*arg1, *arg2, *arg3, *arg4, arg5, arg6, &ret0, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("compute_chain_objf_and_deriv"), (PyCFunction)wrapComputeChainObjfAndDerivExt_as_compute_chain_objf_and_deriv, METH_VARARGS | METH_KEYWORDS, C("compute_chain_objf_and_deriv(opts:ChainTrainingOptions, den_graph:DenominatorGraph, supervision:Supervision, nnet_output:CuMatrixBase, nnet_output_deriv:CuMatrixBase, xent_output_deriv:CuMatrix) -> (objf:float, l2_term:float, weight:float)\n\nDoes both the numerator and denominator parts of the chain computation in one call.\n\nArgs:\n  opts (ChainTrainingOptions): Struct containing options\n  den_graph (DenominatorGraph): The denominator graph, derived from denominator fst.\n  supervision (Supervision): The supervision object containing the supervision paths and constrains\n  nnet_output (CuMatrixBase): The output of the neural net; dimension must equal ((supervision.num_sequences * supervision.frames_per_sequence) by den_graph.num_pdfs)\n  nnet_output_deriv (CuMatrixBase): The derivative of the objective function w.r.t. the neural net output\n  xent_output_deriv (CuMatrix): If non-NULL, then the numerator part of the derivative (equals the posterior from the numerator forward-backward, scaled by the supervision weight)\n\nReturns:\n  objf (float): The [num -den] objective function computed for this example\n  l2_term (float): The l2 regularization term in the objective function\n  weight (float): The weight to normalize the objective function by")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_chain_training_ext",  // module name
  "CLIF-generated module for chain/chain-training-ext.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_cu_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_chain_den_graph")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_chain_training")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_chain_supervision")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __chain__training__ext_clifwrap
