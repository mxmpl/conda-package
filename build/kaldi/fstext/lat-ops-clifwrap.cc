//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/lat-ops.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/getters-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "fstext/float-weight-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/encode-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "lat-ops-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __lat__ops_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// to_bytes(fst:LatticeFst) -> bytes
static PyObject* wrapFstToBytes_as_to_bytes(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:to_bytes", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("to_bytes", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::std::string ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::FstToBytes(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// from_bytes(s:bytes) -> LatticeFst
static PyObject* wrapBytesToLatticeFst_as_from_bytes(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("s"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_bytes", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_bytes", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::BytesToLatticeFst(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// verify(fst:LatticeFst) -> bool
static PyObject* wrapVerifyExt_as_verify(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:verify", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("verify", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::VerifyExt(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// count_states(fst:LatticeFst) -> int
static PyObject* wrapCountStatesExt_as_count_states(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:count_states", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("count_states", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::CountStatesExt(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// count_arcs(fst:LatticeFst) -> int
static PyObject* wrapCountArcsExt_as_count_arcs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:count_arcs", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("count_arcs", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::CountArcsExt(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// arcsort(fst:LatticeMutableFst, sort_type:ArcSortType)
static PyObject* wrapArcSortExt_as_arcsort(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("sort_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:arcsort", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("arcsort", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::script::ArcSortType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("arcsort", names[1], "::fst::script::ArcSortType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ArcSortExt(arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// closure(fst:LatticeMutableFst, closure_type:ClosureType)
static PyObject* wrapClosureExt_as_closure(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("closure_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:closure", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("closure", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::ClosureType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("closure", names[1], "::fst::ClosureType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ClosureExt(arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// concat(fst1:LatticeMutableFst, fst2:LatticeFst)
static PyObject* wrapConcatExt_as_concat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:concat", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("concat", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("concat", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ConcatExt(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// connect(fst:LatticeMutableFst)
static PyObject* wrapConnectExt_as_connect(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:connect", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("connect", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ConnectExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// decode(fst:LatticeMutableFst, mapper:LatticeEncodeMapper)
static PyObject* wrapDecodeExt_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:decode", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("decode", names[1], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::DecodeExt(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// encode(fst:LatticeMutableFst, mapper:LatticeEncodeMapper)
static PyObject* wrapEncodeExt_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:encode", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("encode", names[1], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::EncodeExt(arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// invert(fst:LatticeMutableFst)
static PyObject* wrapInvertExt_as_invert(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:invert", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("invert", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::InvertExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// minimize(fst:LatticeMutableFst, sfst:LatticeMutableFst=default, delta:float=default, allow_nondet:bool=default)
static PyObject* wrapMinimizeExt_as_minimize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("sfst"),
      C("delta"),
      C("allow_nondet"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:minimize", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("minimize", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("minimize", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("minimize", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  }
  float arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("minimize", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("minimize", names[2], "float", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("minimize", names[3], "bool", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ::fst::MinimizeExt(arg1); break;
  case 2:
    ::fst::MinimizeExt(arg1, arg2); break;
  case 3:
    ::fst::MinimizeExt(arg1, arg2, std::move(arg3)); break;
  case 4:
    ::fst::MinimizeExt(arg1, arg2, std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// project(fst:LatticeMutableFst, project_type:ProjectType)
static PyObject* wrapProjectExt_as_project(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("project_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:project", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("project", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::ProjectType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("project", names[1], "::fst::ProjectType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ProjectExt(arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// prune(fst:LatticeMutableFst, weight_threshold:LatticeWeight, state_threshold:int=default, delta:float=default)
static PyObject* wrapPruneExt_as_prune(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("weight_threshold"),
      C("state_threshold"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:prune", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("prune", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::LatticeWeightTpl<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("prune", names[1], "::fst::LatticeWeightTpl<float>", a[1]);
  int arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("prune", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("prune", names[2], "int", a[2]);
  }
  double arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("prune", names[3], "double", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::PruneExt(arg1, *arg2); break;
  case 3:
    ::fst::PruneExt(arg1, *arg2, std::move(arg3)); break;
  case 4:
    ::fst::PruneExt(arg1, *arg2, std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// push(fst:LatticeMutableFst, type:ReweightType, delta:float=default, remove_total_weight:bool=default)
static PyObject* wrapPushExt_as_push(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("type"),
      C("delta"),
      C("remove_total_weight"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:push", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("push", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::ReweightType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("push", names[1], "::fst::ReweightType", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("push", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("push", names[2], "float", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("push", names[3], "bool", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::PushExt(arg1, std::move(arg2)); break;
  case 3:
    ::fst::PushExt(arg1, std::move(arg2), std::move(arg3)); break;
  case 4:
    ::fst::PushExt(arg1, std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// relabel(fst:LatticeMutableFst, ipairs:list<tuple<int, int>>, opairs:list<tuple<int, int>>)
static PyObject* wrapRelabelExt_as_relabel(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("fst"),
      C("ipairs"),
      C("opairs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:relabel", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("relabel", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("relabel", names[1], "::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> >", a[1]);
  ::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> > arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("relabel", names[2], "::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> >", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RelabelExt(arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// relabel_tables(fst:LatticeMutableFst, old_isymbols:SymbolTable, new_isymbols:SymbolTable, unknown_isymbol:str, attach_new_isymbols:bool, old_osymbols:SymbolTable, new_osymbols:SymbolTable, unknown_osymbol:str, attach_new_osymbols:bool)
static PyObject* wrapRelabelTables_as_relabel_tables(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[9];
  char* names[] = {
      C("fst"),
      C("old_isymbols"),
      C("new_isymbols"),
      C("unknown_isymbol"),
      C("attach_new_isymbols"),
      C("old_osymbols"),
      C("new_osymbols"),
      C("unknown_osymbol"),
      C("attach_new_osymbols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOOO:relabel_tables", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("relabel_tables", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::SymbolTable * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("relabel_tables", names[1], "::fst::SymbolTable *", a[1]);
  ::fst::SymbolTable * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("relabel_tables", names[2], "::fst::SymbolTable *", a[2]);
  ::std::string arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("relabel_tables", names[3], "::std::string", a[3]);
  bool arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("relabel_tables", names[4], "bool", a[4]);
  ::fst::SymbolTable * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("relabel_tables", names[5], "::fst::SymbolTable *", a[5]);
  ::fst::SymbolTable * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("relabel_tables", names[6], "::fst::SymbolTable *", a[6]);
  ::std::string arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("relabel_tables", names[7], "::std::string", a[7]);
  bool arg9;
  if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("relabel_tables", names[8], "bool", a[8]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RelabelTables(arg1, arg2, arg3, std::move(arg4), std::move(arg5), arg6, arg7, std::move(arg8), std::move(arg9));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// reweight(fst:LatticeMutableFst, potential:list<LatticeWeight>, type:ReweightType)
static PyObject* wrapReweightExt_as_reweight(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("fst"),
      C("potential"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:reweight", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("reweight", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::std::vector<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Weight> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("reweight", names[1], "::std::vector<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Weight>", a[1]);
  ::fst::ReweightType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("reweight", names[2], "::fst::ReweightType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ReweightExt(arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// rmepsilon(fst:LatticeMutableFst, connect:bool=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, delta:float=default)
static PyObject* wrapRmEpsilonExt_as_rmepsilon(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("fst"),
      C("connect"),
      C("weight_threshold"),
      C("state_threshold"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOOO:rmepsilon", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("rmepsilon", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("rmepsilon", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("rmepsilon", names[1], "bool", a[1]);
  }
  ::fst::LatticeWeightTpl<float>* arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("rmepsilon", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("rmepsilon", names[2], "::fst::LatticeWeightTpl<float>", a[2]);
  }
  int arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("rmepsilon", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("rmepsilon", names[3], "int", a[3]);
  }
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("rmepsilon", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ::fst::RmEpsilonExt(arg1); break;
  case 2:
    ::fst::RmEpsilonExt(arg1, std::move(arg2)); break;
  case 3:
    ::fst::RmEpsilonExt(arg1, std::move(arg2), *arg3); break;
  case 4:
    ::fst::RmEpsilonExt(arg1, std::move(arg2), *arg3, std::move(arg4)); break;
  case 5:
    ::fst::RmEpsilonExt(arg1, std::move(arg2), *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// topsort(fst:LatticeMutableFst) -> bool
static PyObject* wrapTopSortExt_as_topsort(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:topsort", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("topsort", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::TopSortExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// union(fst1:LatticeMutableFst, fst2:LatticeFst)
static PyObject* wrapUnionExt_as_union(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:union", names, &a[0], &a[1])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("union", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("union", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::UnionExt(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map(ifst:LatticeFst, ofst:LatticeMutableFst, map_type:MapType, delta:float, weight:LatticeWeight)
static PyObject* wrapMapExt_as_map(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("map_type"),
      C("delta"),
      C("weight"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:map", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  ::fst::script::MapType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("map", names[2], "::fst::script::MapType", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("map", names[3], "float", a[3]);
  ::fst::LatticeWeightTpl<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("map", names[4], "::fst::LatticeWeightTpl<float>", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MapExt(*arg1, arg2, std::move(arg3), std::move(arg4), *arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compose(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)
static PyObject* wrapComposeExt_as_compose(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("ofst"),
      C("connect"),
      C("compose_filter"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:compose", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compose", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("compose", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("compose", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("compose", names[3], "bool", a[3]);
  ::fst::ComposeFilter arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("compose", names[4], "::fst::ComposeFilter", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ComposeExt(*arg1, *arg2, arg3, std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// determinize(ifst:LatticeFst, ofst:LatticeMutableFst, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, subsequential_label:int=default, type:DeterminizeType=default, increment_subsequential_label:bool=default)
static PyObject* wrapDeterminizeExt_as_determinize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      C("weight_threshold"),
      C("state_threshold"),
      C("subsequential_label"),
      C("type"),
      C("increment_subsequential_label"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOOOO:determinize", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 8; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("determinize", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("determinize", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("determinize", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("determinize", names[2], "float", a[2]);
  }
  ::fst::LatticeWeightTpl<float>* arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("determinize", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("determinize", names[3], "::fst::LatticeWeightTpl<float>", a[3]);
  }
  int arg5;
  if (nargs > 4) {
    if (!a[4]) return DefaultArgMissedError("determinize", names[4]);
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("determinize", names[4], "int", a[4]);
  }
  int arg6;
  if (nargs > 5) {
    if (!a[5]) return DefaultArgMissedError("determinize", names[5]);
    if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("determinize", names[5], "int", a[5]);
  }
  ::fst::DeterminizeType arg7;
  if (nargs > 6) {
    if (!a[6]) return DefaultArgMissedError("determinize", names[6]);
    if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("determinize", names[6], "::fst::DeterminizeType", a[6]);
  }
  bool arg8;
  if (nargs > 7) {
    if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("determinize", names[7], "bool", a[7]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::DeterminizeExt(*arg1, arg2); break;
  case 3:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3)); break;
  case 4:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3), *arg4); break;
  case 5:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  case 6:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6)); break;
  case 7:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6), std::move(arg7)); break;
  case 8:
    ::fst::DeterminizeExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// difference(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)
static PyObject* wrapDifferenceExt_as_difference(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("ofst"),
      C("connect"),
      C("compose_filter"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:difference", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("difference", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("difference", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("difference", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("difference", names[3], "bool", a[3]);
  ::fst::ComposeFilter arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("difference", names[4], "::fst::ComposeFilter", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::DifferenceExt(*arg1, *arg2, arg3, std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// disambiguate(ifst:LatticeFst, ofst:LatticeMutableFst, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, subsequential_label:int=default)
static PyObject* wrapDisambiguateExt_as_disambiguate(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      C("weight_threshold"),
      C("state_threshold"),
      C("subsequential_label"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOO:disambiguate", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 6; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("disambiguate", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("disambiguate", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("disambiguate", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("disambiguate", names[2], "float", a[2]);
  }
  ::fst::LatticeWeightTpl<float>* arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("disambiguate", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("disambiguate", names[3], "::fst::LatticeWeightTpl<float>", a[3]);
  }
  int arg5;
  if (nargs > 4) {
    if (!a[4]) return DefaultArgMissedError("disambiguate", names[4]);
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("disambiguate", names[4], "int", a[4]);
  }
  int arg6;
  if (nargs > 5) {
    if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("disambiguate", names[5], "int", a[5]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::DisambiguateExt(*arg1, arg2); break;
  case 3:
    ::fst::DisambiguateExt(*arg1, arg2, std::move(arg3)); break;
  case 4:
    ::fst::DisambiguateExt(*arg1, arg2, std::move(arg3), *arg4); break;
  case 5:
    ::fst::DisambiguateExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  case 6:
    ::fst::DisambiguateExt(*arg1, arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// epsnormalize(ifst:LatticeFst, ofst:LatticeMutableFst, type:EpsNormalizeType=default)
static PyObject* wrapEpsNormalizeExt_as_epsnormalize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:epsnormalize", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("epsnormalize", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("epsnormalize", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  ::fst::EpsNormalizeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("epsnormalize", names[2], "::fst::EpsNormalizeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::EpsNormalizeExt(*arg1, arg2); break;
  case 3:
    ::fst::EpsNormalizeExt(*arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// equal(ifst1:LatticeFst, ifst2:LatticeFst, delta:float=default) -> bool
static PyObject* wrapEqualExt_as_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:equal", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equal", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("equal", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("equal", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::fst::EqualExt(*arg1, *arg2); break;
  case 3:
    ret0 = ::fst::EqualExt(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// equivalent(ifst1:LatticeFst, ifst2:LatticeFst, delta:float) -> (result:bool, error:bool)
static PyObject* wrapEquivalentExt_as_equivalent(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:equivalent", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equivalent", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("equivalent", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  double arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("equivalent", names[2], "double", a[2]);
  bool ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::EquivalentExt(*arg1, *arg2, std::move(arg3), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// intersect(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)
static PyObject* wrapIntersectExt_as_intersect(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("ofst"),
      C("connect"),
      C("compose_filter"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:intersect", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("intersect", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("intersect", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("intersect", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("intersect", names[3], "bool", a[3]);
  ::fst::ComposeFilter arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("intersect", names[4], "::fst::ComposeFilter", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::IntersectExt(*arg1, *arg2, arg3, std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// isomorphic(ifst1:LatticeFst, ifst2:LatticeFst, delta:float=default) -> bool
static PyObject* wrapIsomorphicExt_as_isomorphic(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:isomorphic", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("isomorphic", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("isomorphic", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("isomorphic", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::fst::IsomorphicExt(*arg1, *arg2); break;
  case 3:
    ret0 = ::fst::IsomorphicExt(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// prune_cons(ifst:LatticeFst, ofst:LatticeMutableFst, weight_threshold:LatticeWeight, state_threshold:int=default, delta:float=default)
static PyObject* wrapPruneExt_as_prune_cons(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("weight_threshold"),
      C("state_threshold"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:prune_cons", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("prune_cons", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("prune_cons", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  ::fst::LatticeWeightTpl<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("prune_cons", names[2], "::fst::LatticeWeightTpl<float>", a[2]);
  int arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("prune_cons", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("prune_cons", names[3], "int", a[3]);
  }
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("prune_cons", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::fst::PruneExt(*arg1, arg2, *arg3); break;
  case 4:
    ::fst::PruneExt(*arg1, arg2, *arg3, std::move(arg4)); break;
  case 5:
    ::fst::PruneExt(*arg1, arg2, *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// push_cons(ifst:LatticeFst, ofst:LatticeMutableFst, flags:int, type:ReweightType, delta:float)
static PyObject* wrapPushExt_as_push_cons(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("flags"),
      C("type"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:push_cons", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("push_cons", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("push_cons", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  unsigned int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("push_cons", names[2], "unsigned int", a[2]);
  ::fst::ReweightType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("push_cons", names[3], "::fst::ReweightType", a[3]);
  float arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("push_cons", names[4], "float", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::PushExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// randequivalent(ifst1:LatticeFst, ifst2:LatticeFst, num_paths:int, delta:float, seed:int, selector_type:RandArcSelection, max_length:int) -> (result:bool, error:bool)
static PyObject* wrapRandEquivalentExt_as_randequivalent(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("num_paths"),
      C("delta"),
      C("seed"),
      C("selector_type"),
      C("max_length"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:randequivalent", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("randequivalent", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("randequivalent", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("randequivalent", names[2], "int", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("randequivalent", names[3], "float", a[3]);
  long arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("randequivalent", names[4], "long", a[4]);
  ::fst::script::RandArcSelection arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("randequivalent", names[5], "::fst::script::RandArcSelection", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("randequivalent", names[6], "int", a[6]);
  bool ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::RandEquivalentExt(*arg1, *arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// randgen(ifst:LatticeFst, ofst:LatticeMutableFst, seed:int, selector_type:RandArcSelection, max_length:int, num_paths:int, weighted:bool, remove_total_weight:bool)
static PyObject* wrapRandGenExt_as_randgen(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("seed"),
      C("selector_type"),
      C("max_length"),
      C("num_paths"),
      C("weighted"),
      C("remove_total_weight"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:randgen", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("randgen", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("randgen", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  long arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("randgen", names[2], "long", a[2]);
  ::fst::script::RandArcSelection arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("randgen", names[3], "::fst::script::RandArcSelection", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("randgen", names[4], "int", a[4]);
  int arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("randgen", names[5], "int", a[5]);
  bool arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("randgen", names[6], "bool", a[6]);
  bool arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("randgen", names[7], "bool", a[7]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RandGenExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// replace(pairs:list<tuple<int, LatticeFst>>, ofst:LatticeMutableFst, root_label:int, call_label_type:ReplaceLabelType, return_label_type:ReplaceLabelType, return_label:int)
static PyObject* wrapLatticeReplace_as_replace(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("pairs"),
      C("ofst"),
      C("root_label"),
      C("call_label_type"),
      C("return_label_type"),
      C("return_label"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:replace", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, ::fst::LatticeFst *> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("replace", names[0], "::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, ::fst::LatticeFst *> >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("replace", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  long arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("replace", names[2], "long", a[2]);
  ::fst::ReplaceLabelType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("replace", names[3], "::fst::ReplaceLabelType", a[3]);
  ::fst::ReplaceLabelType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("replace", names[4], "::fst::ReplaceLabelType", a[4]);
  long arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("replace", names[5], "long", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::LatticeReplace(std::move(arg1), arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// reverse(ifst:LatticeFst, ofst:LatticeMutableFst, require_superinitial:bool=default)
static PyObject* wrapReverseExt_as_reverse(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("require_superinitial"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:reverse", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("reverse", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("reverse", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("reverse", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::ReverseExt(*arg1, arg2); break;
  case 3:
    ::fst::ReverseExt(*arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// rmepsiloncons(ifst:LatticeFst, ofst:LatticeMutableFst, connect:bool=default, reverse:bool=default, queue_type:QueueType=default, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default)
static PyObject* wrapRmEpsilonExt_as_rmepsiloncons(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("connect"),
      C("reverse"),
      C("queue_type"),
      C("delta"),
      C("weight_threshold"),
      C("state_threshold"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOOOO:rmepsiloncons", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 8; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("rmepsiloncons", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("rmepsiloncons", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("rmepsiloncons", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("rmepsiloncons", names[2], "bool", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("rmepsiloncons", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("rmepsiloncons", names[3], "bool", a[3]);
  }
  ::fst::QueueType arg5;
  if (nargs > 4) {
    if (!a[4]) return DefaultArgMissedError("rmepsiloncons", names[4]);
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("rmepsiloncons", names[4], "::fst::QueueType", a[4]);
  }
  float arg6;
  if (nargs > 5) {
    if (!a[5]) return DefaultArgMissedError("rmepsiloncons", names[5]);
    if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("rmepsiloncons", names[5], "float", a[5]);
  }
  ::fst::LatticeWeightTpl<float>* arg7;
  if (nargs > 6) {
    if (!a[6]) return DefaultArgMissedError("rmepsiloncons", names[6]);
    if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("rmepsiloncons", names[6], "::fst::LatticeWeightTpl<float>", a[6]);
  }
  int arg8;
  if (nargs > 7) {
    if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("rmepsiloncons", names[7], "int", a[7]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::RmEpsilonExt(*arg1, arg2); break;
  case 3:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3)); break;
  case 4:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3), std::move(arg4)); break;
  case 5:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5)); break;
  case 6:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6)); break;
  case 7:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), *arg7); break;
  case 8:
    ::fst::RmEpsilonExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), *arg7, std::move(arg8)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// shortestdistance(fst:LatticeFst, reverse:bool=default, source:int=default, queue_type:QueueType=default, delta:float=default) -> list<LatticeWeight>
static PyObject* wrapShortestDistanceExt_as_shortestdistance(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("fst"),
      C("reverse"),
      C("source"),
      C("queue_type"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOOO:shortestdistance", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("shortestdistance", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("shortestdistance", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("shortestdistance", names[1], "bool", a[1]);
  }
  int arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("shortestdistance", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("shortestdistance", names[2], "int", a[2]);
  }
  ::fst::QueueType arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("shortestdistance", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("shortestdistance", names[3], "::fst::QueueType", a[3]);
  }
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("shortestdistance", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::vector<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Weight> * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::ShortestDistanceExt(*arg1); break;
  case 2:
    ret0 = ::fst::ShortestDistanceExt(*arg1, std::move(arg2)); break;
  case 3:
    ret0 = ::fst::ShortestDistanceExt(*arg1, std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::fst::ShortestDistanceExt(*arg1, std::move(arg2), std::move(arg3), std::move(arg4)); break;
  case 5:
    ret0 = ::fst::ShortestDistanceExt(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// shortestpath(ifst:LatticeFst, ofst:LatticeMutableFst, nshortest:int=default, unique:bool=default, queue_type:QueueType=default, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default)
static PyObject* wrapShortestPathExt_as_shortestpath(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("nshortest"),
      C("unique"),
      C("queue_type"),
      C("delta"),
      C("weight_threshold"),
      C("state_threshold"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OOOOOO:shortestpath", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 8; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("shortestpath", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("shortestpath", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  int arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("shortestpath", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("shortestpath", names[2], "int", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("shortestpath", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("shortestpath", names[3], "bool", a[3]);
  }
  ::fst::QueueType arg5;
  if (nargs > 4) {
    if (!a[4]) return DefaultArgMissedError("shortestpath", names[4]);
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("shortestpath", names[4], "::fst::QueueType", a[4]);
  }
  float arg6;
  if (nargs > 5) {
    if (!a[5]) return DefaultArgMissedError("shortestpath", names[5]);
    if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("shortestpath", names[5], "float", a[5]);
  }
  ::fst::LatticeWeightTpl<float>* arg7;
  if (nargs > 6) {
    if (!a[6]) return DefaultArgMissedError("shortestpath", names[6]);
    if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("shortestpath", names[6], "::fst::LatticeWeightTpl<float>", a[6]);
  }
  int arg8;
  if (nargs > 7) {
    if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("shortestpath", names[7], "int", a[7]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::ShortestPathExt(*arg1, arg2); break;
  case 3:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3)); break;
  case 4:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3), std::move(arg4)); break;
  case 5:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5)); break;
  case 6:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6)); break;
  case 7:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), *arg7); break;
  case 8:
    ::fst::ShortestPathExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), *arg7, std::move(arg8)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// synchronize(ifst:LatticeFst, ofst:LatticeMutableFst)
static PyObject* wrapSynchronizeExt_as_synchronize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:synchronize", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("synchronize", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("synchronize", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::SynchronizeExt(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("to_bytes"), (PyCFunction)wrapFstToBytes_as_to_bytes, METH_VARARGS | METH_KEYWORDS, C("to_bytes(fst:LatticeFst) -> bytes\n  Calls C++ function\n  void ::fst::FstToBytes(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::std::string*)")},
  {C("from_bytes"), (PyCFunction)wrapBytesToLatticeFst_as_from_bytes, METH_VARARGS | METH_KEYWORDS, C("from_bytes(s:bytes) -> LatticeFst\n  Calls C++ function\n  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * ::fst::BytesToLatticeFst(::std::string)")},
  {C("verify"), (PyCFunction)wrapVerifyExt_as_verify, METH_VARARGS | METH_KEYWORDS, C("verify(fst:LatticeFst) -> bool\n  Calls C++ function\n  bool ::fst::VerifyExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("count_states"), (PyCFunction)wrapCountStatesExt_as_count_states, METH_VARARGS | METH_KEYWORDS, C("count_states(fst:LatticeFst) -> int\n  Calls C++ function\n  int ::fst::CountStatesExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("count_arcs"), (PyCFunction)wrapCountArcsExt_as_count_arcs, METH_VARARGS | METH_KEYWORDS, C("count_arcs(fst:LatticeFst) -> int\n  Calls C++ function\n  int ::fst::CountArcsExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("arcsort"), (PyCFunction)wrapArcSortExt_as_arcsort, METH_VARARGS | METH_KEYWORDS, C("arcsort(fst:LatticeMutableFst, sort_type:ArcSortType)\n  Calls C++ function\n  void ::fst::ArcSortExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::script::ArcSortType)")},
  {C("closure"), (PyCFunction)wrapClosureExt_as_closure, METH_VARARGS | METH_KEYWORDS, C("closure(fst:LatticeMutableFst, closure_type:ClosureType)\n  Calls C++ function\n  void ::fst::ClosureExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::ClosureType)")},
  {C("concat"), (PyCFunction)wrapConcatExt_as_concat, METH_VARARGS | METH_KEYWORDS, C("concat(fst1:LatticeMutableFst, fst2:LatticeFst)\n  Calls C++ function\n  void ::fst::ConcatExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("connect"), (PyCFunction)wrapConnectExt_as_connect, METH_VARARGS | METH_KEYWORDS, C("connect(fst:LatticeMutableFst)\n  Calls C++ function\n  void ::fst::ConnectExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {C("decode"), (PyCFunction)wrapDecodeExt_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(fst:LatticeMutableFst, mapper:LatticeEncodeMapper)\n  Calls C++ function\n  void ::fst::DecodeExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("encode"), (PyCFunction)wrapEncodeExt_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(fst:LatticeMutableFst, mapper:LatticeEncodeMapper)\n  Calls C++ function\n  void ::fst::EncodeExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {C("invert"), (PyCFunction)wrapInvertExt_as_invert, METH_VARARGS | METH_KEYWORDS, C("invert(fst:LatticeMutableFst)\n  Calls C++ function\n  void ::fst::InvertExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {C("minimize"), (PyCFunction)wrapMinimizeExt_as_minimize, METH_VARARGS | METH_KEYWORDS, C("minimize(fst:LatticeMutableFst, sfst:LatticeMutableFst=default, delta:float=default, allow_nondet:bool=default)\n  Calls C++ function\n  void ::fst::MinimizeExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, float, bool)")},
  {C("project"), (PyCFunction)wrapProjectExt_as_project, METH_VARARGS | METH_KEYWORDS, C("project(fst:LatticeMutableFst, project_type:ProjectType)\n  Calls C++ function\n  void ::fst::ProjectExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::ProjectType)")},
  {C("prune"), (PyCFunction)wrapPruneExt_as_prune, METH_VARARGS | METH_KEYWORDS, C("prune(fst:LatticeMutableFst, weight_threshold:LatticeWeight, state_threshold:int=default, delta:float=default)\n  Calls C++ function\n  void ::fst::PruneExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::LatticeWeightTpl<float>, int, double)")},
  {C("push"), (PyCFunction)wrapPushExt_as_push, METH_VARARGS | METH_KEYWORDS, C("push(fst:LatticeMutableFst, type:ReweightType, delta:float=default, remove_total_weight:bool=default)\n  Calls C++ function\n  void ::fst::PushExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::ReweightType, float, bool)")},
  {C("relabel"), (PyCFunction)wrapRelabelExt_as_relabel, METH_VARARGS | METH_KEYWORDS, C("relabel(fst:LatticeMutableFst, ipairs:list<tuple<int, int>>, opairs:list<tuple<int, int>>)\n  Calls C++ function\n  void ::fst::RelabelExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> >, ::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label> >)")},
  {C("relabel_tables"), (PyCFunction)wrapRelabelTables_as_relabel_tables, METH_VARARGS | METH_KEYWORDS, C("relabel_tables(fst:LatticeMutableFst, old_isymbols:SymbolTable, new_isymbols:SymbolTable, unknown_isymbol:str, attach_new_isymbols:bool, old_osymbols:SymbolTable, new_osymbols:SymbolTable, unknown_osymbol:str, attach_new_osymbols:bool)\n  Calls C++ function\n  void ::fst::RelabelTables(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::SymbolTable *, ::fst::SymbolTable *, ::std::string, bool, ::fst::SymbolTable *, ::fst::SymbolTable *, ::std::string, bool)")},
  {C("reweight"), (PyCFunction)wrapReweightExt_as_reweight, METH_VARARGS | METH_KEYWORDS, C("reweight(fst:LatticeMutableFst, potential:list<LatticeWeight>, type:ReweightType)\n  Calls C++ function\n  void ::fst::ReweightExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::std::vector<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Weight>, ::fst::ReweightType)")},
  {C("rmepsilon"), (PyCFunction)wrapRmEpsilonExt_as_rmepsilon, METH_VARARGS | METH_KEYWORDS, C("rmepsilon(fst:LatticeMutableFst, connect:bool=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, delta:float=default)\n  Calls C++ function\n  void ::fst::RmEpsilonExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool, ::fst::LatticeWeightTpl<float>, int, float)")},
  {C("topsort"), (PyCFunction)wrapTopSortExt_as_topsort, METH_VARARGS | METH_KEYWORDS, C("topsort(fst:LatticeMutableFst) -> bool\n  Calls C++ function\n  bool ::fst::TopSortExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {C("union"), (PyCFunction)wrapUnionExt_as_union, METH_VARARGS | METH_KEYWORDS, C("union(fst1:LatticeMutableFst, fst2:LatticeFst)\n  Calls C++ function\n  void ::fst::UnionExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >)")},
  {C("map"), (PyCFunction)wrapMapExt_as_map, METH_VARARGS | METH_KEYWORDS, C("map(ifst:LatticeFst, ofst:LatticeMutableFst, map_type:MapType, delta:float, weight:LatticeWeight)\n  Calls C++ function\n  void ::fst::MapExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::script::MapType, float, ::fst::LatticeWeightTpl<float>)")},
  {C("compose"), (PyCFunction)wrapComposeExt_as_compose, METH_VARARGS | METH_KEYWORDS, C("compose(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)\n  Calls C++ function\n  void ::fst::ComposeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool, ::fst::ComposeFilter)")},
  {C("determinize"), (PyCFunction)wrapDeterminizeExt_as_determinize, METH_VARARGS | METH_KEYWORDS, C("determinize(ifst:LatticeFst, ofst:LatticeMutableFst, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, subsequential_label:int=default, type:DeterminizeType=default, increment_subsequential_label:bool=default)\n  Calls C++ function\n  void ::fst::DeterminizeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, float, ::fst::LatticeWeightTpl<float>, int, int, ::fst::DeterminizeType, bool)")},
  {C("difference"), (PyCFunction)wrapDifferenceExt_as_difference, METH_VARARGS | METH_KEYWORDS, C("difference(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)\n  Calls C++ function\n  void ::fst::DifferenceExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool, ::fst::ComposeFilter)")},
  {C("disambiguate"), (PyCFunction)wrapDisambiguateExt_as_disambiguate, METH_VARARGS | METH_KEYWORDS, C("disambiguate(ifst:LatticeFst, ofst:LatticeMutableFst, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default, subsequential_label:int=default)\n  Calls C++ function\n  void ::fst::DisambiguateExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, float, ::fst::LatticeWeightTpl<float>, int, int)")},
  {C("epsnormalize"), (PyCFunction)wrapEpsNormalizeExt_as_epsnormalize, METH_VARARGS | METH_KEYWORDS, C("epsnormalize(ifst:LatticeFst, ofst:LatticeMutableFst, type:EpsNormalizeType=default)\n  Calls C++ function\n  void ::fst::EpsNormalizeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::EpsNormalizeType)")},
  {C("equal"), (PyCFunction)wrapEqualExt_as_equal, METH_VARARGS | METH_KEYWORDS, C("equal(ifst1:LatticeFst, ifst2:LatticeFst, delta:float=default) -> bool\n  Calls C++ function\n  bool ::fst::EqualExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, float)")},
  {C("equivalent"), (PyCFunction)wrapEquivalentExt_as_equivalent, METH_VARARGS | METH_KEYWORDS, C("equivalent(ifst1:LatticeFst, ifst2:LatticeFst, delta:float) -> (result:bool, error:bool)\n  Calls C++ function\n  bool ::fst::EquivalentExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, double, bool*)")},
  {C("intersect"), (PyCFunction)wrapIntersectExt_as_intersect, METH_VARARGS | METH_KEYWORDS, C("intersect(ifst1:LatticeFst, ifst2:LatticeFst, ofst:LatticeMutableFst, connect:bool, compose_filter:ComposeFilter)\n  Calls C++ function\n  void ::fst::IntersectExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool, ::fst::ComposeFilter)")},
  {C("isomorphic"), (PyCFunction)wrapIsomorphicExt_as_isomorphic, METH_VARARGS | METH_KEYWORDS, C("isomorphic(ifst1:LatticeFst, ifst2:LatticeFst, delta:float=default) -> bool\n  Calls C++ function\n  bool ::fst::IsomorphicExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, float)")},
  {C("prune_cons"), (PyCFunction)wrapPruneExt_as_prune_cons, METH_VARARGS | METH_KEYWORDS, C("prune_cons(ifst:LatticeFst, ofst:LatticeMutableFst, weight_threshold:LatticeWeight, state_threshold:int=default, delta:float=default)\n  Calls C++ function\n  void ::fst::PruneExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::LatticeWeightTpl<float>, int, float)")},
  {C("push_cons"), (PyCFunction)wrapPushExt_as_push_cons, METH_VARARGS | METH_KEYWORDS, C("push_cons(ifst:LatticeFst, ofst:LatticeMutableFst, flags:int, type:ReweightType, delta:float)\n  Calls C++ function\n  void ::fst::PushExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, unsigned int, ::fst::ReweightType, float)")},
  {C("randequivalent"), (PyCFunction)wrapRandEquivalentExt_as_randequivalent, METH_VARARGS | METH_KEYWORDS, C("randequivalent(ifst1:LatticeFst, ifst2:LatticeFst, num_paths:int, delta:float, seed:int, selector_type:RandArcSelection, max_length:int) -> (result:bool, error:bool)\n  Calls C++ function\n  bool ::fst::RandEquivalentExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, int, float, long, ::fst::script::RandArcSelection, int, bool*)")},
  {C("randgen"), (PyCFunction)wrapRandGenExt_as_randgen, METH_VARARGS | METH_KEYWORDS, C("randgen(ifst:LatticeFst, ofst:LatticeMutableFst, seed:int, selector_type:RandArcSelection, max_length:int, num_paths:int, weighted:bool, remove_total_weight:bool)\n  Calls C++ function\n  void ::fst::RandGenExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, long, ::fst::script::RandArcSelection, int, int, bool, bool)")},
  {C("replace"), (PyCFunction)wrapLatticeReplace_as_replace, METH_VARARGS | METH_KEYWORDS, C("replace(pairs:list<tuple<int, LatticeFst>>, ofst:LatticeMutableFst, root_label:int, call_label_type:ReplaceLabelType, return_label_type:ReplaceLabelType, return_label:int)\n  Calls C++ function\n  void ::fst::LatticeReplace(::std::vector< ::std::pair<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Label, ::fst::LatticeFst *> >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, long, ::fst::ReplaceLabelType, ::fst::ReplaceLabelType, long)")},
  {C("reverse"), (PyCFunction)wrapReverseExt_as_reverse, METH_VARARGS | METH_KEYWORDS, C("reverse(ifst:LatticeFst, ofst:LatticeMutableFst, require_superinitial:bool=default)\n  Calls C++ function\n  void ::fst::ReverseExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool)")},
  {C("rmepsiloncons"), (PyCFunction)wrapRmEpsilonExt_as_rmepsiloncons, METH_VARARGS | METH_KEYWORDS, C("rmepsiloncons(ifst:LatticeFst, ofst:LatticeMutableFst, connect:bool=default, reverse:bool=default, queue_type:QueueType=default, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default)\n  Calls C++ function\n  void ::fst::RmEpsilonExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool, bool, ::fst::QueueType, float, ::fst::LatticeWeightTpl<float>, int)")},
  {C("shortestdistance"), (PyCFunction)wrapShortestDistanceExt_as_shortestdistance, METH_VARARGS | METH_KEYWORDS, C("shortestdistance(fst:LatticeFst, reverse:bool=default, source:int=default, queue_type:QueueType=default, delta:float=default) -> list<LatticeWeight>\n  Calls C++ function\n  ::std::vector<typename ::fst::ArcTpl<LatticeWeightTpl<float> >::Weight> * ::fst::ShortestDistanceExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, bool, int, ::fst::QueueType, float)")},
  {C("shortestpath"), (PyCFunction)wrapShortestPathExt_as_shortestpath, METH_VARARGS | METH_KEYWORDS, C("shortestpath(ifst:LatticeFst, ofst:LatticeMutableFst, nshortest:int=default, unique:bool=default, queue_type:QueueType=default, delta:float=default, weight_threshold:LatticeWeight=default, state_threshold:int=default)\n  Calls C++ function\n  void ::fst::ShortestPathExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, int, bool, ::fst::QueueType, float, ::fst::LatticeWeightTpl<float>, int)")},
  {C("synchronize"), (PyCFunction)wrapSynchronizeExt_as_synchronize, METH_VARARGS | METH_KEYWORDS, C("synchronize(ifst:LatticeFst, ofst:LatticeMutableFst)\n  Calls C++ function\n  void ::fst::SynchronizeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_lat_ops",  // module name
  "CLIF-generated module for fstext/fst-ops.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_getters")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_float_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_encode")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __lat__ops_clifwrap
