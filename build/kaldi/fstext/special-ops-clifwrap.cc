//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/special-ops.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/getters-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "fstext/context-fst-clifwrap.h"
#include "fstext/deterministic-fst-clifwrap.h"
#include "fstext/determinize-lattice-clifwrap.h"
#include "special-ops-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __special__ops_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _compose_context_fst(ifst1:StdContextFst, ifst2:StdFst, ofst:StdMutableFst, connect:bool=default, compose_filter:ComposeFilter=default)
static PyObject* wrapComposeContextFstExt_as__compose_context_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("ifst1"),
      C("ifst2"),
      C("ofst"),
      C("connect"),
      C("compose_filter"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO|OO:_compose_context_fst", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 3; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::ContextFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compose_context_fst", names[0], "::fst::ContextFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, int>", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compose_context_fst", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_compose_context_fst", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[2]);
  bool arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("_compose_context_fst", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_compose_context_fst", names[3], "bool", a[3]);
  }
  ::fst::ComposeFilter arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_compose_context_fst", names[4], "::fst::ComposeFilter", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 3:
    ::fst::ComposeContextFstExt(*arg1, *arg2, arg3); break;
  case 4:
    ::fst::ComposeContextFstExt(*arg1, *arg2, arg3, std::move(arg4)); break;
  case 5:
    ::fst::ComposeContextFstExt(*arg1, *arg2, arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _compose_context(disambig_syms:list<int>, N:int, P:int, ifst:StdVectorFst, ofst:StdVectorFst) -> list<list<int>>
static PyObject* wrapComposeContextExt_as__compose_context(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("disambig_syms"),
      C("N"),
      C("P"),
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:_compose_context", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compose_context", names[0], "::std::vector< ::int32>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compose_context", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_compose_context", names[2], "int", a[2]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_compose_context", names[3], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[3]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_compose_context", names[4], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[4]);
  ::std::vector< ::std::vector< ::int32> > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ComposeContextExt(std::move(arg1), std::move(arg2), std::move(arg3), arg4, arg5, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// add_subsequential_loop(subseq_symbol:int, fst:StdMutableFst)
static PyObject* wrapAddSubsequentialLoopExt_as_add_subsequential_loop(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("subseq_symbol"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_subsequential_loop", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_subsequential_loop", names[0], "int", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_subsequential_loop", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AddSubsequentialLoopExt(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _compose_deterministic_on_demand(fst1:StdFst, fst2:StdDeterministicOnDemandFst, ofst:StdMutableFst)
static PyObject* wrapComposeDeterministicOnDemandExt_as__compose_deterministic_on_demand(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_compose_deterministic_on_demand", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compose_deterministic_on_demand", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compose_deterministic_on_demand", names[1], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_compose_deterministic_on_demand", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ComposeDeterministicOnDemandExt(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _compose_deterministic_on_demand_inverse(fst1:StdFst, fst2:StdDeterministicOnDemandFst, ofst:StdMutableFst)
static PyObject* wrapComposeDeterministicOnDemandInverseExt_as__compose_deterministic_on_demand_inverse(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_compose_deterministic_on_demand_inverse", names, &a[0], &a[1], &a[2])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_compose_deterministic_on_demand_inverse", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_compose_deterministic_on_demand_inverse", names[1], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_compose_deterministic_on_demand_inverse", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ComposeDeterministicOnDemandInverseExt(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _determinize_lattice(ifst:LatticeFst, ofst:LatticeMutableFst, opts:DeterminizeLatticeOptions=default) -> bool
static PyObject* wrapDeterminizeLatticeExt_as__determinize_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_determinize_lattice", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_determinize_lattice", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_determinize_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  ::fst::DeterminizeLatticeOptions* arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_determinize_lattice", names[2], "::fst::DeterminizeLatticeOptions", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::fst::DeterminizeLatticeExt(*arg1, arg2); break;
  case 3:
    ret0 = ::fst::DeterminizeLatticeExt(*arg1, arg2, *arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _determinize_lattice_to_compact(ifst:LatticeFst, ofst:CompactLatticeMutableFst, opts:DeterminizeLatticeOptions=default) -> bool
static PyObject* wrapDeterminizeLatticeExt_as__determinize_lattice_to_compact(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_determinize_lattice_to_compact", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_determinize_lattice_to_compact", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_determinize_lattice_to_compact", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[1]);
  ::fst::DeterminizeLatticeOptions* arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_determinize_lattice_to_compact", names[2], "::fst::DeterminizeLatticeOptions", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::fst::DeterminizeLatticeExt(*arg1, arg2); break;
  case 3:
    ret0 = ::fst::DeterminizeLatticeExt(*arg1, arg2, *arg3); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _determinize_star(ifst:StdFst, ofst:StdMutableFst, delta:float=default, max_states:int=default, allow_partial:bool=default) -> bool
static PyObject* wrapDeterminizeStarExt_as__determinize_star(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      C("max_states"),
      C("allow_partial"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OOO:_determinize_star", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_determinize_star", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_determinize_star", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("_determinize_star", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_determinize_star", names[2], "float", a[2]);
  }
  int arg4;
  if (nargs > 3) {
    if (!a[3]) return DefaultArgMissedError("_determinize_star", names[3]);
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_determinize_star", names[3], "int", a[3]);
  }
  bool arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_determinize_star", names[4], "bool", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::fst::DeterminizeStarExt(*arg1, arg2); break;
  case 3:
    ret0 = ::fst::DeterminizeStarExt(*arg1, arg2, std::move(arg3)); break;
  case 4:
    ret0 = ::fst::DeterminizeStarExt(*arg1, arg2, std::move(arg3), std::move(arg4)); break;
  case 5:
    ret0 = ::fst::DeterminizeStarExt(*arg1, arg2, std::move(arg3), std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _remove_eps_local(fst:StdMutableFst)
static PyObject* wrapRemoveEpsLocalExt_as__remove_eps_local(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_eps_local", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_eps_local", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveEpsLocalExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _remove_eps_local_special(fst:StdMutableFst)
static PyObject* wrapRemoveEpsLocalSpecialExt_as__remove_eps_local_special(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_eps_local_special", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_eps_local_special", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveEpsLocalSpecialExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _push_in_log(fst:StdVectorFst, ptype:int, delta:float=default, to_final:bool=default)
static PyObject* wrapPushInLogExt_as__push_in_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("ptype"),
      C("delta"),
      C("to_final"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:_push_in_log", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_push_in_log", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[0]);
  unsigned int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_push_in_log", names[1], "unsigned int", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (float)9.765625e-04;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_push_in_log", names[2], "float", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!a[3]) arg4 = (bool)false;
    else if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_push_in_log", names[3], "bool", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::PushInLogExt(arg1, std::move(arg2)); break;
  case 3:
    ::fst::PushInLogExt(arg1, std::move(arg2), std::move(arg3)); break;
  case 4:
    ::fst::PushInLogExt(arg1, std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// determinize_star_in_log(fst:StdVectorFst, delta:float=default, max_states:int=default)
static PyObject* wrapDeterminizeStarInLogExt_as_determinize_star_in_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("fst"),
      C("delta"),
      C("max_states"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:determinize_star_in_log", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("determinize_star_in_log", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)9.765625e-04;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("determinize_star_in_log", names[1], "float", a[1]);
  }
  int arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (int)-1;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("determinize_star_in_log", names[2], "int", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ::fst::DeterminizeStarInLogExt(arg1); break;
  case 2:
    ::fst::DeterminizeStarInLogExt(arg1, std::move(arg2)); break;
  case 3:
    ::fst::DeterminizeStarInLogExt(arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_compose_context_fst"), (PyCFunction)wrapComposeContextFstExt_as__compose_context_fst, METH_VARARGS | METH_KEYWORDS, C("_compose_context_fst(ifst1:StdContextFst, ifst2:StdFst, ofst:StdMutableFst, connect:bool=default, compose_filter:ComposeFilter=default)\n  Calls C++ function\n  void ::fst::ComposeContextFstExt(::fst::ContextFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, int>, ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, bool, ::fst::ComposeFilter)")},
  {C("_compose_context"), (PyCFunction)wrapComposeContextExt_as__compose_context, METH_VARARGS | METH_KEYWORDS, C("_compose_context(disambig_syms:list<int>, N:int, P:int, ifst:StdVectorFst, ofst:StdVectorFst) -> list<list<int>>\n  Calls C++ function\n  void ::fst::ComposeContextExt(::std::vector< ::int32>, int, int, ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *, ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *, ::std::vector< ::std::vector< ::int32> >*)")},
  {C("add_subsequential_loop"), (PyCFunction)wrapAddSubsequentialLoopExt_as_add_subsequential_loop, METH_VARARGS | METH_KEYWORDS, C("add_subsequential_loop(subseq_symbol:int, fst:StdMutableFst)\n\nAdds a subsequential symbol loop to the input FST.\n\nModifies the FST so that it transuces the same paths, but the input side\nof the paths can all have the subsequential symbol '$' appended to them\nany number of times.\n\nArgs:\n  subseq_symbol (int): Integer index for the subsequential symbol.\n  fst (StdFst): Input FST.")},
  {C("_compose_deterministic_on_demand"), (PyCFunction)wrapComposeDeterministicOnDemandExt_as__compose_deterministic_on_demand, METH_VARARGS | METH_KEYWORDS, C("_compose_deterministic_on_demand(fst1:StdFst, fst2:StdDeterministicOnDemandFst, ofst:StdMutableFst)\n  Calls C++ function\n  void ::fst::ComposeDeterministicOnDemandExt(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("_compose_deterministic_on_demand_inverse"), (PyCFunction)wrapComposeDeterministicOnDemandInverseExt_as__compose_deterministic_on_demand_inverse, METH_VARARGS | METH_KEYWORDS, C("_compose_deterministic_on_demand_inverse(fst1:StdFst, fst2:StdDeterministicOnDemandFst, ofst:StdMutableFst)\n  Calls C++ function\n  void ::fst::ComposeDeterministicOnDemandInverseExt(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("_determinize_lattice"), (PyCFunction)wrapDeterminizeLatticeExt_as__determinize_lattice, METH_VARARGS | METH_KEYWORDS, C("_determinize_lattice(ifst:LatticeFst, ofst:LatticeMutableFst, opts:DeterminizeLatticeOptions=default) -> bool\n  Calls C++ function\n  bool ::fst::DeterminizeLatticeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, ::fst::DeterminizeLatticeOptions)")},
  {C("_determinize_lattice_to_compact"), (PyCFunction)wrapDeterminizeLatticeExt_as__determinize_lattice_to_compact, METH_VARARGS | METH_KEYWORDS, C("_determinize_lattice_to_compact(ifst:LatticeFst, ofst:CompactLatticeMutableFst, opts:DeterminizeLatticeOptions=default) -> bool\n  Calls C++ function\n  bool ::fst::DeterminizeLatticeExt(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *, ::fst::DeterminizeLatticeOptions)")},
  {C("_determinize_star"), (PyCFunction)wrapDeterminizeStarExt_as__determinize_star, METH_VARARGS | METH_KEYWORDS, C("_determinize_star(ifst:StdFst, ofst:StdMutableFst, delta:float=default, max_states:int=default, allow_partial:bool=default) -> bool\n  Calls C++ function\n  bool ::fst::DeterminizeStarExt(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, float, int, bool)")},
  {C("_remove_eps_local"), (PyCFunction)wrapRemoveEpsLocalExt_as__remove_eps_local, METH_VARARGS | METH_KEYWORDS, C("_remove_eps_local(fst:StdMutableFst)\n  Calls C++ function\n  void ::fst::RemoveEpsLocalExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("_remove_eps_local_special"), (PyCFunction)wrapRemoveEpsLocalSpecialExt_as__remove_eps_local_special, METH_VARARGS | METH_KEYWORDS, C("_remove_eps_local_special(fst:StdMutableFst)\n  Calls C++ function\n  void ::fst::RemoveEpsLocalSpecialExt(::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("_push_in_log"), (PyCFunction)wrapPushInLogExt_as__push_in_log, METH_VARARGS | METH_KEYWORDS, C("_push_in_log(fst:StdVectorFst, ptype:int, delta:float=default, to_final:bool=default)\n  Calls C++ function\n  void ::fst::PushInLogExt(::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *, unsigned int, float, bool)")},
  {C("determinize_star_in_log"), (PyCFunction)wrapDeterminizeStarInLogExt_as_determinize_star_in_log, METH_VARARGS | METH_KEYWORDS, C("determinize_star_in_log(fst:StdVectorFst, delta:float=default, max_states:int=default)\n\nPerforms determinize_star in place in log semiring.\n\nArgs:\n    ifst (StdFst): Input fst over the tropical semiring.\n    delta (float): Comparison/quantization delta.\n    max_states (int): If positive, determinization will fail when max states\n        is reached.\nRaises:\n    RuntimeError: If determization fails.\n\nSee Also: :meth:`determinize_star`")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_special_ops",  // module name
  "CLIF-generated module for fstext/special-ops.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_getters")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_context_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_deterministic_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_determinize_lattice")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __special__ops_clifwrap
