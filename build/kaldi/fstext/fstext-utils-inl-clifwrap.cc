//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/fstext-utils-inl.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/symbol-table-clifwrap.h"
#include "fstext/float-weight-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/expanded-fst-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "fstext/fstext-utils.h"
#include "fstext-utils-inl-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __fstext__utils__inl_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// highest_numbered_output_symbol(fst:StdFst) -> int
static PyObject* wrapHighestNumberedOutputSymbol_as_highest_numbered_output_symbol(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:highest_numbered_output_symbol", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("highest_numbered_output_symbol", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::HighestNumberedOutputSymbol(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// highest_numbered_input_symbol(fst:StdFst) -> int
static PyObject* wrapHighestNumberedInputSymbol_as_highest_numbered_input_symbol(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:highest_numbered_input_symbol", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("highest_numbered_input_symbol", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::HighestNumberedInputSymbol(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_input_symbols(fst:StdFst, include_eps:bool) -> list<int>
static PyObject* wrapGetInputSymbols_as_get_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("include_eps"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_input_symbols", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_input_symbols", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_input_symbols", names[1], "bool", a[1]);
  ::std::vector<int> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::GetInputSymbols(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_output_symbols(fst:StdFst, include_eps:bool) -> list<int>
static PyObject* wrapGetOutputSymbols_as_get_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("include_eps"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_output_symbols", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_output_symbols", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_output_symbols", names[1], "bool", a[1]);
  ::std::vector<int> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::GetOutputSymbols(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// clear_symbols(clear_input:bool, clear_output:bool, fst:StdMutableFst)
static PyObject* wrapClearSymbols_as_clear_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("clear_input"),
      C("clear_output"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:clear_symbols", names, &a[0], &a[1], &a[2])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("clear_symbols", names[0], "bool", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("clear_symbols", names[1], "bool", a[1]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("clear_symbols", names[2], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ClearSymbols(std::move(arg1), std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_symbols(symtab:SymbolTable, include_eps:bool) -> list<int>
static PyObject* wrapGetSymbols_as_get_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("symtab"),
      C("include_eps"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_symbols", names, &a[0], &a[1])) return nullptr;
  ::fst::SymbolTable* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_symbols", names[0], "::fst::SymbolTable", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_symbols", names[1], "bool", a[1]);
  ::std::vector<int> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::GetSymbols(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _get_linear_symbol_sequence_from_std(fst:StdFst) -> (success:bool, isymbols_out:list<int>, osymbols_out:list<int>, tot_weight_out:TropicalWeight)
static PyObject* wrapGetLinearSymbolSequence_as__get_linear_symbol_sequence_from_std(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_get_linear_symbol_sequence_from_std", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_get_linear_symbol_sequence_from_std", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::std::vector<int> ret1{};
  ::std::vector<int> ret2{};
  ::fst::TropicalWeightTpl<float> ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::GetLinearSymbolSequence(*arg1, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// convert_nbest_to_list(fst:StdFst) -> list<StdVectorFst>
static PyObject* wrapConvertNbestToVector_as_convert_nbest_to_list(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:convert_nbest_to_list", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_nbest_to_list", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::std::vector< ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ConvertNbestToVector(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// nbest_as_fsts(fst:StdFst, n:int) -> list<StdVectorFst>
static PyObject* wrapNbestAsFsts_as_nbest_as_fsts(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst"),
      C("n"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:nbest_as_fsts", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("nbest_as_fsts", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  unsigned long arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("nbest_as_fsts", names[1], "unsigned long", a[1]);
  ::std::vector< ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::NbestAsFsts(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// make_linear_acceptor(labels:list<int>, ofst:StdMutableFst)
static PyObject* wrapMakeLinearAcceptor_as_make_linear_acceptor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("labels"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:make_linear_acceptor", names, &a[0], &a[1])) return nullptr;
  ::std::vector<int> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("make_linear_acceptor", names[0], "::std::vector<int>", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("make_linear_acceptor", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MakeLinearAcceptor(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// make_linear_acceptor_with_alternatives(labels:list<list<int>>, ofst:StdMutableFst)
static PyObject* wrapMakeLinearAcceptorWithAlternatives_as_make_linear_acceptor_with_alternatives(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("labels"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:make_linear_acceptor_with_alternatives", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::std::vector<int> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("make_linear_acceptor_with_alternatives", names[0], "::std::vector< ::std::vector<int> >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("make_linear_acceptor_with_alternatives", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MakeLinearAcceptorWithAlternatives(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// safe_determinize_wrapper(ifst:StdMutableFst, ofst:StdMutableFst, delta:float=default)
static PyObject* wrapSafeDeterminizeWrapper_as_safe_determinize_wrapper(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:safe_determinize_wrapper", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("safe_determinize_wrapper", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("safe_determinize_wrapper", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("safe_determinize_wrapper", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::SafeDeterminizeWrapper(arg1, arg2); break;
  case 3:
    ::fst::SafeDeterminizeWrapper(arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// safe_determinize_minimize_wrapper(ifst:StdMutableFst, ofst:StdVectorFst, delta:float=default)
static PyObject* wrapSafeDeterminizeMinimizeWrapper_as_safe_determinize_minimize_wrapper(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:safe_determinize_minimize_wrapper", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("safe_determinize_minimize_wrapper", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("safe_determinize_minimize_wrapper", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("safe_determinize_minimize_wrapper", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::SafeDeterminizeMinimizeWrapper(arg1, arg2); break;
  case 3:
    ::fst::SafeDeterminizeMinimizeWrapper(arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// safe_determinize_minimize_wrapper_in_log(ifst:StdVectorFst, ofst:StdVectorFst, delta:float=default)
static PyObject* wrapSafeDeterminizeMinimizeWrapperInLog_as_safe_determinize_minimize_wrapper_in_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:safe_determinize_minimize_wrapper_in_log", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("safe_determinize_minimize_wrapper_in_log", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("safe_determinize_minimize_wrapper_in_log", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (float)9.765625e-04;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("safe_determinize_minimize_wrapper_in_log", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::SafeDeterminizeMinimizeWrapperInLog(arg1, arg2); break;
  case 3:
    ::fst::SafeDeterminizeMinimizeWrapperInLog(arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// remove_some_input_symbols(to_remove:list<int>, fst:StdMutableFst)
static PyObject* wrapRemoveSomeInputSymbols_as_remove_some_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("to_remove"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:remove_some_input_symbols", names, &a[0], &a[1])) return nullptr;
  ::std::vector<int> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_some_input_symbols", names[0], "::std::vector<int>", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("remove_some_input_symbols", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveSomeInputSymbols(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_input_symbols(symbol_map:list<int>, fst:StdMutableFst)
static PyObject* wrapMapInputSymbols_as_map_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("symbol_map"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:map_input_symbols", names, &a[0], &a[1])) return nullptr;
  ::std::vector<int> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_input_symbols", names[0], "::std::vector<int>", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("map_input_symbols", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MapInputSymbols(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// remove_weights(fst:StdMutableFst)
static PyObject* wrapRemoveWeights_as_remove_weights(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:remove_weights", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_weights", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveWeights(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// preceding_input_symbols_are_same(start_is_epsilon:bool, fst:StdFst) -> bool
static PyObject* wrapPrecedingInputSymbolsAreSame_as_preceding_input_symbols_are_same(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("start_is_epsilon"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:preceding_input_symbols_are_same", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("preceding_input_symbols_are_same", names[0], "bool", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("preceding_input_symbols_are_same", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::PrecedingInputSymbolsAreSame(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// following_input_symbols_are_same(end_is_epsilon:bool, fst:StdFst) -> bool
static PyObject* wrapFollowingInputSymbolsAreSame_as_following_input_symbols_are_same(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("end_is_epsilon"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:following_input_symbols_are_same", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("following_input_symbols_are_same", names[0], "bool", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("following_input_symbols_are_same", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::FollowingInputSymbolsAreSame(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// make_preceding_input_symbols_same(start_is_epsilon:bool, fst:StdMutableFst)
static PyObject* wrapMakePrecedingInputSymbolsSame_as_make_preceding_input_symbols_same(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("start_is_epsilon"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:make_preceding_input_symbols_same", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("make_preceding_input_symbols_same", names[0], "bool", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("make_preceding_input_symbols_same", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MakePrecedingInputSymbolsSame(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// make_following_input_symbols_same(end_is_epsilon:bool, fst:StdMutableFst)
static PyObject* wrapMakeFollowingInputSymbolsSame_as_make_following_input_symbols_same(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("end_is_epsilon"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:make_following_input_symbols_same", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("make_following_input_symbols_same", names[0], "bool", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("make_following_input_symbols_same", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::MakeFollowingInputSymbolsSame(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_probability_scale(scale:float, fst:StdMutableFst)
static PyObject* wrapApplyProbabilityScale_as_apply_probability_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("scale"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:apply_probability_scale", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_probability_scale", names[0], "float", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_probability_scale", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ApplyProbabilityScale(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// equal_align(ifst:StdFst, length:int, rand_seed:int, ofst:StdMutableFst, num_retries:int=default) -> bool
static PyObject* wrapEqualAlign_as_equal_align(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("ifst"),
      C("length"),
      C("rand_seed"),
      C("ofst"),
      C("num_retries"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:equal_align", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equal_align", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("equal_align", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("equal_align", names[2], "int", a[2]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("equal_align", names[3], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[3]);
  int arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("equal_align", names[4], "int", a[4]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    ret0 = ::fst::EqualAlign(*arg1, std::move(arg2), std::move(arg3), arg4); break;
  case 5:
    ret0 = ::fst::EqualAlign(*arg1, std::move(arg2), std::move(arg3), arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// remove_useless_arcs(fst:StdMutableFst)
static PyObject* wrapRemoveUselessArcs_as_remove_useless_arcs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:remove_useless_arcs", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_useless_arcs", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveUselessArcs(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// phi_compose(fst1:StdFst, fst2:StdFst, phi_label:int, ofst:StdMutableFst)
static PyObject* wrapPhiCompose_as_phi_compose(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      C("phi_label"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:phi_compose", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("phi_compose", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("phi_compose", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("phi_compose", names[2], "int", a[2]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("phi_compose", names[3], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::PhiCompose(*arg1, *arg2, std::move(arg3), arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// propagate_final(phi_label:int, fst:StdMutableFst)
static PyObject* wrapPropagateFinal_as_propagate_final(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("phi_label"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:propagate_final", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("propagate_final", names[0], "int", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("propagate_final", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::PropagateFinal(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// rho_compose(fst1:StdFst, fst2:StdFst, rho_label:int, ofst:StdMutableFst)
static PyObject* wrapRhoCompose_as_rho_compose(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      C("rho_label"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:rho_compose", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("rho_compose", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("rho_compose", names[1], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("rho_compose", names[2], "int", a[2]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("rho_compose", names[3], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RhoCompose(*arg1, *arg2, std::move(arg3), arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_stochastic_fst(fst:StdFst, delta:float=default, min_sum:TropicalWeight=default, max_sum:TropicalWeight=default) -> bool
static PyObject* wrapIsStochasticFst_as_is_stochastic_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("delta"),
      C("min_sum"),
      C("max_sum"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:is_stochastic_fst", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_stochastic_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) return DefaultArgMissedError("is_stochastic_fst", names[1]);
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("is_stochastic_fst", names[1], "float", a[1]);
  }
  ::fst::TropicalWeightTpl<float> * arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("is_stochastic_fst", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("is_stochastic_fst", names[2], "::fst::TropicalWeightTpl<float> *", a[2]);
  }
  ::fst::TropicalWeightTpl<float> * arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("is_stochastic_fst", names[3], "::fst::TropicalWeightTpl<float> *", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::IsStochasticFst(*arg1); break;
  case 2:
    ret0 = ::fst::IsStochasticFst(*arg1, std::move(arg2)); break;
  case 3:
    ret0 = ::fst::IsStochasticFst(*arg1, std::move(arg2), arg3); break;
  case 4:
    ret0 = ::fst::IsStochasticFst(*arg1, std::move(arg2), arg3, arg4); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_stochastic_fst_in_log(fst:StdFst, delta:float=default, min_sum:TropicalWeight=default, max_sum:TropicalWeight=default) -> bool
static PyObject* wrapIsStochasticFstInLog_as_is_stochastic_fst_in_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("fst"),
      C("delta"),
      C("min_sum"),
      C("max_sum"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOO:is_stochastic_fst_in_log", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_stochastic_fst_in_log", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)9.765625e-04;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("is_stochastic_fst_in_log", names[1], "float", a[1]);
  }
  ::fst::TropicalWeightTpl<float> * arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (::fst::TropicalWeightTpl<float> *)nullptr;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("is_stochastic_fst_in_log", names[2], "::fst::TropicalWeightTpl<float> *", a[2]);
  }
  ::fst::TropicalWeightTpl<float> * arg4;
  if (nargs > 3) {
    if (!a[3]) arg4 = (::fst::TropicalWeightTpl<float> *)nullptr;
    else if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("is_stochastic_fst_in_log", names[3], "::fst::TropicalWeightTpl<float> *", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::IsStochasticFstInLog(*arg1); break;
  case 2:
    ret0 = ::fst::IsStochasticFstInLog(*arg1, std::move(arg2)); break;
  case 3:
    ret0 = ::fst::IsStochasticFstInLog(*arg1, std::move(arg2), arg3); break;
  case 4:
    ret0 = ::fst::IsStochasticFstInLog(*arg1, std::move(arg2), arg3, arg4); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("highest_numbered_output_symbol"), (PyCFunction)wrapHighestNumberedOutputSymbol_as_highest_numbered_output_symbol, METH_VARARGS | METH_KEYWORDS, C("highest_numbered_output_symbol(fst:StdFst) -> int\n\nReturns the highest numbered output label of the FST (zero if FST is empty).")},
  {C("highest_numbered_input_symbol"), (PyCFunction)wrapHighestNumberedInputSymbol_as_highest_numbered_input_symbol, METH_VARARGS | METH_KEYWORDS, C("highest_numbered_input_symbol(fst:StdFst) -> int\n\nReturns the highest numbered input label of the FST (zero if FST is empty).")},
  {C("get_input_symbols"), (PyCFunction)wrapGetInputSymbols_as_get_input_symbols, METH_VARARGS | METH_KEYWORDS, C("get_input_symbols(fst:StdFst, include_eps:bool) -> list<int>\n\nGets input labels of the FST as a sorted unique list.")},
  {C("get_output_symbols"), (PyCFunction)wrapGetOutputSymbols_as_get_output_symbols, METH_VARARGS | METH_KEYWORDS, C("get_output_symbols(fst:StdFst, include_eps:bool) -> list<int>\n\nGets output labels of the FST as a sorted unique list.")},
  {C("clear_symbols"), (PyCFunction)wrapClearSymbols_as_clear_symbols, METH_VARARGS | METH_KEYWORDS, C("clear_symbols(clear_input:bool, clear_output:bool, fst:StdMutableFst)\n\nSets all input/output labels of the FST to zero.\n\nDoes not alter symbol tables.")},
  {C("get_symbols"), (PyCFunction)wrapGetSymbols_as_get_symbols, METH_VARARGS | METH_KEYWORDS, C("get_symbols(symtab:SymbolTable, include_eps:bool) -> list<int>\n\nGets labels in the symbol table as a sorted unique list.")},
  {C("_get_linear_symbol_sequence_from_std"), (PyCFunction)wrapGetLinearSymbolSequence_as__get_linear_symbol_sequence_from_std, METH_VARARGS | METH_KEYWORDS, C("_get_linear_symbol_sequence_from_std(fst:StdFst) -> (success:bool, isymbols_out:list<int>, osymbols_out:list<int>, tot_weight_out:TropicalWeight)\n  Calls C++ function\n  bool ::fst::GetLinearSymbolSequence(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::std::vector<int>*, ::std::vector<int>*, ::fst::TropicalWeightTpl<float>*)")},
  {C("convert_nbest_to_list"), (PyCFunction)wrapConvertNbestToVector_as_convert_nbest_to_list, METH_VARARGS | METH_KEYWORDS, C("convert_nbest_to_list(fst:StdFst) -> list<StdVectorFst>\n\nConverts n-best FST to a list of FSTs.")},
  {C("nbest_as_fsts"), (PyCFunction)wrapNbestAsFsts_as_nbest_as_fsts, METH_VARARGS | METH_KEYWORDS, C("nbest_as_fsts(fst:StdFst, n:int) -> list<StdVectorFst>\n\nOutputs (up to) n-best paths in the FST as a list of FSTs.")},
  {C("make_linear_acceptor"), (PyCFunction)wrapMakeLinearAcceptor_as_make_linear_acceptor, METH_VARARGS | METH_KEYWORDS, C("make_linear_acceptor(labels:list<int>, ofst:StdMutableFst)\n\nCreates an unweighted linear acceptor from the label sequence.")},
  {C("make_linear_acceptor_with_alternatives"), (PyCFunction)wrapMakeLinearAcceptorWithAlternatives_as_make_linear_acceptor_with_alternatives, METH_VARARGS | METH_KEYWORDS, C("make_linear_acceptor_with_alternatives(labels:list<list<int>>, ofst:StdMutableFst)\n\nCreates an unweighted acceptor with a linear structure.\n\nEach position in the input list is a list of labels.  Each position must\nhave at least one alternative. Epsilon/0 is treated like a normal symbol.")},
  {C("safe_determinize_wrapper"), (PyCFunction)wrapSafeDeterminizeWrapper_as_safe_determinize_wrapper, METH_VARARGS | METH_KEYWORDS, C("safe_determinize_wrapper(ifst:StdMutableFst, ofst:StdMutableFst, delta:float=default)\n\nPerforms safe determinization.\n\nThis is a form of determinization that will never blow up. Note that\n`ifst` is non-const and can be destroyed by this operation. Does not do\nepsilon removal. This is so it's safe to cast to log and do this, and\nmaintain equivalence in tropical.")},
  {C("safe_determinize_minimize_wrapper"), (PyCFunction)wrapSafeDeterminizeMinimizeWrapper_as_safe_determinize_minimize_wrapper, METH_VARARGS | METH_KEYWORDS, C("safe_determinize_minimize_wrapper(ifst:StdMutableFst, ofst:StdVectorFst, delta:float=default)\n\nPerforms safe determinization and minimization.\n\nLike meth:`safe_determinize_wrapper` but also does encoded minimization,\nwhich is safe. This algorithm will destroy `ifst`.")},
  {C("safe_determinize_minimize_wrapper_in_log"), (PyCFunction)wrapSafeDeterminizeMinimizeWrapperInLog_as_safe_determinize_minimize_wrapper_in_log, METH_VARARGS | METH_KEYWORDS, C("safe_determinize_minimize_wrapper_in_log(ifst:StdVectorFst, ofst:StdVectorFst, delta:float=default)\n\nPerforms safe determinization and minimization in log semiring.\n\nLike meth:`safe_determinize_minimize_wrapper` but first casts to the log\nsemiring. This algorithm will destroy `ifst`.")},
  {C("remove_some_input_symbols"), (PyCFunction)wrapRemoveSomeInputSymbols_as_remove_some_input_symbols, METH_VARARGS | METH_KEYWORDS, C("remove_some_input_symbols(to_remove:list<int>, fst:StdMutableFst)\n\nReplaces given input labels with zeros.")},
  {C("map_input_symbols"), (PyCFunction)wrapMapInputSymbols_as_map_input_symbols, METH_VARARGS | METH_KEYWORDS, C("map_input_symbols(symbol_map:list<int>, fst:StdMutableFst)\n\nMaps input labels to labels given in the symbol map.")},
  {C("remove_weights"), (PyCFunction)wrapRemoveWeights_as_remove_weights, METH_VARARGS | METH_KEYWORDS, C("remove_weights(fst:StdMutableFst)\n\nRemoves FST weights.")},
  {C("preceding_input_symbols_are_same"), (PyCFunction)wrapPrecedingInputSymbolsAreSame_as_preceding_input_symbols_are_same, METH_VARARGS | METH_KEYWORDS, C("preceding_input_symbols_are_same(start_is_epsilon:bool, fst:StdFst) -> bool\n\nChecks if all arcs entering any state have the same input symbol.\n\nReturns true if and only if the FST is such that the input symbols on\narcs entering any given state all have the same value. If\n`start_is_epsilon == True`, treats start-state as an epsilon input arc\n[i.e. ensures only epsilons can enter start-state].")},
  {C("following_input_symbols_are_same"), (PyCFunction)wrapFollowingInputSymbolsAreSame_as_following_input_symbols_are_same, METH_VARARGS | METH_KEYWORDS, C("following_input_symbols_are_same(end_is_epsilon:bool, fst:StdFst) -> bool\n\nChecks if all arcs exiting any state have the same input symbol.\n\nReturns true if and only if the FST is such that the input symbols on\narcs exiting any given state all have the same value. If\n`end_is_epsilon == True`, treats final-states as epsilon output arcs\n[i.e. ensures only epsilons can exit final-states].")},
  {C("make_preceding_input_symbols_same"), (PyCFunction)wrapMakePrecedingInputSymbolsSame_as_make_preceding_input_symbols_same, METH_VARARGS | METH_KEYWORDS, C("make_preceding_input_symbols_same(start_is_epsilon:bool, fst:StdMutableFst)\n\nEnsures that all arcs entering any state have the same input symbol.\n\nDetects states that have differing input symbols going in, and inserts,\nfor each of the preceding arcs with non-epsilon input symbol, a new dummy\nstate that has an epsilon link to the fst state. If `start_is_epsilon ==\nTrue`, ensures that start-state can have only epsilon-links into it.")},
  {C("make_following_input_symbols_same"), (PyCFunction)wrapMakeFollowingInputSymbolsSame_as_make_following_input_symbols_same, METH_VARARGS | METH_KEYWORDS, C("make_following_input_symbols_same(end_is_epsilon:bool, fst:StdMutableFst)\n\nEnsures that all arcs exiting any state have the same input symbol.\n\nDetects states that have differing input symbols going out, and inserts,\nfor each of the following arcs with non-epsilon input symbol, a new dummy\nstate that has an epsilon link from the fst state. The output symbol and\nweight stay on the link to the dummy state (in order to keep the FST\noutput-deterministic and stochastic, if it already was). If\n`end_is_epsilon == True`, treats \"being a final-state\" like having an\nepsilon output link.")},
  {C("apply_probability_scale"), (PyCFunction)wrapApplyProbabilityScale_as_apply_probability_scale, METH_VARARGS | METH_KEYWORDS, C("apply_probability_scale(scale:float, fst:StdMutableFst)\n\nApplies a probability scale to the FST.\n\nThis is applicable to FSTs in the log or tropical semiring. It multiplies\nthe arc and final weights by `scale` [this is not the multiplication\noperation of the semiring, it's actual multiplication, which is\nequivalent to taking a power in the semiring].")},
  {C("equal_align"), (PyCFunction)wrapEqualAlign_as_equal_align, METH_VARARGS | METH_KEYWORDS, C("equal_align(ifst:StdFst, length:int, rand_seed:int, ofst:StdMutableFst, num_retries:int=default) -> bool\n\nGenerates sequences from the input FST with exactly \"length\" symbols.\n\nThis is similar to randgen, but it generates a sequence with exactly\n\"length\" input symbols.  It returns `True` on success, `False` on failure\n(failure is partly random but should never happen in practice for normal\nspeech models.) It generates a random path through the input FST, finds\nout which subset of the states it visits along the way have self-loops\nwith inupt symbols on them, and outputs a path with exactly enough\nself-loops to have the requested number of input symbols. Note that\nEqualAlign does not use the probabilities on the FST.  It just uses equal\nprobabilities in the first stage of selection (since the output will\nanyway not be a truly random sample from the FST). The input fst \"ifst\"\nmust be connected or this may enter an infinite loop.")},
  {C("remove_useless_arcs"), (PyCFunction)wrapRemoveUselessArcs_as_remove_useless_arcs, METH_VARARGS | METH_KEYWORDS, C("remove_useless_arcs(fst:StdMutableFst)\n\nRemoves arcs that are not on best paths for any input symbol sequence.\n\nThis removes arcs such that there is no input symbol sequence for which\nthe best path through the FST would contain those arcs [for these\npurposes, epsilon is not treated as a real symbol]. This is mainly geared\ntowards decoding-graph FSTs which may contain transitions that have less\nlikely words on them that would never be taken.  We do not claim that\nthis algorithm removes all such arcs; it just does the best job it can.\nOnly works for tropical (not log) semiring as it uses NaturalLess.")},
  {C("phi_compose"), (PyCFunction)wrapPhiCompose_as_phi_compose, METH_VARARGS | METH_KEYWORDS, C("phi_compose(fst1:StdFst, fst2:StdFst, phi_label:int, ofst:StdMutableFst)\n\nPerforms composition by handling phi (failure) transitions.\n\nThis is a version of composition where the right hand FST (fst2) is\ntreated as a backoff language model, with the phi symbol (e.g. #0)\ntreated as a \"failure transition\", only taken when there is no match for\nthe requested symbol.")},
  {C("propagate_final"), (PyCFunction)wrapPropagateFinal_as_propagate_final, METH_VARARGS | METH_KEYWORDS, C("propagate_final(phi_label:int, fst:StdMutableFst)\n\nPropagates final-probs through \"phi\" transitions.\n\nNote that here, phi_label may be epsilon. If you have a backoff language\nmodel with special symbols (\"phi\") on the backoff arcs instead of\nepsilon, you may use :meth:`phi_compose` to compose with it, but this\nwon't do the right thing w.r.t. final probabilities.  You should first\ncall :meth:`propagate_final` on the FST with phi's in it (`fst2` in\n:meth:`phi_compose`), to fix this.  If a state does not have a\nfinal-prob, but has a phi transition, it makes the state's final-prob\n(phi-prob * final-prob-of-dest-state), and does this recursively i.e.\nfollows phi transitions on the dest state first.  It behaves as if there\nwere a super-final state with a special symbol leading to it, from each\ncurrently final state.  Note that this may not behave as desired if there\nare epsilons in your FST; it might be better to remove those before\ncalling this function.")},
  {C("rho_compose"), (PyCFunction)wrapRhoCompose_as_rho_compose, METH_VARARGS | METH_KEYWORDS, C("rho_compose(fst1:StdFst, fst2:StdFst, rho_label:int, ofst:StdMutableFst)\n\nPerforms composition by handling rho transitions.\n\nThis is a version of composition where the right hand FST (fst2) has\nspecial \"rho transitions\" which are taken whenever no normal transition\nmatches; these transitions will be rewritten with whatever symbol was on\nthe first FST.")},
  {C("is_stochastic_fst"), (PyCFunction)wrapIsStochasticFst_as_is_stochastic_fst, METH_VARARGS | METH_KEYWORDS, C("is_stochastic_fst(fst:StdFst, delta:float=default, min_sum:TropicalWeight=default, max_sum:TropicalWeight=default) -> bool\n\nChecks if FST is stochastic.\n\nThis function returns true if, in the semiring of the FST, the sum\n(within the semiring) of all the arcs out of each state in the FST is\none, to within delta.\n\nArgs:\n  fst: The FST that we are testing.\n  delta: The tolerance to within which we test equality to 1.\n  min_sum: If provided, it will be set to the minimum sum of weights.\n  max_sum: If provided, it will be set to the maximum sum of weights.\n\nReturns:\n  True if the FST is stochastic, and False otherwise.")},
  {C("is_stochastic_fst_in_log"), (PyCFunction)wrapIsStochasticFstInLog_as_is_stochastic_fst_in_log, METH_VARARGS | METH_KEYWORDS, C("is_stochastic_fst_in_log(fst:StdFst, delta:float=default, min_sum:TropicalWeight=default, max_sum:TropicalWeight=default) -> bool\n\nChecks if FST is stochastic in log semiring.\n\nThis function returns true if, in the log semiring, the sum of all the\narcs out of each state in the FST is one, to within delta.\n\nArgs:\n  fst: The FST that we are testing.\n  delta: The tolerance to within which we test equality to 1.\n  min_sum: If provided, it will be set to the minimum sum of weights.\n  max_sum: If provided, it will be set to the maximum sum of weights.\n\nReturns:\n  True if the FST is stochastic, and False otherwise.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_fstext_utils_inl",  // module name
  "CLIF-generated module for fstext/fstext-utils-inl.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_float_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_expanded_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __fstext__utils__inl_clifwrap
