//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/fstext-shims.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/expanded-fst-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "fstext/const-fst-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "base/iostream-clifwrap.h"
#include "fstext-shims-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __fstext__shims_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _assign_std_vector_fst(ifst:StdVectorFst, ofst:StdVectorFst)
static PyObject* wrapAssignVectorFst_as__assign_std_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_std_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_std_vector_fst", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_std_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_log_vector_fst(ifst:LogVectorFst, ofst:LogVectorFst)
static PyObject* wrapAssignVectorFst_as__assign_log_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_log_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_log_vector_fst", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_log_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_lattice_vector_fst(ifst:LatticeVectorFst, ofst:LatticeVectorFst)
static PyObject* wrapAssignVectorFst_as__assign_lattice_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_lattice_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_lattice_vector_fst", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_lattice_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_compact_lattice_vector_fst(ifst:CompactLatticeVectorFst, ofst:CompactLatticeVectorFst)
static PyObject* wrapAssignVectorFst_as__assign_compact_lattice_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_compact_lattice_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_compact_lattice_vector_fst", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_compact_lattice_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_kws_index_vector_fst(ifst:KwsIndexVectorFst, ofst:KwsIndexVectorFst)
static PyObject* wrapAssignVectorFst_as__assign_kws_index_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_kws_index_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_kws_index_vector_fst", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_kws_index_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_std_const_fst(ifst:StdConstFst, ofst:StdConstFst)
static PyObject* wrapAssignConstFst_as__assign_std_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_std_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_std_const_fst", names[0], "::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int>", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_std_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_log_const_fst(ifst:LogConstFst, ofst:LogConstFst)
static PyObject* wrapAssignConstFst_as__assign_log_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_log_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_log_const_fst", names[0], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int>", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_log_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_lattice_const_fst(ifst:LatticeConstFst, ofst:LatticeConstFst)
static PyObject* wrapAssignConstFst_as__assign_lattice_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_lattice_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_lattice_const_fst", names[0], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int>", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_lattice_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_compact_lattice_const_fst(ifst:CompactLatticeConstFst, ofst:CompactLatticeConstFst)
static PyObject* wrapAssignConstFst_as__assign_compact_lattice_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_compact_lattice_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_compact_lattice_const_fst", names[0], "::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int>", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_compact_lattice_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_kws_index_const_fst(ifst:KwsIndexConstFst, ofst:KwsIndexConstFst)
static PyObject* wrapAssignConstFst_as__assign_kws_index_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_kws_index_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_kws_index_const_fst", names[0], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int>", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_kws_index_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_std_fst_to_vector_fst(ifst:StdFst, ofst:StdVectorFst)
static PyObject* wrapAssignFstToVectorFst_as__assign_std_fst_to_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_std_fst_to_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_std_fst_to_vector_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_std_fst_to_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_log_fst_to_vector_fst(ifst:LogFst, ofst:LogVectorFst)
static PyObject* wrapAssignFstToVectorFst_as__assign_log_fst_to_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_log_fst_to_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_log_fst_to_vector_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_log_fst_to_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_lattice_fst_to_vector_fst(ifst:LatticeFst, ofst:LatticeVectorFst)
static PyObject* wrapAssignFstToVectorFst_as__assign_lattice_fst_to_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_lattice_fst_to_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_lattice_fst_to_vector_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_lattice_fst_to_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_compact_lattice_fst_to_vector_fst(ifst:CompactLatticeFst, ofst:CompactLatticeVectorFst)
static PyObject* wrapAssignFstToVectorFst_as__assign_compact_lattice_fst_to_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_compact_lattice_fst_to_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_compact_lattice_fst_to_vector_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_compact_lattice_fst_to_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_kws_index_fst_to_vector_fst(ifst:KwsIndexFst, ofst:KwsIndexVectorFst)
static PyObject* wrapAssignFstToVectorFst_as__assign_kws_index_fst_to_vector_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_kws_index_fst_to_vector_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_kws_index_fst_to_vector_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_kws_index_fst_to_vector_fst", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToVectorFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_std_fst_to_const_fst(ifst:StdFst, ofst:StdConstFst)
static PyObject* wrapAssignFstToConstFst_as__assign_std_fst_to_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_std_fst_to_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_std_fst_to_const_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_std_fst_to_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_log_fst_to_const_fst(ifst:LogFst, ofst:LogConstFst)
static PyObject* wrapAssignFstToConstFst_as__assign_log_fst_to_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_log_fst_to_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_log_fst_to_const_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_log_fst_to_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_lattice_fst_to_const_fst(ifst:LatticeFst, ofst:LatticeConstFst)
static PyObject* wrapAssignFstToConstFst_as__assign_lattice_fst_to_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_lattice_fst_to_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_lattice_fst_to_const_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_lattice_fst_to_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_compact_lattice_fst_to_const_fst(ifst:CompactLatticeFst, ofst:CompactLatticeConstFst)
static PyObject* wrapAssignFstToConstFst_as__assign_compact_lattice_fst_to_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_compact_lattice_fst_to_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_compact_lattice_fst_to_const_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_compact_lattice_fst_to_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _assign_kws_index_fst_to_const_fst(ifst:KwsIndexFst, ofst:KwsIndexConstFst)
static PyObject* wrapAssignFstToConstFst_as__assign_kws_index_fst_to_const_fst(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_assign_kws_index_fst_to_const_fst", names, &a[0], &a[1])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assign_kws_index_fst_to_const_fst", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  ::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assign_kws_index_fst_to_const_fst", names[1], "::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::AssignFstToConstFst(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// cast_std_to_log(ifst:StdVectorFst) -> LogVectorFst
static PyObject* wrapCastStdToLog_as_cast_std_to_log(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ifst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:cast_std_to_log", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("cast_std_to_log", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::CastStdToLog(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.LogVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// cast_log_to_std(ifst:LogVectorFst) -> StdVectorFst
static PyObject* wrapCastLogToStd_as_cast_log_to_std(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ifst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:cast_log_to_std", names, &a[0])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("cast_log_to_std", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > >", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::CastLogToStd(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(1);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  PyObject* pyproc = ImportFQName("kaldi.fstext.StdVectorFst");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// _convert_lattice_to_compact_lattice(ifst:LatticeExpandedFst, ofst:CompactLatticeMutableFst, invert:bool=default)
static PyObject* wrapConvertLatticeToCompactLattice_as__convert_lattice_to_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_convert_lattice_to_compact_lattice", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_convert_lattice_to_compact_lattice", names[0], "::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_convert_lattice_to_compact_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (bool)true;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_convert_lattice_to_compact_lattice", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::ConvertLatticeToCompactLattice(*arg1, arg2); break;
  case 3:
    ::fst::ConvertLatticeToCompactLattice(*arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _convert_compact_lattice_to_lattice(ifst:CompactLatticeExpandedFst, ofst:LatticeMutableFst, invert:bool=default)
static PyObject* wrapConvertCompactLatticeToLattice_as__convert_compact_lattice_to_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("ifst"),
      C("ofst"),
      C("invert"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_convert_compact_lattice_to_lattice", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::ExpandedFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_convert_compact_lattice_to_lattice", names[0], "::fst::ExpandedFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_convert_compact_lattice_to_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (bool)true;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_convert_compact_lattice_to_lattice", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::fst::ConvertCompactLatticeToLattice(*arg1, arg2); break;
  case 3:
    ::fst::ConvertCompactLatticeToLattice(*arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _convert_lattice_to_std(ifst:LatticeExpandedFst, ofst:StdMutableFst)
static PyObject* wrapConvertLatticeToStd_as__convert_lattice_to_std(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_convert_lattice_to_std", names, &a[0], &a[1])) return nullptr;
  ::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_convert_lattice_to_std", names[0], "::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_convert_lattice_to_std", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ConvertLatticeToStd(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _convert_std_to_lattice(ifst:StdExpandedFst, ofst:LatticeMutableFst)
static PyObject* wrapConvertStdToLattice_as__convert_std_to_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("ifst"),
      C("ofst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_convert_std_to_lattice", names, &a[0], &a[1])) return nullptr;
  ::fst::ExpandedFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_convert_std_to_lattice", names[0], "::fst::ExpandedFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_convert_std_to_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ConvertStdToLattice(*arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale_lattice(scale:list<list<float>>, fst:LatticeMutableFst)
static PyObject* wrapScaleKaldiLattice_as_scale_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("scale"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:scale_lattice", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::std::vector<double> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_lattice", names[0], "::std::vector< ::std::vector<double> >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("scale_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ScaleKaldiLattice(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale_compact_lattice(scale:list<list<float>>, fst:CompactLatticeMutableFst)
static PyObject* wrapScaleCompactLattice_as_scale_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("scale"),
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:scale_compact_lattice", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::std::vector<double> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_compact_lattice", names[0], "::std::vector< ::std::vector<double> >", a[0]);
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("scale_compact_lattice", names[1], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ScaleCompactLattice(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// remove_alignments_from_compact_lattice(fst:CompactLatticeMutableFst)
static PyObject* wrapRemoveAlignmentsFromCompactLatticeExt_as_remove_alignments_from_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:remove_alignments_from_compact_lattice", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("remove_alignments_from_compact_lattice", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::RemoveAlignmentsFromCompactLatticeExt(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// compact_lattice_has_alignment(fst:CompactLatticeExpandedFst) -> bool
static PyObject* wrapCompactLatticeHasAlignmentExt_as_compact_lattice_has_alignment(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:compact_lattice_has_alignment", names, &a[0])) return nullptr;
  ::fst::ExpandedFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("compact_lattice_has_alignment", names[0], "::fst::ExpandedFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::CompactLatticeHasAlignmentExt(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _get_linear_symbol_sequence_from_lattice(fst:LatticeFst) -> (success:bool, isymbols_out:list<int>, osymbols_out:list<int>, tot_weight_out:LatticeWeight)
static PyObject* wrapGetLinearSymbolSequenceFromLatticeFst_as__get_linear_symbol_sequence_from_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_get_linear_symbol_sequence_from_lattice", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_get_linear_symbol_sequence_from_lattice", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::std::vector< ::int32> ret1{};
  ::std::vector< ::int32> ret2{};
  ::fst::LatticeWeightTpl<float> ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::GetLinearSymbolSequenceFromLatticeFst(*arg1, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_assign_std_vector_fst"), (PyCFunction)wrapAssignVectorFst_as__assign_std_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_std_vector_fst(ifst:StdVectorFst, ofst:StdVectorFst)\n  Calls C++ function\n  void ::fst::AssignVectorFst(::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *)")},
  {C("_assign_log_vector_fst"), (PyCFunction)wrapAssignVectorFst_as__assign_log_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_log_vector_fst(ifst:LogVectorFst, ofst:LogVectorFst)\n  Calls C++ function\n  void ::fst::AssignVectorFst(::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > *)")},
  {C("_assign_lattice_vector_fst"), (PyCFunction)wrapAssignVectorFst_as__assign_lattice_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_lattice_vector_fst(ifst:LatticeVectorFst, ofst:LatticeVectorFst)\n  Calls C++ function\n  void ::fst::AssignVectorFst(::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *)")},
  {C("_assign_compact_lattice_vector_fst"), (PyCFunction)wrapAssignVectorFst_as__assign_compact_lattice_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_compact_lattice_vector_fst(ifst:CompactLatticeVectorFst, ofst:CompactLatticeVectorFst)\n  Calls C++ function\n  void ::fst::AssignVectorFst(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *)")},
  {C("_assign_kws_index_vector_fst"), (PyCFunction)wrapAssignVectorFst_as__assign_kws_index_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_kws_index_vector_fst(ifst:KwsIndexVectorFst, ofst:KwsIndexVectorFst)\n  Calls C++ function\n  void ::fst::AssignVectorFst(::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > *)")},
  {C("_assign_std_const_fst"), (PyCFunction)wrapAssignConstFst_as__assign_std_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_std_const_fst(ifst:StdConstFst, ofst:StdConstFst)\n  Calls C++ function\n  void ::fst::AssignConstFst(::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int>, ::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_log_const_fst"), (PyCFunction)wrapAssignConstFst_as__assign_log_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_log_const_fst(ifst:LogConstFst, ofst:LogConstFst)\n  Calls C++ function\n  void ::fst::AssignConstFst(::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int>, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_lattice_const_fst"), (PyCFunction)wrapAssignConstFst_as__assign_lattice_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_lattice_const_fst(ifst:LatticeConstFst, ofst:LatticeConstFst)\n  Calls C++ function\n  void ::fst::AssignConstFst(::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int>, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_compact_lattice_const_fst"), (PyCFunction)wrapAssignConstFst_as__assign_compact_lattice_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_compact_lattice_const_fst(ifst:CompactLatticeConstFst, ofst:CompactLatticeConstFst)\n  Calls C++ function\n  void ::fst::AssignConstFst(::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int>, ::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> *)")},
  {C("_assign_kws_index_const_fst"), (PyCFunction)wrapAssignConstFst_as__assign_kws_index_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_kws_index_const_fst(ifst:KwsIndexConstFst, ofst:KwsIndexConstFst)\n  Calls C++ function\n  void ::fst::AssignConstFst(::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int>, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> *)")},
  {C("_assign_std_fst_to_vector_fst"), (PyCFunction)wrapAssignFstToVectorFst_as__assign_std_fst_to_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_std_fst_to_vector_fst(ifst:StdFst, ofst:StdVectorFst)\n  Calls C++ function\n  void ::fst::AssignFstToVectorFst(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *)")},
  {C("_assign_log_fst_to_vector_fst"), (PyCFunction)wrapAssignFstToVectorFst_as__assign_log_fst_to_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_log_fst_to_vector_fst(ifst:LogFst, ofst:LogVectorFst)\n  Calls C++ function\n  void ::fst::AssignFstToVectorFst(::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > > > *)")},
  {C("_assign_lattice_fst_to_vector_fst"), (PyCFunction)wrapAssignFstToVectorFst_as__assign_lattice_fst_to_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_lattice_fst_to_vector_fst(ifst:LatticeFst, ofst:LatticeVectorFst)\n  Calls C++ function\n  void ::fst::AssignFstToVectorFst(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *)")},
  {C("_assign_compact_lattice_fst_to_vector_fst"), (PyCFunction)wrapAssignFstToVectorFst_as__assign_compact_lattice_fst_to_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_compact_lattice_fst_to_vector_fst(ifst:CompactLatticeFst, ofst:CompactLatticeVectorFst)\n  Calls C++ function\n  void ::fst::AssignFstToVectorFst(::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *)")},
  {C("_assign_kws_index_fst_to_vector_fst"), (PyCFunction)wrapAssignFstToVectorFst_as__assign_kws_index_fst_to_vector_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_kws_index_fst_to_vector_fst(ifst:KwsIndexFst, ofst:KwsIndexVectorFst)\n  Calls C++ function\n  void ::fst::AssignFstToVectorFst(::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >, ::fst::VectorFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, ::std::allocator< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > > > *)")},
  {C("_assign_std_fst_to_const_fst"), (PyCFunction)wrapAssignFstToConstFst_as__assign_std_fst_to_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_std_fst_to_const_fst(ifst:StdFst, ofst:StdConstFst)\n  Calls C++ function\n  void ::fst::AssignFstToConstFst(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::ConstFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_log_fst_to_const_fst"), (PyCFunction)wrapAssignFstToConstFst_as__assign_log_fst_to_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_log_fst_to_const_fst(ifst:LogFst, ofst:LogConstFst)\n  Calls C++ function\n  void ::fst::AssignFstToConstFst(::fst::Fst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LogWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_lattice_fst_to_const_fst"), (PyCFunction)wrapAssignFstToConstFst_as__assign_lattice_fst_to_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_lattice_fst_to_const_fst(ifst:LatticeFst, ofst:LatticeConstFst)\n  Calls C++ function\n  void ::fst::AssignFstToConstFst(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, unsigned int> *)")},
  {C("_assign_compact_lattice_fst_to_const_fst"), (PyCFunction)wrapAssignFstToConstFst_as__assign_compact_lattice_fst_to_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_compact_lattice_fst_to_const_fst(ifst:CompactLatticeFst, ofst:CompactLatticeConstFst)\n  Calls C++ function\n  void ::fst::AssignFstToConstFst(::fst::Fst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >, ::fst::ConstFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, unsigned int> *)")},
  {C("_assign_kws_index_fst_to_const_fst"), (PyCFunction)wrapAssignFstToConstFst_as__assign_kws_index_fst_to_const_fst, METH_VARARGS | METH_KEYWORDS, C("_assign_kws_index_fst_to_const_fst(ifst:KwsIndexFst, ofst:KwsIndexConstFst)\n  Calls C++ function\n  void ::fst::AssignFstToConstFst(::fst::Fst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >, ::fst::ConstFst< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >, unsigned int> *)")},
  {C("cast_std_to_log"), (PyCFunction)wrapCastStdToLog_as_cast_std_to_log, METH_VARARGS | METH_KEYWORDS, C("cast_std_to_log(ifst:StdVectorFst) -> LogVectorFst\n\nCasts FST in tropical semiring to log semiring.")},
  {C("cast_log_to_std"), (PyCFunction)wrapCastLogToStd_as_cast_log_to_std, METH_VARARGS | METH_KEYWORDS, C("cast_log_to_std(ifst:LogVectorFst) -> StdVectorFst\n\nCasts FST in log semiring to tropical semiring.")},
  {C("_convert_lattice_to_compact_lattice"), (PyCFunction)wrapConvertLatticeToCompactLattice_as__convert_lattice_to_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("_convert_lattice_to_compact_lattice(ifst:LatticeExpandedFst, ofst:CompactLatticeMutableFst, invert:bool=default)\n  Calls C++ function\n  void ::fst::ConvertLatticeToCompactLattice(::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *, bool)")},
  {C("_convert_compact_lattice_to_lattice"), (PyCFunction)wrapConvertCompactLatticeToLattice_as__convert_compact_lattice_to_lattice, METH_VARARGS | METH_KEYWORDS, C("_convert_compact_lattice_to_lattice(ifst:CompactLatticeExpandedFst, ofst:LatticeMutableFst, invert:bool=default)\n  Calls C++ function\n  void ::fst::ConvertCompactLatticeToLattice(::fst::ExpandedFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *, bool)")},
  {C("_convert_lattice_to_std"), (PyCFunction)wrapConvertLatticeToStd_as__convert_lattice_to_std, METH_VARARGS | METH_KEYWORDS, C("_convert_lattice_to_std(ifst:LatticeExpandedFst, ofst:StdMutableFst)\n  Calls C++ function\n  void ::fst::ConvertLatticeToStd(::fst::ExpandedFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("_convert_std_to_lattice"), (PyCFunction)wrapConvertStdToLattice_as__convert_std_to_lattice, METH_VARARGS | METH_KEYWORDS, C("_convert_std_to_lattice(ifst:StdExpandedFst, ofst:LatticeMutableFst)\n  Calls C++ function\n  void ::fst::ConvertStdToLattice(::fst::ExpandedFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::fst::MutableFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *)")},
  {C("scale_lattice"), (PyCFunction)wrapScaleKaldiLattice_as_scale_lattice, METH_VARARGS | METH_KEYWORDS, C("scale_lattice(scale:list<list<float>>, fst:LatticeMutableFst)\n\nScales the lattice weights.\n\nScales the pair of weights in `LatticeWeight` by viewing the pair (a, b)\nas a 2-vector and pre-multiplying by the 2x2 matrix in `scale`.  E.g.\ntypically scale would equal `[[1, 0], [0, acwt]]` if we want to scale the\nacoustics by `acwt`.")},
  {C("scale_compact_lattice"), (PyCFunction)wrapScaleCompactLattice_as_scale_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("scale_compact_lattice(scale:list<list<float>>, fst:CompactLatticeMutableFst)\n\nScales the compact lattice weights.\n\nScales the pair of weights in `CompactLatticeWeight` by viewing the pair (a, b)\nas a 2-vector and pre-multiplying by the 2x2 matrix in `scale`.  E.g.\ntypically scale would equal `[[1, 0], [0, acwt]]` if we want to scale the\nacoustics by `acwt`.")},
  {C("remove_alignments_from_compact_lattice"), (PyCFunction)wrapRemoveAlignmentsFromCompactLatticeExt_as_remove_alignments_from_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("remove_alignments_from_compact_lattice(fst:CompactLatticeMutableFst)\n\nRemoves state-level alignments in a compact lattice.")},
  {C("compact_lattice_has_alignment"), (PyCFunction)wrapCompactLatticeHasAlignmentExt_as_compact_lattice_has_alignment, METH_VARARGS | METH_KEYWORDS, C("compact_lattice_has_alignment(fst:CompactLatticeExpandedFst) -> bool\n\nChecks if compact lattice has state-level alignments.")},
  {C("_get_linear_symbol_sequence_from_lattice"), (PyCFunction)wrapGetLinearSymbolSequenceFromLatticeFst_as__get_linear_symbol_sequence_from_lattice, METH_VARARGS | METH_KEYWORDS, C("_get_linear_symbol_sequence_from_lattice(fst:LatticeFst) -> (success:bool, isymbols_out:list<int>, osymbols_out:list<int>, tot_weight_out:LatticeWeight)\n  Calls C++ function\n  bool ::fst::GetLinearSymbolSequenceFromLatticeFst(::fst::Fst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >, ::std::vector< ::int32>*, ::std::vector< ::int32>*, ::fst::LatticeWeightTpl<float>*)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_fstext_shims",  // module name
  "CLIF-generated module for fstext/fstext-shims.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_expanded_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_const_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __fstext__shims_clifwrap
