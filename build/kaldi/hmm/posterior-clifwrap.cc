//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/hmm/posterior.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "hmm/transition-model-clifwrap.h"
#include "posterior-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __posterior_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// write_posterior(os:ostream, binary:bool, post:list<list<tuple<int, float>>>)
static PyObject* wrapWritePosterior_as_write_posterior(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("binary"),
      C("post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write_posterior", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_posterior", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_posterior", names[1], "bool", a[1]);
  ::kaldi::Posterior arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write_posterior", names[2], "::kaldi::Posterior", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::WritePosterior(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_posterior(is:istream, binary:bool) -> list<list<tuple<int, float>>>
static PyObject* wrapReadPosterior_as_read_posterior(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_posterior", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_posterior", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_posterior", names[1], "bool", a[1]);
  ::kaldi::Posterior ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ReadPosterior(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// total_posterior(post:list<list<tuple<int, float>>>) -> float
static PyObject* wrapTotalPosterior_as_total_posterior(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:total_posterior", names, &a[0])) return nullptr;
  ::kaldi::Posterior arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("total_posterior", names[0], "::kaldi::Posterior", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TotalPosterior(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// posterior_entries_are_disjoint(post_elem1:list<tuple<int, float>>, post_elem2:list<tuple<int, float>>) -> bool
static PyObject* wrapPosteriorEntriesAreDisjoint_as_posterior_entries_are_disjoint(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("post_elem1"),
      C("post_elem2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:posterior_entries_are_disjoint", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("posterior_entries_are_disjoint", names[0], "::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >", a[0]);
  ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("posterior_entries_are_disjoint", names[1], "::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::PosteriorEntriesAreDisjoint(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// merge_posteriors(post1:list<list<tuple<int, float>>>, post2:list<list<tuple<int, float>>>, merge:bool, drop_frames:bool) -> (num_frames:int, post:list<list<tuple<int, float>>>)
static PyObject* wrapMergePosteriors_as_merge_posteriors(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("post1"),
      C("post2"),
      C("merge"),
      C("drop_frames"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:merge_posteriors", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::Posterior arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("merge_posteriors", names[0], "::kaldi::Posterior", a[0]);
  ::kaldi::Posterior arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("merge_posteriors", names[1], "::kaldi::Posterior", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("merge_posteriors", names[2], "bool", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("merge_posteriors", names[3], "bool", a[3]);
  ::kaldi::Posterior ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::MergePosteriors(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// vector_to_posterior_entry(log_likes:VectorBase, num_gselect:int, min_post:float) -> (log_like:float, post_entry:list<tuple<int, float>>)
static PyObject* wrapVectorToPosteriorEntry_as_vector_to_posterior_entry(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("log_likes"),
      C("num_gselect"),
      C("min_post"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:vector_to_posterior_entry", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("vector_to_posterior_entry", names[0], "::kaldi::VectorBase<float>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("vector_to_posterior_entry", names[1], "int", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("vector_to_posterior_entry", names[2], "float", a[2]);
  ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> > ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VectorToPosteriorEntry(*arg1, std::move(arg2), std::move(arg3), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// alignment_to_posterior(ali:list<int>) -> list<list<tuple<int, float>>>
static PyObject* wrapAlignmentToPosterior_as_alignment_to_posterior(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ali"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:alignment_to_posterior", names, &a[0])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("alignment_to_posterior", names[0], "::std::vector< ::int32>", a[0]);
  ::kaldi::Posterior ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::AlignmentToPosterior(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// convert_posterior_to_pdfs(tmodel:TransitionModel, post_in:list<list<tuple<int, float>>>) -> list<list<tuple<int, float>>>
static PyObject* wrapConvertPosteriorToPdfs_as_convert_posterior_to_pdfs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("tmodel"),
      C("post_in"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:convert_posterior_to_pdfs", names, &a[0], &a[1])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_posterior_to_pdfs", names[0], "::kaldi::TransitionModel", a[0]);
  ::kaldi::Posterior arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("convert_posterior_to_pdfs", names[1], "::kaldi::Posterior", a[1]);
  ::kaldi::Posterior ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ConvertPosteriorToPdfs(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// convert_posterior_to_phones(tmodel:TransitionModel, post_in:list<list<tuple<int, float>>>) -> list<list<tuple<int, float>>>
static PyObject* wrapConvertPosteriorToPhones_as_convert_posterior_to_phones(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("tmodel"),
      C("post_in"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:convert_posterior_to_phones", names, &a[0], &a[1])) return nullptr;
  ::kaldi::TransitionModel* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("convert_posterior_to_phones", names[0], "::kaldi::TransitionModel", a[0]);
  ::kaldi::Posterior arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("convert_posterior_to_phones", names[1], "::kaldi::Posterior", a[1]);
  ::kaldi::Posterior ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ConvertPosteriorToPhones(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// posterior_to_matrix(post:list<list<tuple<int, float>>>, post_dim:int) -> Matrix
static PyObject* wrapPosteriorToMatrix_as_posterior_to_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("post"),
      C("post_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:posterior_to_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::Posterior arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("posterior_to_matrix", names[0], "::kaldi::Posterior", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("posterior_to_matrix", names[1], "int", a[1]);
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::PosteriorToMatrix(std::move(arg1), std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// posterior_to_pdf_matrix(post:list<list<tuple<int, float>>>, model:TransitionModel) -> Matrix
static PyObject* wrapPosteriorToPdfMatrix_as_posterior_to_pdf_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("post"),
      C("model"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:posterior_to_pdf_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::Posterior arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("posterior_to_pdf_matrix", names[0], "::kaldi::Posterior", a[0]);
  ::kaldi::TransitionModel* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("posterior_to_pdf_matrix", names[1], "::kaldi::TransitionModel", a[1]);
  ::kaldi::Matrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::PosteriorToPdfMatrix(std::move(arg1), *arg2, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("write_posterior"), (PyCFunction)wrapWritePosterior_as_write_posterior, METH_VARARGS | METH_KEYWORDS, C("write_posterior(os:ostream, binary:bool, post:list<list<tuple<int, float>>>)\n  Calls C++ function\n  void ::kaldi::WritePosterior(::std::basic_ostream<char, ::std::char_traits<char> >, bool, ::kaldi::Posterior)")},
  {C("read_posterior"), (PyCFunction)wrapReadPosterior_as_read_posterior, METH_VARARGS | METH_KEYWORDS, C("read_posterior(is:istream, binary:bool) -> list<list<tuple<int, float>>>\n  Calls C++ function\n  void ::kaldi::ReadPosterior(::std::basic_istream<char, ::std::char_traits<char> >, bool, ::kaldi::Posterior*)")},
  {C("total_posterior"), (PyCFunction)wrapTotalPosterior_as_total_posterior, METH_VARARGS | METH_KEYWORDS, C("total_posterior(post:list<list<tuple<int, float>>>) -> float\n  Calls C++ function\n  float ::kaldi::TotalPosterior(::kaldi::Posterior)")},
  {C("posterior_entries_are_disjoint"), (PyCFunction)wrapPosteriorEntriesAreDisjoint_as_posterior_entries_are_disjoint, METH_VARARGS | METH_KEYWORDS, C("posterior_entries_are_disjoint(post_elem1:list<tuple<int, float>>, post_elem2:list<tuple<int, float>>) -> bool\n  Calls C++ function\n  bool ::kaldi::PosteriorEntriesAreDisjoint(::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >, ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >)")},
  {C("merge_posteriors"), (PyCFunction)wrapMergePosteriors_as_merge_posteriors, METH_VARARGS | METH_KEYWORDS, C("merge_posteriors(post1:list<list<tuple<int, float>>>, post2:list<list<tuple<int, float>>>, merge:bool, drop_frames:bool) -> (num_frames:int, post:list<list<tuple<int, float>>>)\n  Calls C++ function\n  int ::kaldi::MergePosteriors(::kaldi::Posterior, ::kaldi::Posterior, bool, bool, ::kaldi::Posterior*)")},
  {C("vector_to_posterior_entry"), (PyCFunction)wrapVectorToPosteriorEntry_as_vector_to_posterior_entry, METH_VARARGS | METH_KEYWORDS, C("vector_to_posterior_entry(log_likes:VectorBase, num_gselect:int, min_post:float) -> (log_like:float, post_entry:list<tuple<int, float>>)\n  Calls C++ function\n  float ::kaldi::VectorToPosteriorEntry(::kaldi::VectorBase<float>, int, float, ::std::vector< ::std::pair< ::int32, ::kaldi::BaseFloat> >*)")},
  {C("alignment_to_posterior"), (PyCFunction)wrapAlignmentToPosterior_as_alignment_to_posterior, METH_VARARGS | METH_KEYWORDS, C("alignment_to_posterior(ali:list<int>) -> list<list<tuple<int, float>>>\n  Calls C++ function\n  void ::kaldi::AlignmentToPosterior(::std::vector< ::int32>, ::kaldi::Posterior*)")},
  {C("convert_posterior_to_pdfs"), (PyCFunction)wrapConvertPosteriorToPdfs_as_convert_posterior_to_pdfs, METH_VARARGS | METH_KEYWORDS, C("convert_posterior_to_pdfs(tmodel:TransitionModel, post_in:list<list<tuple<int, float>>>) -> list<list<tuple<int, float>>>\n  Calls C++ function\n  void ::kaldi::ConvertPosteriorToPdfs(::kaldi::TransitionModel, ::kaldi::Posterior, ::kaldi::Posterior*)")},
  {C("convert_posterior_to_phones"), (PyCFunction)wrapConvertPosteriorToPhones_as_convert_posterior_to_phones, METH_VARARGS | METH_KEYWORDS, C("convert_posterior_to_phones(tmodel:TransitionModel, post_in:list<list<tuple<int, float>>>) -> list<list<tuple<int, float>>>\n  Calls C++ function\n  void ::kaldi::ConvertPosteriorToPhones(::kaldi::TransitionModel, ::kaldi::Posterior, ::kaldi::Posterior*)")},
  {C("posterior_to_matrix"), (PyCFunction)wrapPosteriorToMatrix_as_posterior_to_matrix, METH_VARARGS | METH_KEYWORDS, C("posterior_to_matrix(post:list<list<tuple<int, float>>>, post_dim:int) -> Matrix\n  Calls C++ function\n  void ::kaldi::PosteriorToMatrix(::kaldi::Posterior, int, ::kaldi::Matrix<float>*)")},
  {C("posterior_to_pdf_matrix"), (PyCFunction)wrapPosteriorToPdfMatrix_as_posterior_to_pdf_matrix, METH_VARARGS | METH_KEYWORDS, C("posterior_to_pdf_matrix(post:list<list<tuple<int, float>>>, model:TransitionModel) -> Matrix\n  Calls C++ function\n  void ::kaldi::PosteriorToPdfMatrix(::kaldi::Posterior, ::kaldi::TransitionModel, ::kaldi::Matrix<float>*)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_posterior",  // module name
  "CLIF-generated module for hmm/posterior.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_transition_model")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __posterior_clifwrap
