//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/cudamatrix/cu-matrixdim.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "cu-matrixdim-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __cu__matrixdim_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyMatrixElement {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::MatrixElement<float>> cpp;
};
static ::MatrixElement<float>* ThisPtr(PyObject*);

static PyObject* get_row(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->row, {});
}

static int set_row(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the row attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->row)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for row:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_column(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->column, {});
}

static int set_column(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the column attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->column)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for column:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->weight, {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("row"), get_row, set_row, C("C++ ::int32_cuda MatrixElement<float>.row")},
  {C("column"), get_column, set_column, C("C++ ::int32_cuda MatrixElement<float>.column")},
  {C("weight"), get_weight, set_weight, C("C++ float MatrixElement<float>.weight")},
  {}
};

// MatrixElement __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// MatrixElement __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixElement __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrixdim.MatrixElement",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::MatrixElement<float>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "MatrixElement takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::MatrixElement<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::MatrixElement<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_MatrixElement_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::MatrixElement<float>"));
      if (!PyErr_Occurred()) {
        ::MatrixElement<float>* c = static_cast<::MatrixElement<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::MatrixElement<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixElement

namespace pyDoubleMatrixElement {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::MatrixElement<double>> cpp;
};
static ::MatrixElement<double>* ThisPtr(PyObject*);

static PyObject* get_row(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->row, {});
}

static int set_row(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the row attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->row)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for row:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_column(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->column, {});
}

static int set_column(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the column attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->column)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for column:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->weight, {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("row"), get_row, set_row, C("C++ ::int32_cuda MatrixElement<double>.row")},
  {C("column"), get_column, set_column, C("C++ ::int32_cuda MatrixElement<double>.column")},
  {C("weight"), get_weight, set_weight, C("C++ double MatrixElement<double>.weight")},
  {}
};

// DoubleMatrixElement __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleMatrixElement __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleMatrixElement __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrixdim.DoubleMatrixElement", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::MatrixElement<double>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleMatrixElement takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::MatrixElement<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::MatrixElement<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_MatrixElement_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::MatrixElement<double>"));
      if (!PyErr_Occurred()) {
        ::MatrixElement<double>* c = static_cast<::MatrixElement<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::MatrixElement<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleMatrixElement

namespace pyMatrixDim {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::MatrixDim_> cpp;
};
static ::MatrixDim_* ThisPtr(PyObject*);

static PyObject* get_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->rows, {});
}

static int set_rows(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the rows attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->rows)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for rows:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->cols, {});
}

static int set_cols(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cols attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cols)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cols:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_stride(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->stride, {});
}

static int set_stride(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the stride attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->stride)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for stride:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("rows"), get_rows, set_rows, C("C++ ::int32_cuda MatrixDim_.rows")},
  {C("cols"), get_cols, set_cols, C("C++ ::int32_cuda MatrixDim_.cols")},
  {C("stride"), get_stride, set_stride, C("C++ ::int32_cuda MatrixDim_.stride")},
  {}
};

// MatrixDim __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// MatrixDim __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixDim __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrixdim.MatrixDim",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::MatrixDim_",     // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "MatrixDim takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::MatrixDim_>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::MatrixDim_* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_MatrixDim_"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::MatrixDim_"));
      if (!PyErr_Occurred()) {
        ::MatrixDim_* c = static_cast<::MatrixDim_*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::MatrixDim_*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixDim

namespace pyCuBlockMatrixData {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::CuBlockMatrixData_> cpp;
};
static ::CuBlockMatrixData_* ThisPtr(PyObject*);

static PyObject* get_row_offset(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->row_offset, {});
}

static int set_row_offset(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the row_offset attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->row_offset)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for row_offset:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_col_offset(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->col_offset, {});
}

static int set_col_offset(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the col_offset attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->col_offset)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for col_offset:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_matrix_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->matrix_dim), {});
}

static int set_matrix_dim(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the matrix_dim attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->matrix_dim)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for matrix_dim:MatrixDim", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("row_offset"), get_row_offset, set_row_offset, C("C++ ::int32_cuda CuBlockMatrixData_.row_offset")},
  {C("col_offset"), get_col_offset, set_col_offset, C("C++ ::int32_cuda CuBlockMatrixData_.col_offset")},
  {C("matrix_dim"), get_matrix_dim, set_matrix_dim, C("C++ ::MatrixDim CuBlockMatrixData_.matrix_dim")},
  {}
};

// CuBlockMatrixData __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CuBlockMatrixData __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuBlockMatrixData __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrixdim.CuBlockMatrixData",   // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::CuBlockMatrixData_", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CuBlockMatrixData takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::CuBlockMatrixData_>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::CuBlockMatrixData_* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_CuBlockMatrixData_"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::CuBlockMatrixData_"));
      if (!PyErr_Occurred()) {
        ::CuBlockMatrixData_* c = static_cast<::CuBlockMatrixData_*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::CuBlockMatrixData_*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuBlockMatrixData

namespace pyIntPair {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::Int32Pair> cpp;
};
static ::Int32Pair* ThisPtr(PyObject*);

static PyObject* get_first(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->first, {});
}

static int set_first(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->first)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for first:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_second(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->second, {});
}

static int set_second(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the second attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->second)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for second:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("first"), get_first, set_first, C("C++ ::int32_cuda Int32Pair.first")},
  {C("second"), get_second, set_second, C("C++ ::int32_cuda Int32Pair.second")},
  {}
};

// IntPair __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IntPair __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IntPair __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrixdim.IntPair",             // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::Int32Pair",      // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IntPair takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::Int32Pair>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::Int32Pair* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_Int32Pair"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::Int32Pair"));
      if (!PyErr_Occurred()) {
        ::Int32Pair* c = static_cast<::Int32Pair*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::Int32Pair*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIntPair


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyMatrixElement::wrapper_Type) < 0) return false;
  Py_INCREF(&pyMatrixElement::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleMatrixElement::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleMatrixElement::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyMatrixDim::wrapper_Type) < 0) return false;
  Py_INCREF(&pyMatrixDim::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCuBlockMatrixData::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuBlockMatrixData::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyIntPair::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIntPair::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_cu_matrixdim",  // module name
  "CLIF-generated module for cudamatrix/cu-matrixdim.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "MatrixElement", reinterpret_cast<PyObject*>(&pyMatrixElement::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleMatrixElement", reinterpret_cast<PyObject*>(&pyDoubleMatrixElement::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "MatrixDim", reinterpret_cast<PyObject*>(&pyMatrixDim::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuBlockMatrixData", reinterpret_cast<PyObject*>(&pyCuBlockMatrixData::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IntPair", reinterpret_cast<PyObject*>(&pyIntPair::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __cu__matrixdim_clifwrap

namespace clif {

// CuBlockMatrixData to/from ::CuBlockMatrixData_ conversion

bool Clif_PyObjAs(PyObject* py, ::CuBlockMatrixData_** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::CuBlockMatrixData_* cpp = __cu__matrixdim_clifwrap::pyCuBlockMatrixData::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::CuBlockMatrixData_>* c) {
  assert(c != nullptr);
  ::CuBlockMatrixData_* cpp = __cu__matrixdim_clifwrap::pyCuBlockMatrixData::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::CuBlockMatrixData_>* c) {
  assert(c != nullptr);
  ::CuBlockMatrixData_* cpp = __cu__matrixdim_clifwrap::pyCuBlockMatrixData::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuBlockMatrixData instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::CuBlockMatrixData_* c) {
  assert(c != nullptr);
  ::CuBlockMatrixData_* cpp = __cu__matrixdim_clifwrap::pyCuBlockMatrixData::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::CuBlockMatrixData_>* c) {
  assert(c != nullptr);
  ::CuBlockMatrixData_* cpp = __cu__matrixdim_clifwrap::pyCuBlockMatrixData::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::CuBlockMatrixData_* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp = ::clif::Instance<::CuBlockMatrixData_>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::CuBlockMatrixData_> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp = ::clif::Instance<::CuBlockMatrixData_>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::CuBlockMatrixData_> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp = ::clif::Instance<::CuBlockMatrixData_>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::CuBlockMatrixData_& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyCuBlockMatrixData::wrapper*>(py)->cpp = ::clif::MakeShared<::CuBlockMatrixData_>(c);
  return py;
}

// DoubleMatrixElement to/from ::MatrixElement<double> conversion

bool Clif_PyObjAs(PyObject* py, ::MatrixElement<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::MatrixElement<double>* cpp = __cu__matrixdim_clifwrap::pyDoubleMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::MatrixElement<double>>* c) {
  assert(c != nullptr);
  ::MatrixElement<double>* cpp = __cu__matrixdim_clifwrap::pyDoubleMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::MatrixElement<double>>* c) {
  assert(c != nullptr);
  ::MatrixElement<double>* cpp = __cu__matrixdim_clifwrap::pyDoubleMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleMatrixElement instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::MatrixElement<double>* c) {
  assert(c != nullptr);
  ::MatrixElement<double>* cpp = __cu__matrixdim_clifwrap::pyDoubleMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::MatrixElement<double>>* c) {
  assert(c != nullptr);
  ::MatrixElement<double>* cpp = __cu__matrixdim_clifwrap::pyDoubleMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::MatrixElement<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::MatrixElement<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::MatrixElement<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::MatrixElement<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyDoubleMatrixElement::wrapper*>(py)->cpp = ::clif::MakeShared<::MatrixElement<double>>(c);
  return py;
}

// IntPair to/from ::Int32Pair conversion

bool Clif_PyObjAs(PyObject* py, ::Int32Pair** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::Int32Pair* cpp = __cu__matrixdim_clifwrap::pyIntPair::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::Int32Pair>* c) {
  assert(c != nullptr);
  ::Int32Pair* cpp = __cu__matrixdim_clifwrap::pyIntPair::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::Int32Pair>* c) {
  assert(c != nullptr);
  ::Int32Pair* cpp = __cu__matrixdim_clifwrap::pyIntPair::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IntPair instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::Int32Pair* c) {
  assert(c != nullptr);
  ::Int32Pair* cpp = __cu__matrixdim_clifwrap::pyIntPair::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::Int32Pair>* c) {
  assert(c != nullptr);
  ::Int32Pair* cpp = __cu__matrixdim_clifwrap::pyIntPair::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::Int32Pair* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyIntPair::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp = ::clif::Instance<::Int32Pair>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::Int32Pair> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyIntPair::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp = ::clif::Instance<::Int32Pair>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::Int32Pair> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyIntPair::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp = ::clif::Instance<::Int32Pair>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::Int32Pair& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyIntPair::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyIntPair::wrapper*>(py)->cpp = ::clif::MakeShared<::Int32Pair>(c);
  return py;
}

// MatrixDim to/from ::MatrixDim_ conversion

bool Clif_PyObjAs(PyObject* py, ::MatrixDim_** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::MatrixDim_* cpp = __cu__matrixdim_clifwrap::pyMatrixDim::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::MatrixDim_>* c) {
  assert(c != nullptr);
  ::MatrixDim_* cpp = __cu__matrixdim_clifwrap::pyMatrixDim::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::MatrixDim_>* c) {
  assert(c != nullptr);
  ::MatrixDim_* cpp = __cu__matrixdim_clifwrap::pyMatrixDim::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert MatrixDim instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::MatrixDim_* c) {
  assert(c != nullptr);
  ::MatrixDim_* cpp = __cu__matrixdim_clifwrap::pyMatrixDim::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::MatrixDim_>* c) {
  assert(c != nullptr);
  ::MatrixDim_* cpp = __cu__matrixdim_clifwrap::pyMatrixDim::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::MatrixDim_* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixDim::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp = ::clif::Instance<::MatrixDim_>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::MatrixDim_> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixDim::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp = ::clif::Instance<::MatrixDim_>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::MatrixDim_> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixDim::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp = ::clif::Instance<::MatrixDim_>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::MatrixDim_& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixDim::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixDim::wrapper*>(py)->cpp = ::clif::MakeShared<::MatrixDim_>(c);
  return py;
}

// MatrixElement to/from ::MatrixElement<float> conversion

bool Clif_PyObjAs(PyObject* py, ::MatrixElement<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::MatrixElement<float>* cpp = __cu__matrixdim_clifwrap::pyMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::MatrixElement<float>>* c) {
  assert(c != nullptr);
  ::MatrixElement<float>* cpp = __cu__matrixdim_clifwrap::pyMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::MatrixElement<float>>* c) {
  assert(c != nullptr);
  ::MatrixElement<float>* cpp = __cu__matrixdim_clifwrap::pyMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert MatrixElement instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::MatrixElement<float>* c) {
  assert(c != nullptr);
  ::MatrixElement<float>* cpp = __cu__matrixdim_clifwrap::pyMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::MatrixElement<float>>* c) {
  assert(c != nullptr);
  ::MatrixElement<float>* cpp = __cu__matrixdim_clifwrap::pyMatrixElement::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::MatrixElement<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::MatrixElement<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::MatrixElement<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp = ::clif::Instance<::MatrixElement<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::MatrixElement<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrixdim_clifwrap::pyMatrixElement::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrixdim_clifwrap::pyMatrixElement::wrapper*>(py)->cpp = ::clif::MakeShared<::MatrixElement<float>>(c);
  return py;
}

}  // namespace clif
