//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/tree/build-tree.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "itf/clusterable-itf-clifwrap.h"
#include "tree/event-map-clifwrap.h"
#include "tree/build-tree-questions-clifwrap.h"
#include "build-tree-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __build__tree_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// build_tree(qopts:Questions, phone_sets:list<list<int>>, phone2num_pdf_classes:list<int>, share_roots:list<bool>, do_split:list<bool>, stats:list<tuple<list<tuple<int, int>>, Clusterable>>, thresh:float, max_leaves:int, cluster_thresh:float, P:int, round_num_leaves:bool=default) -> EventMap
static PyObject* wrapBuildTree_as_build_tree(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[11]{};
  char* names[] = {
      C("qopts"),
      C("phone_sets"),
      C("phone2num_pdf_classes"),
      C("share_roots"),
      C("do_split"),
      C("stats"),
      C("thresh"),
      C("max_leaves"),
      C("cluster_thresh"),
      C("P"),
      C("round_num_leaves"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOOOO|O:build_tree", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8], &a[9], &a[10])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 11; nargs > 10; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::Questions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("build_tree", names[0], "::kaldi::Questions", a[0]);
  ::std::vector< ::std::vector< ::int32> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("build_tree", names[1], "::std::vector< ::std::vector< ::int32> >", a[1]);
  ::std::vector< ::int32> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("build_tree", names[2], "::std::vector< ::int32>", a[2]);
  ::std::vector<bool> arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("build_tree", names[3], "::std::vector<bool>", a[3]);
  ::std::vector<bool> arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("build_tree", names[4], "::std::vector<bool>", a[4]);
  ::kaldi::BuildTreeStatsType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("build_tree", names[5], "::kaldi::BuildTreeStatsType", a[5]);
  float arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("build_tree", names[6], "float", a[6]);
  int arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("build_tree", names[7], "int", a[7]);
  float arg9;
  if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("build_tree", names[8], "float", a[8]);
  int arg10;
  if (!Clif_PyObjAs(a[9], &arg10)) return ArgError("build_tree", names[9], "int", a[9]);
  bool arg11;
  if (nargs > 10) {
    if (!a[10]) arg11 = (bool)true;
    else if (!Clif_PyObjAs(a[10], &arg11)) return ArgError("build_tree", names[10], "bool", a[10]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 10:
    ret0 = ::kaldi::BuildTree(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9), std::move(arg10)); break;
  case 11:
    ret0 = ::kaldi::BuildTree(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9), std::move(arg10), std::move(arg11)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// build_tree_two_level(qopts:Questions, phone_sets:list<list<int>>, phone2num_pdf_classes:list<int>, share_roots:list<bool>, do_split:list<bool>, stats:list<tuple<list<tuple<int, int>>, Clusterable>>, max_leaves_first:int, max_leaves_second:int, cluster_leaves:bool, P:int) -> (tree:EventMap, leaf_map:list<int>)
static PyObject* wrapBuildTreeTwoLevel_as_build_tree_two_level(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[10];
  char* names[] = {
      C("qopts"),
      C("phone_sets"),
      C("phone2num_pdf_classes"),
      C("share_roots"),
      C("do_split"),
      C("stats"),
      C("max_leaves_first"),
      C("max_leaves_second"),
      C("cluster_leaves"),
      C("P"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOOOO:build_tree_two_level", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8], &a[9])) return nullptr;
  ::kaldi::Questions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("build_tree_two_level", names[0], "::kaldi::Questions", a[0]);
  ::std::vector< ::std::vector< ::int32> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("build_tree_two_level", names[1], "::std::vector< ::std::vector< ::int32> >", a[1]);
  ::std::vector< ::int32> arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("build_tree_two_level", names[2], "::std::vector< ::int32>", a[2]);
  ::std::vector<bool> arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("build_tree_two_level", names[3], "::std::vector<bool>", a[3]);
  ::std::vector<bool> arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("build_tree_two_level", names[4], "::std::vector<bool>", a[4]);
  ::kaldi::BuildTreeStatsType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("build_tree_two_level", names[5], "::kaldi::BuildTreeStatsType", a[5]);
  int arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("build_tree_two_level", names[6], "int", a[6]);
  int arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("build_tree_two_level", names[7], "int", a[7]);
  bool arg9;
  if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("build_tree_two_level", names[8], "bool", a[8]);
  int arg10;
  if (!Clif_PyObjAs(a[9], &arg10)) return ArgError("build_tree_two_level", names[9], "int", a[9]);
  ::std::vector< ::int32> ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::EventMap * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::BuildTreeTwoLevel(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9), std::move(arg10), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// gen_rand_stats(dim:int, num_stats:int, N:int, P:int, phone_ids:list<int>, hmm_lengths:list<int>, is_ctx_dep:list<bool>, ensure_all_phones_covered:bool) -> list<tuple<list<tuple<int, int>>, Clusterable>>
static PyObject* wrapGenRandStats_as_gen_rand_stats(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("dim"),
      C("num_stats"),
      C("N"),
      C("P"),
      C("phone_ids"),
      C("hmm_lengths"),
      C("is_ctx_dep"),
      C("ensure_all_phones_covered"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:gen_rand_stats", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("gen_rand_stats", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("gen_rand_stats", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("gen_rand_stats", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("gen_rand_stats", names[3], "int", a[3]);
  ::std::vector< ::int32> arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("gen_rand_stats", names[4], "::std::vector< ::int32>", a[4]);
  ::std::vector< ::int32> arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("gen_rand_stats", names[5], "::std::vector< ::int32>", a[5]);
  ::std::vector<bool> arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("gen_rand_stats", names[6], "::std::vector<bool>", a[6]);
  bool arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("gen_rand_stats", names[7], "bool", a[7]);
  ::kaldi::BuildTreeStatsType ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::GenRandStats(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_symbol_table_as_integers(filename:str, include_eps:bool) -> list<int>
static PyObject* wrapReadSymbolTableAsIntegers_as_read_symbol_table_as_integers(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("filename"),
      C("include_eps"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_symbol_table_as_integers", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_symbol_table_as_integers", names[0], "::std::string", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_symbol_table_as_integers", names[1], "bool", a[1]);
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ReadSymbolTableAsIntegers(std::move(arg1), std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_roots_file(is:istream) -> (phone_sets:list<list<int>>, is_shared_root:list<bool>, is_split_root:list<bool>)
static PyObject* wrapReadRootsFile_as_read_roots_file(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("is"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:read_roots_file", names, &a[0])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_roots_file", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::vector< ::int32> > ret0{};
  ::std::vector<bool> ret1{};
  ::std::vector<bool> ret2{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::ReadRootsFile(*arg1, &ret0, &ret1, &ret2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(3);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("build_tree"), (PyCFunction)wrapBuildTree_as_build_tree, METH_VARARGS | METH_KEYWORDS, C("build_tree(qopts:Questions, phone_sets:list<list<int>>, phone2num_pdf_classes:list<int>, share_roots:list<bool>, do_split:list<bool>, stats:list<tuple<list<tuple<int, int>>, Clusterable>>, thresh:float, max_leaves:int, cluster_thresh:float, P:int, round_num_leaves:bool=default) -> EventMap\n\nBuilds a set of decision trees.\n\nThis is the normal way to build a set of decision trees. The sets\n'phone_sets' dictacte how we set up the roots of the decision trees.\nEach set of phones phone_sets[i] has shared decision-tree roots, and if\nthe corresponding variable share_roots[i] is true, the root will be\nshared for the different HMM-positions in the phone.\n\nArgs:\n    qopts (:class:`Questions`): Questions options class, contains\n      questions for each key\n    phone_sets (list): Each element of phone_sets is a set of phones\n      whose roots are shared together\n    phone2num_pdf_classes (list): A map from phones to the number of\n      pdf_classes in the phone\n    share_roots (list): A vector the same size as phone_sets; says for\n      each phone set whether the root should be shared among all the\n      pdf-classes or not\n    do_split (list): A vector the same size as phone_sets; says for\n      each phone set whether decision-tree splitting should be done\n    stats (list): The statistics used in tree-building\n    thresh (float): Threshold used in decision-tree splitting or you\n      may use 0 in which case max_leaves becomes the constraint\n    max_leaves (int): Maximum number of leaves it will create; set\n      this to a large number if you want to specify just thresh\n    cluster_thresh (float): Threshold for clustering leaves after\n      decision-tree splitting; leaves will be combined if\n      log-likelihood change is less than this.\n    P (int): The central position of the phone context window\n    round_num_leaves (bool): If true, then the number of leaves in the\n      final tree is made a multiple of 8. This is done by further\n      clustering the leaves after they are first clustered based on\n      log-likelihood change. (See cluster_thresh above) (default: True).\n\nReturns:\n    EventMap object that is the tree.")},
  {C("build_tree_two_level"), (PyCFunction)wrapBuildTreeTwoLevel_as_build_tree_two_level, METH_VARARGS | METH_KEYWORDS, C("build_tree_two_level(qopts:Questions, phone_sets:list<list<int>>, phone2num_pdf_classes:list<int>, share_roots:list<bool>, do_split:list<bool>, stats:list<tuple<list<tuple<int, int>>, Clusterable>>, max_leaves_first:int, max_leaves_second:int, cluster_leaves:bool, P:int) -> (tree:EventMap, leaf_map:list<int>)\n\nBuilds a two-level decision tree.\n\nThis is useful for example in building tied mixture systems with\nmultiple codebooks.\n\nArgs:\n    qopts (:class:`Questions`): Questions options class, contains\n      questions for each key\n    phone_sets (list): Each element of phone_sets is a set of phones\n      whose roots are shared together\n    phone2num_pdf_classes (list): A map from phones to the number of\n      pdf_classes in the phone\n    share_roots (list): A vector the same size as phone_sets; says for\n      each phone set whether the root should be shared among all the\n      pdf-classes or not\n    do_split (list): A vector the same size as phone_sets; says for\n      each phone set whether decision-tree splitting should be done\n    stats (list): The statistics used in tree-building\n    max_leaves_first (int): Maximum number of leaves it will create\n      in first level\n    max_leaves_second (int): Maximum number of leaves it will create\n      in second level\n    cluster_leaves (bool): If true, post-cluster the leaves produced\n      in the second level.\n    P (int): The central position of the phone context window\n\nReturns:\n    tree: EventMap object that is the tree\n    leaf_map: Mapping from the leaves of the big tree to the leaves\n    of the little tree")},
  {C("gen_rand_stats"), (PyCFunction)wrapGenRandStats_as_gen_rand_stats, METH_VARARGS | METH_KEYWORDS, C("gen_rand_stats(dim:int, num_stats:int, N:int, P:int, phone_ids:list<int>, hmm_lengths:list<int>, is_ctx_dep:list<bool>, ensure_all_phones_covered:bool) -> list<tuple<list<tuple<int, int>>, Clusterable>>\n\nGenerates random statistics of the form used by build_tree.\n\nIt tries to do so in such a way that they mimic \"real\" stats.\nThe event keys and their corresponding values are:\n\n===============  ============================================\nkey              value\n===============  ============================================\n-1 == PDF_CLASS  pdf-class\n0                phone-id of left-most context phone\n1                phone-id of one-from-left-most context phone\nP - 1            phone-id of central phone\nN - 1            phone-id of right-most context phone.\n===============  ============================================\n\nArgs:\n    dim (int): dimension of features\n    num_stats (int): approximate number of separate phones-in-context\n      wanted\n    N (int): context-size\n    P (int): central-phone position\n    phone_ids (list): ids of phones\n    hmm_lengths (list): lenghts of hmm for phone\n    is_ctx_dep (list): boolean array whether each phone is\n      context-dependant\n    ensure_all_phones_covered (bool): If true, ensures that every\n      phone is seen at least once in the central position\n\nReturns:\n    Statistics of the form used by BuildTree")},
  {C("read_symbol_table_as_integers"), (PyCFunction)wrapReadSymbolTableAsIntegers_as_read_symbol_table_as_integers, METH_VARARGS | METH_KEYWORDS, C("read_symbol_table_as_integers(filename:str, include_eps:bool) -> list<int>\n\nReads a symbol table, discards the symbols and returns the indexes.")},
  {C("read_roots_file"), (PyCFunction)wrapReadRootsFile_as_read_roots_file, METH_VARARGS | METH_KEYWORDS, C("read_roots_file(is:istream) -> (phone_sets:list<list<int>>, is_shared_root:list<bool>, is_split_root:list<bool>)\n\nReads roots from file.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_build_tree",  // module name
  "CLIF-generated module for tree/build-tree.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_clusterable_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_event_map")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_build_tree_questions")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __build__tree_clifwrap
