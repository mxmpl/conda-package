//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/online2/online-gmm-decoding.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "itf/options-itf-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "base/iostream-clifwrap.h"
#include "hmm/transition-model-clifwrap.h"
#include "gmm/am-diag-gmm-clifwrap.h"
#include "transform/basis-fmllr-diag-gmm-clifwrap.h"
#include "transform/fmllr-diag-gmm-clifwrap.h"
#include "feat/online-feature-clifwrap.h"
#include "online2/online-feature-pipeline-clifwrap.h"
#include "online2/online-gmm-decodable-clifwrap.h"
#include "online2/online-endpoint-clifwrap.h"
#include "decoder/lattice-faster-decoder-clifwrap.h"
#include "hmm/posterior-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "online-gmm-decoding-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __online__gmm__decoding_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyOnlineGmmDecodingAdaptationPolicyConfig {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig> cpp;
};
static ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* ThisPtr(PyObject*);

static PyObject* get_adaptation_first_utt_delay(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->adaptation_first_utt_delay, {});
}

static int set_adaptation_first_utt_delay(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptation_first_utt_delay attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->adaptation_first_utt_delay)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for adaptation_first_utt_delay:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_adaptation_first_utt_ratio(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->adaptation_first_utt_ratio, {});
}

static int set_adaptation_first_utt_ratio(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptation_first_utt_ratio attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->adaptation_first_utt_ratio)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for adaptation_first_utt_ratio:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_adaptation_delay(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->adaptation_delay, {});
}

static int set_adaptation_delay(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptation_delay attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->adaptation_delay)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for adaptation_delay:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_adaptation_ratio(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->adaptation_ratio, {});
}

static int set_adaptation_ratio(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptation_ratio attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->adaptation_ratio)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for adaptation_ratio:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// check()
static PyObject* wrapCheck_as_check(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Check();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// do_adapt(chunk_begin_secs:float, chuck_end_secs:float, is_first_utterance:bool) -> bool
static PyObject* wrapDoAdapt_as_do_adapt(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("chunk_begin_secs"),
      C("chuck_end_secs"),
      C("is_first_utterance"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:do_adapt", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("do_adapt", names[0], "float", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("do_adapt", names[1], "float", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("do_adapt", names[2], "bool", a[2]);
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->DoAdapt(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("adaptation_first_utt_delay"), get_adaptation_first_utt_delay, set_adaptation_first_utt_delay, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingAdaptationPolicyConfig.adaptation_first_utt_delay")},
  {C("adaptation_first_utt_ratio"), get_adaptation_first_utt_ratio, set_adaptation_first_utt_ratio, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingAdaptationPolicyConfig.adaptation_first_utt_ratio")},
  {C("adaptation_delay"), get_adaptation_delay, set_adaptation_delay, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingAdaptationPolicyConfig.adaptation_delay")},
  {C("adaptation_ratio"), get_adaptation_ratio, set_adaptation_ratio, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingAdaptationPolicyConfig.adaptation_ratio")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig::Register(::kaldi::OptionsItf *)")},
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_NOARGS, C("check()\n  Calls C++ function\n  void ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig::Check()")},
  {C("do_adapt"), (PyCFunction)wrapDoAdapt_as_do_adapt, METH_VARARGS | METH_KEYWORDS, C("do_adapt(chunk_begin_secs:float, chuck_end_secs:float, is_first_utterance:bool) -> bool\n  Calls C++ function\n  bool ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig::DoAdapt(float, float, bool)")},
  {}
};

// OnlineGmmDecodingAdaptationPolicyConfig __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OnlineGmmDecodingAdaptationPolicyConfig __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OnlineGmmDecodingAdaptationPolicyConfig __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_online_gmm_decoding.OnlineGmmDecodingAdaptationPolicyConfig", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "OnlineGmmDecodingAdaptationPolicyConfig takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OnlineGmmDecodingAdaptationPolicyConfig"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OnlineGmmDecodingAdaptationPolicyConfig"));
      if (!PyErr_Occurred()) {
        ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c = static_cast<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOnlineGmmDecodingAdaptationPolicyConfig

namespace pyOnlineGmmDecodingConfig {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OnlineGmmDecodingConfig> cpp;
};
static ::kaldi::OnlineGmmDecodingConfig* ThisPtr(PyObject*);

static PyObject* get_fmllr_lattice_beam(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->fmllr_lattice_beam, {});
}

static int set_fmllr_lattice_beam(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the fmllr_lattice_beam attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->fmllr_lattice_beam)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for fmllr_lattice_beam:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_basis_opts(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->basis_opts), {});
}

static int set_basis_opts(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the basis_opts attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->basis_opts)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for basis_opts:BasisFmllrOptions", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_faster_decoder_opts(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->faster_decoder_opts), {});
}

static int set_faster_decoder_opts(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the faster_decoder_opts attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->faster_decoder_opts)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for faster_decoder_opts:LatticeFasterDecoderOptions", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_adaptation_policy_opts(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->adaptation_policy_opts), {});
}

static int set_adaptation_policy_opts(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the adaptation_policy_opts attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->adaptation_policy_opts)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for adaptation_policy_opts:OnlineGmmDecodingAdaptationPolicyConfig", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_online_alimdl_rxfilename(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->online_alimdl_rxfilename, _1);
}

static int set_online_alimdl_rxfilename(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the online_alimdl_rxfilename attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->online_alimdl_rxfilename)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for online_alimdl_rxfilename:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_model_rxfilename(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->model_rxfilename, _1);
}

static int set_model_rxfilename(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the model_rxfilename attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->model_rxfilename)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for model_rxfilename:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_rescore_model_rxfilename(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->rescore_model_rxfilename, _1);
}

static int set_rescore_model_rxfilename(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the rescore_model_rxfilename attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->rescore_model_rxfilename)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for rescore_model_rxfilename:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_fmllr_basis_rxfilename(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->fmllr_basis_rxfilename, _1);
}

static int set_fmllr_basis_rxfilename(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the fmllr_basis_rxfilename attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->fmllr_basis_rxfilename)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for fmllr_basis_rxfilename:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_acoustic_scale(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->acoustic_scale, {});
}

static int set_acoustic_scale(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the acoustic_scale attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->acoustic_scale)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for acoustic_scale:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_silence_phones(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->silence_phones, _1);
}

static int set_silence_phones(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the silence_phones attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->silence_phones)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for silence_phones:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_silence_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->silence_weight, {});
}

static int set_silence_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the silence_weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->silence_weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for silence_weight:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("fmllr_lattice_beam"), get_fmllr_lattice_beam, set_fmllr_lattice_beam, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingConfig.fmllr_lattice_beam")},
  {C("basis_opts"), get_basis_opts, set_basis_opts, C("C++ ::kaldi::BasisFmllrOptions OnlineGmmDecodingConfig.basis_opts")},
  {C("faster_decoder_opts"), get_faster_decoder_opts, set_faster_decoder_opts, C("C++ ::kaldi::LatticeFasterDecoderConfig OnlineGmmDecodingConfig.faster_decoder_opts")},
  {C("adaptation_policy_opts"), get_adaptation_policy_opts, set_adaptation_policy_opts, C("C++ ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig OnlineGmmDecodingConfig.adaptation_policy_opts")},
  {C("online_alimdl_rxfilename"), get_online_alimdl_rxfilename, set_online_alimdl_rxfilename, C("C++ ::std::string OnlineGmmDecodingConfig.online_alimdl_rxfilename")},
  {C("model_rxfilename"), get_model_rxfilename, set_model_rxfilename, C("C++ ::std::string OnlineGmmDecodingConfig.model_rxfilename")},
  {C("rescore_model_rxfilename"), get_rescore_model_rxfilename, set_rescore_model_rxfilename, C("C++ ::std::string OnlineGmmDecodingConfig.rescore_model_rxfilename")},
  {C("fmllr_basis_rxfilename"), get_fmllr_basis_rxfilename, set_fmllr_basis_rxfilename, C("C++ ::std::string OnlineGmmDecodingConfig.fmllr_basis_rxfilename")},
  {C("acoustic_scale"), get_acoustic_scale, set_acoustic_scale, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingConfig.acoustic_scale")},
  {C("silence_phones"), get_silence_phones, set_silence_phones, C("C++ ::std::string OnlineGmmDecodingConfig.silence_phones")},
  {C("silence_weight"), get_silence_weight, set_silence_weight, C("C++ ::kaldi::BaseFloat OnlineGmmDecodingConfig.silence_weight")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n  Calls C++ function\n  void ::kaldi::OnlineGmmDecodingConfig::Register(::kaldi::OptionsItf *)")},
  {}
};

// OnlineGmmDecodingConfig __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OnlineGmmDecodingConfig __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OnlineGmmDecodingConfig __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_online_gmm_decoding.OnlineGmmDecodingConfig", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::OnlineGmmDecodingConfig", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "OnlineGmmDecodingConfig takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingConfig>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OnlineGmmDecodingConfig* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OnlineGmmDecodingConfig"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OnlineGmmDecodingConfig"));
      if (!PyErr_Occurred()) {
        ::kaldi::OnlineGmmDecodingConfig* c = static_cast<::kaldi::OnlineGmmDecodingConfig*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OnlineGmmDecodingConfig*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOnlineGmmDecodingConfig

namespace pyOnlineGmmDecodingModels {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OnlineGmmDecodingModels> cpp;
};
static ::kaldi::OnlineGmmDecodingModels* ThisPtr(PyObject*);

// __init__(config:OnlineGmmDecodingConfig)
static PyObject* wrapOnlineGmmDecodingModels_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::kaldi::OnlineGmmDecodingConfig* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::OnlineGmmDecodingConfig", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingModels>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_transition_model() -> TransitionModel
static PyObject* wrapGetTransitionModel_as_get_transition_model(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingModels* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::TransitionModel ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetTransitionModel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_online_alignment_model() -> AmDiagGmm
static PyObject* wrapGetOnlineAlignmentModel_as_get_online_alignment_model(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingModels* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::AmDiagGmm ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetOnlineAlignmentModel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_model() -> AmDiagGmm
static PyObject* wrapGetModel_as_get_model(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingModels* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::AmDiagGmm ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetModel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_final_model() -> AmDiagGmm
static PyObject* wrapGetFinalModel_as_get_final_model(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingModels* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::AmDiagGmm ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetFinalModel();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// basis_fmllr_estimate() -> BasisFmllrEstimate
static PyObject* wrapGetFmllrBasis_as_basis_fmllr_estimate(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OnlineGmmDecodingModels* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::BasisFmllrEstimate ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetFmllrBasis();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapOnlineGmmDecodingModels_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(config:OnlineGmmDecodingConfig)\n  Calls C++ function\n  void ::kaldi::OnlineGmmDecodingModels::OnlineGmmDecodingModels(::kaldi::OnlineGmmDecodingConfig)")},
  {C("get_transition_model"), (PyCFunction)wrapGetTransitionModel_as_get_transition_model, METH_NOARGS, C("get_transition_model() -> TransitionModel\n  Calls C++ function\n  ::kaldi::TransitionModel ::kaldi::OnlineGmmDecodingModels::GetTransitionModel()")},
  {C("get_online_alignment_model"), (PyCFunction)wrapGetOnlineAlignmentModel_as_get_online_alignment_model, METH_NOARGS, C("get_online_alignment_model() -> AmDiagGmm\n  Calls C++ function\n  ::kaldi::AmDiagGmm ::kaldi::OnlineGmmDecodingModels::GetOnlineAlignmentModel()")},
  {C("get_model"), (PyCFunction)wrapGetModel_as_get_model, METH_NOARGS, C("get_model() -> AmDiagGmm\n  Calls C++ function\n  ::kaldi::AmDiagGmm ::kaldi::OnlineGmmDecodingModels::GetModel()")},
  {C("get_final_model"), (PyCFunction)wrapGetFinalModel_as_get_final_model, METH_NOARGS, C("get_final_model() -> AmDiagGmm\n  Calls C++ function\n  ::kaldi::AmDiagGmm ::kaldi::OnlineGmmDecodingModels::GetFinalModel()")},
  {C("basis_fmllr_estimate"), (PyCFunction)wrapGetFmllrBasis_as_basis_fmllr_estimate, METH_NOARGS, C("basis_fmllr_estimate() -> BasisFmllrEstimate\n  Calls C++ function\n  ::kaldi::BasisFmllrEstimate ::kaldi::OnlineGmmDecodingModels::GetFmllrBasis()")},
  {}
};

// OnlineGmmDecodingModels __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OnlineGmmDecodingModels __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OnlineGmmDecodingModels __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_online_gmm_decoding.OnlineGmmDecodingModels", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::OnlineGmmDecodingModels", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapOnlineGmmDecodingModels_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OnlineGmmDecodingModels* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OnlineGmmDecodingModels"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OnlineGmmDecodingModels"));
      if (!PyErr_Occurred()) {
        ::kaldi::OnlineGmmDecodingModels* c = static_cast<::kaldi::OnlineGmmDecodingModels*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OnlineGmmDecodingModels*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOnlineGmmDecodingModels

namespace pyOnlineGmmAdaptationState {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OnlineGmmAdaptationState> cpp;
};
static ::kaldi::OnlineGmmAdaptationState* ThisPtr(PyObject*);

static PyObject* get_cmvn_state(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->cmvn_state), {});
}

static int set_cmvn_state(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cmvn_state attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cmvn_state)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cmvn_state:OnlineCmvnState", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_transform(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->transform), {});
}

static int set_transform(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the _transform attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->transform)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for _transform:Matrix", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// write(out_stream:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("out_stream"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::OnlineGmmAdaptationState* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(in_stream:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("in_stream"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::OnlineGmmAdaptationState* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("cmvn_state"), get_cmvn_state, set_cmvn_state, C("C++ ::kaldi::OnlineCmvnState OnlineGmmAdaptationState.cmvn_state")},
  {C("_transform"), get_transform, set_transform, C("C++ ::kaldi::Matrix< ::kaldi::BaseFloat> OnlineGmmAdaptationState.transform")},
  {}
};

static PyMethodDef Methods[] = {
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(out_stream:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::OnlineGmmAdaptationState::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(in_stream:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::OnlineGmmAdaptationState::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// OnlineGmmAdaptationState __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OnlineGmmAdaptationState __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OnlineGmmAdaptationState __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_online_gmm_decoding.OnlineGmmAdaptationState", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::OnlineGmmAdaptationState", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "OnlineGmmAdaptationState takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmAdaptationState>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OnlineGmmAdaptationState* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OnlineGmmAdaptationState"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OnlineGmmAdaptationState"));
      if (!PyErr_Occurred()) {
        ::kaldi::OnlineGmmAdaptationState* c = static_cast<::kaldi::OnlineGmmAdaptationState*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OnlineGmmAdaptationState*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOnlineGmmAdaptationState

namespace py_SingleUtteranceGmmDecoder {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::SingleUtteranceGmmDecoder> cpp;
};
static ::kaldi::SingleUtteranceGmmDecoder* ThisPtr(PyObject*);

// __init__(config:OnlineGmmDecodingConfig, models:OnlineGmmDecodingModels, feature_prototype:_OnlineFeaturePipeline, fst:StdFst, adaptation_state:OnlineGmmAdaptationState)
static PyObject* wrapSingleUtteranceGmmDecoder_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("config"),
      C("models"),
      C("feature_prototype"),
      C("fst"),
      C("adaptation_state"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:__init__", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::OnlineGmmDecodingConfig* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::OnlineGmmDecodingConfig", a[0]);
  ::kaldi::OnlineGmmDecodingModels* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::OnlineGmmDecodingModels", a[1]);
  ::kaldi::OnlineFeaturePipeline* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "::kaldi::OnlineFeaturePipeline", a[2]);
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("__init__", names[3], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[3]);
  ::kaldi::OnlineGmmAdaptationState* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("__init__", names[4], "::kaldi::OnlineGmmAdaptationState", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::SingleUtteranceGmmDecoder>(*arg1, *arg2, *arg3, *arg4, *arg5);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _feature_pipeline() -> _OnlineFeaturePipeline
static PyObject* wrapFeaturePipeline_as__feature_pipeline(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::kaldi::OnlineFeaturePipeline> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FeaturePipeline();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// advance_decoding()
static PyObject* wrapAdvanceDecoding_as_advance_decoding(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AdvanceDecoding();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// finalize_decoding()
static PyObject* wrapFinalizeDecoding_as_finalize_decoding(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FinalizeDecoding();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// have_transform() -> bool
static PyObject* wrapHaveTransform_as_have_transform(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->HaveTransform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// estimate_fmllr(end_of_utterance:bool)
static PyObject* wrapEstimateFmllr_as_estimate_fmllr(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("end_of_utterance"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:estimate_fmllr", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("estimate_fmllr", names[0], "bool", a[0]);
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->EstimateFmllr(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_adaptation_state(adaptation_state:OnlineGmmAdaptationState)
static PyObject* wrapGetAdaptationState_as_get_adaptation_state(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("adaptation_state"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_adaptation_state", names, &a[0])) return nullptr;
  ::kaldi::OnlineGmmAdaptationState * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_adaptation_state", names[0], "::kaldi::OnlineGmmAdaptationState *", a[0]);
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetAdaptationState(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_lattice(rescore_if_needed:bool, end_of_utterance:bool, clat:CompactLatticeVectorFst)
static PyObject* wrapGetLattice_as_get_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("rescore_if_needed"),
      C("end_of_utterance"),
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:get_lattice", names, &a[0], &a[1], &a[2])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_lattice", names[0], "bool", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_lattice", names[1], "bool", a[1]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_lattice", names[2], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > *", a[2]);
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetLattice(std::move(arg1), std::move(arg2), arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_best_path(end_of_utterance:bool, best_path:LatticeVectorFst)
static PyObject* wrapGetBestPath_as_get_best_path(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("end_of_utterance"),
      C("best_path"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_best_path", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_best_path", names[0], "bool", a[0]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_best_path", names[1], "::fst::VectorFst< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > > > *", a[1]);
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetBestPath(std::move(arg1), arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// final_relative_cost() -> float
static PyObject* wrapFinalRelativeCost_as_final_relative_cost(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FinalRelativeCost();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// endpoint_detected(config:OnlineEndpointConfig) -> bool
static PyObject* wrapEndpointDetected_as_endpoint_detected(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("config"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:endpoint_detected", names, &a[0])) return nullptr;
  ::kaldi::OnlineEndpointConfig* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("endpoint_detected", names[0], "::kaldi::OnlineEndpointConfig", a[0]);
  // Call actual C++ method.
  ::kaldi::SingleUtteranceGmmDecoder* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->EndpointDetected(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSingleUtteranceGmmDecoder_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(config:OnlineGmmDecodingConfig, models:OnlineGmmDecodingModels, feature_prototype:_OnlineFeaturePipeline, fst:StdFst, adaptation_state:OnlineGmmAdaptationState)\n  Calls C++ function\n  void ::kaldi::SingleUtteranceGmmDecoder::SingleUtteranceGmmDecoder(::kaldi::OnlineGmmDecodingConfig, ::kaldi::OnlineGmmDecodingModels, ::kaldi::OnlineFeaturePipeline, ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >, ::kaldi::OnlineGmmAdaptationState)")},
  {C("_feature_pipeline"), (PyCFunction)wrapFeaturePipeline_as__feature_pipeline, METH_NOARGS, C("_feature_pipeline() -> _OnlineFeaturePipeline\n  Calls C++ function\n  ::kaldi::OnlineFeaturePipeline ::kaldi::SingleUtteranceGmmDecoder::FeaturePipeline()")},
  {C("advance_decoding"), (PyCFunction)wrapAdvanceDecoding_as_advance_decoding, METH_NOARGS, C("advance_decoding()\n\nAdvance the decoding as far as we can.")},
  {C("finalize_decoding"), (PyCFunction)wrapFinalizeDecoding_as_finalize_decoding, METH_NOARGS, C("finalize_decoding()\n\nFinalize the decoding")},
  {C("have_transform"), (PyCFunction)wrapHaveTransform_as_have_transform, METH_NOARGS, C("have_transform() -> bool\n\nReturns true if we already have a fMLLR transform")},
  {C("estimate_fmllr"), (PyCFunction)wrapEstimateFmllr_as_estimate_fmllr, METH_VARARGS | METH_KEYWORDS, C("estimate_fmllr(end_of_utterance:bool)\n\nEstimate the [basis-]fMLLR transform and apply it to the features")},
  {C("get_adaptation_state"), (PyCFunction)wrapGetAdaptationState_as_get_adaptation_state, METH_VARARGS | METH_KEYWORDS, C("get_adaptation_state(adaptation_state:OnlineGmmAdaptationState)\n  Calls C++ function\n  void ::kaldi::SingleUtteranceGmmDecoder::GetAdaptationState(::kaldi::OnlineGmmAdaptationState *)")},
  {C("get_lattice"), (PyCFunction)wrapGetLattice_as_get_lattice, METH_VARARGS | METH_KEYWORDS, C("get_lattice(rescore_if_needed:bool, end_of_utterance:bool, clat:CompactLatticeVectorFst)\n\nGets the lattice. If rescore_if_needed is true and if there is any point in rescoring the state-level lattice, it will rescore the lattice.")},
  {C("get_best_path"), (PyCFunction)wrapGetBestPath_as_get_best_path, METH_VARARGS | METH_KEYWORDS, C("get_best_path(end_of_utterance:bool, best_path:LatticeVectorFst)\n\nOutputs an FST corresponding to the single best path through the current lattice.")},
  {C("final_relative_cost"), (PyCFunction)wrapFinalRelativeCost_as_final_relative_cost, METH_NOARGS, C("final_relative_cost() -> float\n\nOutputs to final_relative_cost, if non-NULL, a number >= 0 that will be close to zero if the final-probs were close to the best probs active on the final state.")},
  {C("endpoint_detected"), (PyCFunction)wrapEndpointDetected_as_endpoint_detected, METH_VARARGS | METH_KEYWORDS, C("endpoint_detected(config:OnlineEndpointConfig) -> bool\n  Calls C++ function\n  bool ::kaldi::SingleUtteranceGmmDecoder::EndpointDetected(::kaldi::OnlineEndpointConfig)")},
  {}
};

// _SingleUtteranceGmmDecoder __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// _SingleUtteranceGmmDecoder __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// _SingleUtteranceGmmDecoder __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_online_gmm_decoding._SingleUtteranceGmmDecoder", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::SingleUtteranceGmmDecoder", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSingleUtteranceGmmDecoder_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::SingleUtteranceGmmDecoder* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_SingleUtteranceGmmDecoder"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::SingleUtteranceGmmDecoder"));
      if (!PyErr_Occurred()) {
        ::kaldi::SingleUtteranceGmmDecoder* c = static_cast<::kaldi::SingleUtteranceGmmDecoder*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::SingleUtteranceGmmDecoder*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace py_SingleUtteranceGmmDecoder


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyOnlineGmmDecodingConfig::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOnlineGmmDecodingConfig::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyOnlineGmmDecodingModels::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOnlineGmmDecodingModels::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyOnlineGmmAdaptationState::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOnlineGmmAdaptationState::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&py_SingleUtteranceGmmDecoder::wrapper_Type) < 0) return false;
  Py_INCREF(&py_SingleUtteranceGmmDecoder::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_online_gmm_decoding",  // module name
  "CLIF-generated module for online2/online-gmm-decoding.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_transition_model")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_am_diag_gmm")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_basis_fmllr_diag_gmm")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fmllr_diag_gmm")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_online_feature")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_online_feature_pipeline")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_online_gmm_decodable")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_online_endpoint")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_faster_decoder")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "OnlineGmmDecodingAdaptationPolicyConfig", reinterpret_cast<PyObject*>(&pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OnlineGmmDecodingConfig", reinterpret_cast<PyObject*>(&pyOnlineGmmDecodingConfig::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OnlineGmmDecodingModels", reinterpret_cast<PyObject*>(&pyOnlineGmmDecodingModels::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OnlineGmmAdaptationState", reinterpret_cast<PyObject*>(&pyOnlineGmmAdaptationState::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "_SingleUtteranceGmmDecoder", reinterpret_cast<PyObject*>(&py_SingleUtteranceGmmDecoder::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __online__gmm__decoding_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// OnlineGmmAdaptationState to/from ::kaldi::OnlineGmmAdaptationState conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmAdaptationState** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OnlineGmmAdaptationState* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OnlineGmmAdaptationState>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmAdaptationState* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OnlineGmmAdaptationState>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmAdaptationState* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OnlineGmmAdaptationState instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmAdaptationState* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmAdaptationState* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::OnlineGmmAdaptationState>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmAdaptationState* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OnlineGmmAdaptationState* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmAdaptationState>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OnlineGmmAdaptationState> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmAdaptationState>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OnlineGmmAdaptationState> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmAdaptationState>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::OnlineGmmAdaptationState& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmAdaptationState::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmAdaptationState>(c);
  return py;
}

// OnlineGmmDecodingAdaptationPolicyConfig to/from ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OnlineGmmDecodingAdaptationPolicyConfig instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OnlineGmmDecodingAdaptationPolicyConfig* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::OnlineGmmDecodingAdaptationPolicyConfig& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingAdaptationPolicyConfig::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingAdaptationPolicyConfig>(c);
  return py;
}

// OnlineGmmDecodingConfig to/from ::kaldi::OnlineGmmDecodingConfig conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingConfig** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OnlineGmmDecodingConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OnlineGmmDecodingConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OnlineGmmDecodingConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OnlineGmmDecodingConfig instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingConfig* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::OnlineGmmDecodingConfig>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingConfig* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OnlineGmmDecodingConfig* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingConfig>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OnlineGmmDecodingConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingConfig>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OnlineGmmDecodingConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingConfig>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::OnlineGmmDecodingConfig& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingConfig::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingConfig>(c);
  return py;
}

// OnlineGmmDecodingModels to/from ::kaldi::OnlineGmmDecodingModels conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingModels** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OnlineGmmDecodingModels* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OnlineGmmDecodingModels>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingModels* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OnlineGmmDecodingModels>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingModels* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OnlineGmmDecodingModels instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::OnlineGmmDecodingModels* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingModels* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::OnlineGmmDecodingModels>* c) {
  assert(c != nullptr);
  ::kaldi::OnlineGmmDecodingModels* cpp = __online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OnlineGmmDecodingModels* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingModels>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OnlineGmmDecodingModels> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingModels>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OnlineGmmDecodingModels> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OnlineGmmDecodingModels>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::OnlineGmmDecodingModels& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::pyOnlineGmmDecodingModels::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::OnlineGmmDecodingModels>(c);
  return py;
}

// _SingleUtteranceGmmDecoder to/from ::kaldi::SingleUtteranceGmmDecoder conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SingleUtteranceGmmDecoder** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::SingleUtteranceGmmDecoder* cpp = __online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::SingleUtteranceGmmDecoder>* c) {
  assert(c != nullptr);
  ::kaldi::SingleUtteranceGmmDecoder* cpp = __online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::SingleUtteranceGmmDecoder>* c) {
  assert(c != nullptr);
  ::kaldi::SingleUtteranceGmmDecoder* cpp = __online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert _SingleUtteranceGmmDecoder instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::SingleUtteranceGmmDecoder* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SingleUtteranceGmmDecoder>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::SingleUtteranceGmmDecoder> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SingleUtteranceGmmDecoder>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::SingleUtteranceGmmDecoder> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper_Type, NULL, NULL);
  reinterpret_cast<__online__gmm__decoding_clifwrap::py_SingleUtteranceGmmDecoder::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::SingleUtteranceGmmDecoder>(std::move(c));
  return py;
}

}  // namespace kaldi
