//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/nnet3/nnet-computation.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/matrix-common-clifwrap.h"
#include "cudamatrix/cu-matrixdim-clifwrap.h"
#include "cudamatrix/cu-array-clifwrap.h"
#include "nnet3/nnet-common-clifwrap.h"
#include "nnet3/nnet-misc-computation-info-clifwrap.h"
#include "nnet3/nnet-nnet-clifwrap.h"
#include "nnet-computation-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __nnet__computation_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


namespace pyIoSpecification {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::IoSpecification> cpp;
};
static ::kaldi::nnet3::IoSpecification* ThisPtr(PyObject*);

static PyObject* get_name(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->name, _1);
}

static int set_name(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the name attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->name)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for name:str", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes, {});
}

static int set_indexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes:list<Index>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_has_deriv(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->has_deriv, {});
}

static int set_has_deriv(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the has_deriv attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->has_deriv)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for has_deriv:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_other(other:IoSpecification) -> IoSpecification
static PyObject* wrapIoSpecification_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::IoSpecification* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::IoSpecification", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::IoSpecification> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::IoSpecification>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_indexes(name:str, indexes:list<Index>, has_deriv:bool=default) -> IoSpecification
static PyObject* wrapIoSpecification_as_from_indexes(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("name"),
      C("indexes"),
      C("has_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:from_indexes", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_indexes", names[0], "::std::string", a[0]);
  ::std::vector< ::kaldi::nnet3::Index> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_indexes", names[1], "::std::vector< ::kaldi::nnet3::Index>", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (bool)false;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_indexes", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::IoSpecification> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::IoSpecification>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::IoSpecification>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_interval(name:str, t_start:int, t_end:int) -> IoSpecification
static PyObject* wrapIoSpecification_as_from_interval(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("name"),
      C("t_start"),
      C("t_end"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:from_interval", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_interval", names[0], "::std::string", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_interval", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_interval", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::IoSpecification> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::IoSpecification>(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// print_io_spec(os:ostream)
static PyObject* wrapPrint_as_print_io_spec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("os"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:print_io_spec", names, &a[0])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("print_io_spec", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::IoSpecification* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Print(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap(other:IoSpecification)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::nnet3::IoSpecification * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::nnet3::IoSpecification *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::IoSpecification* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::IoSpecification* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::IoSpecification* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// __eq__(other:IoSpecification) -> bool
static PyObject* wrap__eq__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__eq__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::IoSpecification* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__eq__", names[0], "::kaldi::nnet3::IoSpecification", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::IoSpecification* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator==(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("name"), get_name, set_name, C("C++ ::std::string IoSpecification.name")},
  {C("indexes"), get_indexes, set_indexes, C("C++ ::std::vector< ::kaldi::nnet3::Index> IoSpecification.indexes")},
  {C("has_deriv"), get_has_deriv, set_has_deriv, C("C++ bool IoSpecification.has_deriv")},
  {}
};

PyObject* slot_richcmp(PyObject* self, PyObject* other, int op) {
  switch (op) {
    case Py_EQ: return slot::adapter<wrap__eq__>(self, other);
    default: Py_RETURN_NOTIMPLEMENTED;
  }
}

static PyMethodDef Methods[] = {
  {C("from_other"), (PyCFunction)wrapIoSpecification_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:IoSpecification) -> IoSpecification\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::IoSpecification> ::kaldi::nnet3::IoSpecification::IoSpecification(::kaldi::nnet3::IoSpecification)")},
  {C("from_indexes"), (PyCFunction)wrapIoSpecification_as_from_indexes, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_indexes(name:str, indexes:list<Index>, has_deriv:bool=default) -> IoSpecification\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::IoSpecification> ::kaldi::nnet3::IoSpecification::IoSpecification(::std::string, ::std::vector< ::kaldi::nnet3::Index>, bool)")},
  {C("from_interval"), (PyCFunction)wrapIoSpecification_as_from_interval, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_interval(name:str, t_start:int, t_end:int) -> IoSpecification\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::IoSpecification> ::kaldi::nnet3::IoSpecification::IoSpecification(::std::string, int, int)")},
  {C("print_io_spec"), (PyCFunction)wrapPrint_as_print_io_spec, METH_VARARGS | METH_KEYWORDS, C("print_io_spec(os:ostream)\n  Calls C++ function\n  void ::kaldi::nnet3::IoSpecification::Print(::std::basic_ostream<char, ::std::char_traits<char> >)")},
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:IoSpecification)\n  Calls C++ function\n  void ::kaldi::nnet3::IoSpecification::Swap(::kaldi::nnet3::IoSpecification *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::IoSpecification::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::IoSpecification::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// IoSpecification __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// IoSpecification __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// IoSpecification __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.IoSpecification", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::IoSpecification", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  slot_richcmp,                        // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "IoSpecification takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::IoSpecification>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::IoSpecification* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_IoSpecification"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::IoSpecification"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::IoSpecification* c = static_cast<::kaldi::nnet3::IoSpecification*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::IoSpecification*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyIoSpecification

namespace pyComputationRequest {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ComputationRequest> cpp;
};
static ::kaldi::nnet3::ComputationRequest* ThisPtr(PyObject*);

static PyObject* get_inputs(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->inputs, {});
}

static int set_inputs(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the inputs attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->inputs)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for inputs:list<IoSpecification>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_outputs(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->outputs, {});
}

static int set_outputs(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the outputs attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->outputs)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for outputs:list<IoSpecification>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_need_model_derivative(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->need_model_derivative, {});
}

static int set_need_model_derivative(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the need_model_derivative attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->need_model_derivative)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for need_model_derivative:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_store_component_stats(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->store_component_stats, {});
}

static int set_store_component_stats(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the store_component_stats attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->store_component_stats)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for store_component_stats:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_misc_info(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->misc_info), {});
}

static int set_misc_info(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the misc_info attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->misc_info)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for misc_info:MiscComputationInfo", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// need_derivatives() -> bool
static PyObject* wrapNeedDerivatives_as_need_derivatives(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NeedDerivatives();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// index_for_input(node_name:str) -> int
static PyObject* wrapIndexForInput_as_index_for_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_name"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:index_for_input", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("index_for_input", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IndexForInput(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// index_for_output(node_name:str) -> int
static PyObject* wrapIndexForOutput_as_index_for_output(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_name"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:index_for_output", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("index_for_output", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IndexForOutput(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// print_request(os:ostream)
static PyObject* wrapPrint_as_print_request(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("os"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:print_request", names, &a[0])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("print_request", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Print(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// __eq__(other:ComputationRequest) -> bool
static PyObject* wrap__eq__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__eq__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ComputationRequest* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__eq__", names[0], "::kaldi::nnet3::ComputationRequest", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ComputationRequest* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator==(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("inputs"), get_inputs, set_inputs, C("C++ ::std::vector< ::kaldi::nnet3::IoSpecification> ComputationRequest.inputs")},
  {C("outputs"), get_outputs, set_outputs, C("C++ ::std::vector< ::kaldi::nnet3::IoSpecification> ComputationRequest.outputs")},
  {C("need_model_derivative"), get_need_model_derivative, set_need_model_derivative, C("C++ bool ComputationRequest.need_model_derivative")},
  {C("store_component_stats"), get_store_component_stats, set_store_component_stats, C("C++ bool ComputationRequest.store_component_stats")},
  {C("misc_info"), get_misc_info, set_misc_info, C("C++ ::kaldi::nnet3::MiscComputationInfo ComputationRequest.misc_info")},
  {}
};

PyObject* slot_richcmp(PyObject* self, PyObject* other, int op) {
  switch (op) {
    case Py_EQ: return slot::adapter<wrap__eq__>(self, other);
    default: Py_RETURN_NOTIMPLEMENTED;
  }
}

static PyMethodDef Methods[] = {
  {C("need_derivatives"), (PyCFunction)wrapNeedDerivatives_as_need_derivatives, METH_NOARGS, C("need_derivatives() -> bool\n  Calls C++ function\n  bool ::kaldi::nnet3::ComputationRequest::NeedDerivatives()")},
  {C("index_for_input"), (PyCFunction)wrapIndexForInput_as_index_for_input, METH_VARARGS | METH_KEYWORDS, C("index_for_input(node_name:str) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ComputationRequest::IndexForInput(::std::string)")},
  {C("index_for_output"), (PyCFunction)wrapIndexForOutput_as_index_for_output, METH_VARARGS | METH_KEYWORDS, C("index_for_output(node_name:str) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ComputationRequest::IndexForOutput(::std::string)")},
  {C("print_request"), (PyCFunction)wrapPrint_as_print_request, METH_VARARGS | METH_KEYWORDS, C("print_request(os:ostream)\n  Calls C++ function\n  void ::kaldi::nnet3::ComputationRequest::Print(::std::basic_ostream<char, ::std::char_traits<char> >)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ComputationRequest::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::ComputationRequest::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// ComputationRequest __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ComputationRequest __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ComputationRequest __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.ComputationRequest", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ComputationRequest", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  slot_richcmp,                        // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "ComputationRequest takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ComputationRequest>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ComputationRequest* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ComputationRequest"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ComputationRequest"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ComputationRequest* c = static_cast<::kaldi::nnet3::ComputationRequest*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ComputationRequest*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyComputationRequest

// Create Python Enum object (cached in _CommandType) for ::kaldi::nnet3::CommandType
static PyObject* wrapCommandType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(25);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ALLOC_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAllocMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DEALLOC_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kDeallocMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SWAP_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kSwapMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SET_CONST"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kSetConst)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("PROPAGATE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kPropagate)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("BACKPROP"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kBackprop)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("BACKPROP_NO_MODEL_UPDATE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kBackpropNoModelUpdate)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 6, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATRIX_COPY"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kMatrixCopy)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 7, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATRIX_ADD"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kMatrixAdd)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 8, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COPY_ROWS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kCopyRows)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 9, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ADD_ROWS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAddRows)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 10, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COPY_ROWS_MULTI"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kCopyRowsMulti)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 11, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COPY_TO_ROWS_MULTI"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kCopyToRowsMulti)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 12, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ADD_ROWS_MULTI"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAddRowsMulti)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 13, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ADD_TO_ROWS_MULTI"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAddToRowsMulti)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 14, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ADD_ROW_RANGES"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAddRowRanges)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 15, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COMPRESS_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kCompressMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 16, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DECOMPRESS_MATRIX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kDecompressMatrix)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 17, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ACCEPT_INPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kAcceptInput)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 18, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("PROVIDE_OUTPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kProvideOutput)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 19, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_OPERATION"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kNoOperation)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 20, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_OPERATION_PERMANENT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kNoOperationPermanent)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 21, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_OPERATION_MARKER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kNoOperationMarker)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 22, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_OPERATION_LABEL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kNoOperationLabel)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 23, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("GOTO_LABEL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(::kaldi::nnet3::CommandType::kGotoLabel)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 24, py);
  py = PyUnicode_FromString("CommandType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _CommandType{};  // set by above func in Init()

namespace pyNnetComputation {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation> cpp;
};
static ::kaldi::nnet3::NnetComputation* ThisPtr(PyObject*);

namespace pyMatrixInfo {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixInfo> cpp;
};
static ::kaldi::nnet3::NnetComputation::MatrixInfo* ThisPtr(PyObject*);

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_rows, {});
}

static int set_num_rows(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_rows attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_rows)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_rows:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_cols, {});
}

static int set_num_cols(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_cols attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_cols)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_cols:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_stride_type(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->stride_type, {});
}

static int set_stride_type(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the stride_type attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->stride_type)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for stride_type:MatrixStrideType", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_args(num_rows:int, num_cols:int, stride_type:MatrixStrideType) -> MatrixInfo
static PyObject* wrapMatrixInfo_as_from_args(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("num_rows"),
      C("num_cols"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:from_args", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_args", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_args", names[1], "int", a[1]);
  ::kaldi::MatrixStrideType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_args", names[2], "::kaldi::MatrixStrideType", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NnetComputation::MatrixInfo>(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::MatrixInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::MatrixInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("num_rows"), get_num_rows, set_num_rows, C("C++ ::int32 NnetComputation::MatrixInfo.num_rows")},
  {C("num_cols"), get_num_cols, set_num_cols, C("C++ ::int32 NnetComputation::MatrixInfo.num_cols")},
  {C("stride_type"), get_stride_type, set_stride_type, C("C++ ::kaldi::MatrixStrideType NnetComputation::MatrixInfo.stride_type")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_args"), (PyCFunction)wrapMatrixInfo_as_from_args, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_args(num_rows:int, num_cols:int, stride_type:MatrixStrideType) -> MatrixInfo\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo> ::kaldi::nnet3::NnetComputation::MatrixInfo::MatrixInfo(int, int, ::kaldi::MatrixStrideType)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::MatrixInfo::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::MatrixInfo::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// MatrixInfo __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// MatrixInfo __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixInfo __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation.MatrixInfo", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation::MatrixInfo", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "MatrixInfo takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::MatrixInfo>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation::MatrixInfo* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation_MatrixInfo"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation::MatrixInfo"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation::MatrixInfo* c = static_cast<::kaldi::nnet3::NnetComputation::MatrixInfo*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation::MatrixInfo*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixInfo

namespace pyMatrixDebugInfo {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixDebugInfo> cpp;
};
static ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* ThisPtr(PyObject*);

static PyObject* get_is_deriv(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->is_deriv, {});
}

static int set_is_deriv(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the is_deriv attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->is_deriv)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for is_deriv:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cindexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->cindexes, {});
}

static int set_cindexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cindexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cindexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cindexes:list<tuple<int, Index>>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// swap(other:MatrixDebugInfo)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::nnet3::NnetComputation::MatrixDebugInfo *", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("is_deriv"), get_is_deriv, set_is_deriv, C("C++ bool NnetComputation::MatrixDebugInfo.is_deriv")},
  {C("cindexes"), get_cindexes, set_cindexes, C("C++ ::std::vector< ::kaldi::nnet3::Cindex> NnetComputation::MatrixDebugInfo.cindexes")},
  {}
};

static PyMethodDef Methods[] = {
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:MatrixDebugInfo)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::MatrixDebugInfo::Swap(::kaldi::nnet3::NnetComputation::MatrixDebugInfo *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::MatrixDebugInfo::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::MatrixDebugInfo::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// MatrixDebugInfo __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// MatrixDebugInfo __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixDebugInfo __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation.MatrixDebugInfo", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation::MatrixDebugInfo", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "MatrixDebugInfo takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation_MatrixDebugInfo"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation::MatrixDebugInfo"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c = static_cast<::kaldi::nnet3::NnetComputation::MatrixDebugInfo*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation::MatrixDebugInfo*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixDebugInfo

namespace pySubMatrixInfo {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation::SubMatrixInfo> cpp;
};
static ::kaldi::nnet3::NnetComputation::SubMatrixInfo* ThisPtr(PyObject*);

static PyObject* get_matrix_index(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->matrix_index, {});
}

static int set_matrix_index(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the matrix_index attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->matrix_index)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for matrix_index:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_row_offset(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->row_offset, {});
}

static int set_row_offset(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the row_offset attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->row_offset)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for row_offset:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_rows, {});
}

static int set_num_rows(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_rows attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_rows)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_rows:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_col_offset(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->col_offset, {});
}

static int set_col_offset(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the col_offset attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->col_offset)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for col_offset:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_cols, {});
}

static int set_num_cols(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_cols attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_cols)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_cols:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_args(matrix_index:int, row_offset:int, num_rows:int, col_offset:int, num_cols:int) -> SubMatrixInfo
static PyObject* wrapSubMatrixInfo_as_from_args(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("matrix_index"),
      C("row_offset"),
      C("num_rows"),
      C("col_offset"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:from_args", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_args", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_args", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_args", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_args", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("from_args", names[4], "int", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NnetComputation::SubMatrixInfo>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// __eq__(other:SubMatrixInfo) -> bool
static PyObject* wrap__eq__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__eq__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__eq__", names[0], "::kaldi::nnet3::NnetComputation::SubMatrixInfo", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator==(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("matrix_index"), get_matrix_index, set_matrix_index, C("C++ ::int32 NnetComputation::SubMatrixInfo.matrix_index")},
  {C("row_offset"), get_row_offset, set_row_offset, C("C++ ::int32 NnetComputation::SubMatrixInfo.row_offset")},
  {C("num_rows"), get_num_rows, set_num_rows, C("C++ ::int32 NnetComputation::SubMatrixInfo.num_rows")},
  {C("col_offset"), get_col_offset, set_col_offset, C("C++ ::int32 NnetComputation::SubMatrixInfo.col_offset")},
  {C("num_cols"), get_num_cols, set_num_cols, C("C++ ::int32 NnetComputation::SubMatrixInfo.num_cols")},
  {}
};

PyObject* slot_richcmp(PyObject* self, PyObject* other, int op) {
  switch (op) {
    case Py_EQ: return slot::adapter<wrap__eq__>(self, other);
    default: Py_RETURN_NOTIMPLEMENTED;
  }
}

static PyMethodDef Methods[] = {
  {C("from_args"), (PyCFunction)wrapSubMatrixInfo_as_from_args, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_args(matrix_index:int, row_offset:int, num_rows:int, col_offset:int, num_cols:int) -> SubMatrixInfo\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo> ::kaldi::nnet3::NnetComputation::SubMatrixInfo::SubMatrixInfo(int, int, int, int, int)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::SubMatrixInfo::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::SubMatrixInfo::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// SubMatrixInfo __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SubMatrixInfo __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SubMatrixInfo __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation.SubMatrixInfo", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation::SubMatrixInfo", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  slot_richcmp,                        // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "SubMatrixInfo takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::SubMatrixInfo>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation::SubMatrixInfo* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation_SubMatrixInfo"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation::SubMatrixInfo"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation::SubMatrixInfo* c = static_cast<::kaldi::nnet3::NnetComputation::SubMatrixInfo*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation::SubMatrixInfo*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySubMatrixInfo

namespace pyCommand {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation::Command> cpp;
};
static ::kaldi::nnet3::NnetComputation::Command* ThisPtr(PyObject*);

static PyObject* get_command_type(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->command_type, {});
}

static int set_command_type(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the command_type attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->command_type)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for command_type:CommandType", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_alpha(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->alpha, {});
}

static int set_alpha(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the alpha attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->alpha)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for alpha:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg1(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg1, {});
}

static int set_arg1(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg1 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg1)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg1:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg2(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg2, {});
}

static int set_arg2(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg2 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg2)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg2:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg3(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg3, {});
}

static int set_arg3(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg3 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg3)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg3:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg4(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg4, {});
}

static int set_arg4(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg4 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg4)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg4:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg5(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg5, {});
}

static int set_arg5(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg5 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg5)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg5:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg6(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg6, {});
}

static int set_arg6(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg6 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg6)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg6:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_arg7(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->arg7, {});
}

static int set_arg7(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the arg7 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->arg7)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for arg7:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// __init__(alpha:float, command_type:CommandType=default, arg1:int=default, arg2:int=default, arg3:int=default, arg4:int=default, arg5:int=default, arg6:int=default, arg7:int=default)
static PyObject* wrapCommand_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[9]{};
  char* names[] = {
      C("alpha"),
      C("command_type"),
      C("arg1"),
      C("arg2"),
      C("arg3"),
      C("arg4"),
      C("arg5"),
      C("arg6"),
      C("arg7"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OOOOOOOO:__init__", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7], &a[8])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 9; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "float", a[0]);
  ::kaldi::nnet3::CommandType arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (::kaldi::nnet3::CommandType)22;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::nnet3::CommandType", a[1]);
  }
  int arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (int)-1;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "int", a[2]);
  }
  int arg4;
  if (nargs > 3) {
    if (!a[3]) arg4 = (int)-1;
    else if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("__init__", names[3], "int", a[3]);
  }
  int arg5;
  if (nargs > 4) {
    if (!a[4]) arg5 = (int)-1;
    else if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("__init__", names[4], "int", a[4]);
  }
  int arg6;
  if (nargs > 5) {
    if (!a[5]) arg6 = (int)-1;
    else if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("__init__", names[5], "int", a[5]);
  }
  int arg7;
  if (nargs > 6) {
    if (!a[6]) arg7 = (int)-1;
    else if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("__init__", names[6], "int", a[6]);
  }
  int arg8;
  if (nargs > 7) {
    if (!a[7]) arg8 = (int)-1;
    else if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("__init__", names[7], "int", a[7]);
  }
  int arg9;
  if (nargs > 8) {
    if (!a[8]) arg9 = (int)-1;
    else if (!Clif_PyObjAs(a[8], &arg9)) return ArgError("__init__", names[8], "int", a[8]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1)); break;
  case 2:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2)); break;
  case 3:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  case 5:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5)); break;
  case 6:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6)); break;
  case 7:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7)); break;
  case 8:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8)); break;
  case 9:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5), std::move(arg6), std::move(arg7), std::move(arg8), std::move(arg9)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::Command* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation::Command* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("command_type"), get_command_type, set_command_type, C("C++ ::kaldi::nnet3::CommandType NnetComputation::Command.command_type")},
  {C("alpha"), get_alpha, set_alpha, C("C++ ::kaldi::BaseFloat NnetComputation::Command.alpha")},
  {C("arg1"), get_arg1, set_arg1, C("C++ ::int32 NnetComputation::Command.arg1")},
  {C("arg2"), get_arg2, set_arg2, C("C++ ::int32 NnetComputation::Command.arg2")},
  {C("arg3"), get_arg3, set_arg3, C("C++ ::int32 NnetComputation::Command.arg3")},
  {C("arg4"), get_arg4, set_arg4, C("C++ ::int32 NnetComputation::Command.arg4")},
  {C("arg5"), get_arg5, set_arg5, C("C++ ::int32 NnetComputation::Command.arg5")},
  {C("arg6"), get_arg6, set_arg6, C("C++ ::int32 NnetComputation::Command.arg6")},
  {C("arg7"), get_arg7, set_arg7, C("C++ ::int32 NnetComputation::Command.arg7")},
  {}
};

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapCommand_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(alpha:float, command_type:CommandType=default, arg1:int=default, arg2:int=default, arg3:int=default, arg4:int=default, arg5:int=default, arg6:int=default, arg7:int=default)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Command::Command(float, ::kaldi::nnet3::CommandType, int, int, int, int, int, int, int)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Command::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Command::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {}
};

// Command __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Command __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Command __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation.Command", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation::Command", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapCommand_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation::Command* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation_Command"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation::Command"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation::Command* c = static_cast<::kaldi::nnet3::NnetComputation::Command*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation::Command*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCommand

namespace pyPrecomputedIndexesInfo {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo> cpp;
};
static ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* ThisPtr(PyObject*);

static PyObject* get_input_indexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->input_indexes, {});
}

static int set_input_indexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the input_indexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->input_indexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for input_indexes:list<Index>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_output_indexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->output_indexes, {});
}

static int set_output_indexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the output_indexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->output_indexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for output_indexes:list<Index>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("input_indexes"), get_input_indexes, set_input_indexes, C("C++ ::std::vector< ::kaldi::nnet3::Index> NnetComputation::PrecomputedIndexesInfo.input_indexes")},
  {C("output_indexes"), get_output_indexes, set_output_indexes, C("C++ ::std::vector< ::kaldi::nnet3::Index> NnetComputation::PrecomputedIndexesInfo.output_indexes")},
  {}
};

// PrecomputedIndexesInfo __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// PrecomputedIndexesInfo __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// PrecomputedIndexesInfo __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation.PrecomputedIndexesInfo", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "PrecomputedIndexesInfo takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation_PrecomputedIndexesInfo"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* c = static_cast<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyPrecomputedIndexesInfo

static PyObject* get_matrices(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->matrices, {});
}

static int set_matrices(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the matrices attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->matrices)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for matrices:list<MatrixInfo>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_matrix_debug_info(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->matrix_debug_info, {});
}

static int set_matrix_debug_info(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the matrix_debug_info attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->matrix_debug_info)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for matrix_debug_info:list<MatrixDebugInfo>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_submatrices(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->submatrices, {});
}

static int set_submatrices(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the submatrices attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->submatrices)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for submatrices:list<SubMatrixInfo>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_component_precomputed_indexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->component_precomputed_indexes, {});
}

static int set_component_precomputed_indexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the component_precomputed_indexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->component_precomputed_indexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for component_precomputed_indexes:list<PrecomputedIndexesInfo>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes, {});
}

static int set_indexes(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes:list<list<int>>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes_multi(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes_multi, {});
}

static int set_indexes_multi(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes_multi attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes_multi)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes_multi:list<list<tuple<int, int>>>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes_ranges(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes_ranges, {});
}

static int set_indexes_ranges(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes_ranges attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes_ranges)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes_ranges:list<list<tuple<int, int>>>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_commands(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->commands, {});
}

static int set_commands(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the commands attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->commands)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for commands:list<Command>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_need_model_derivative(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->need_model_derivative, {});
}

static int set_need_model_derivative(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the need_model_derivative attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->need_model_derivative)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for need_model_derivative:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes_cuda(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes_cuda, {});
}

static int set_indexes_cuda(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes_cuda attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes_cuda)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes_cuda:list<CuArray>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_indexes_ranges_cuda(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->indexes_ranges_cuda, {});
}

static int set_indexes_ranges_cuda(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the indexes_ranges_cuda attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->indexes_ranges_cuda)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for indexes_ranges_cuda:list<CuIntPairArray>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// new_matrix(num_rows:int, num_cols:int, stride_type:MatrixStrideType) -> int
static PyObject* wrapNewMatrix_as_new_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("num_rows"),
      C("num_cols"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:new_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_matrix", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_matrix", names[1], "int", a[1]);
  ::kaldi::MatrixStrideType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("new_matrix", names[2], "::kaldi::MatrixStrideType", a[2]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NewMatrix(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// new_sub_matrix(base_submatrix:int, row_offset:int, num_rows:int, col_offset:int, num_cols:int) -> int
static PyObject* wrapNewSubMatrix_as_new_sub_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("base_submatrix"),
      C("row_offset"),
      C("num_rows"),
      C("col_offset"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:new_sub_matrix", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("new_sub_matrix", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("new_sub_matrix", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("new_sub_matrix", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("new_sub_matrix", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("new_sub_matrix", names[4], "int", a[4]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NewSubMatrix(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_whole_matrix(submatrix_index:int) -> bool
static PyObject* wrapIsWholeMatrix_as_is_whole_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("submatrix_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:is_whole_matrix", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_whole_matrix", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsWholeMatrix(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// compute_cuda_indexes()
static PyObject* wrapComputeCudaIndexes_as_compute_cuda_indexes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ComputeCudaIndexes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// print_computation(os:ostream, nnet:Nnet)
static PyObject* wrapPrint_as_print_computation(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("nnet"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:print_computation", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("print_computation", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::kaldi::nnet3::Nnet* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("print_computation", names[1], "::kaldi::nnet3::Nnet", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Print(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_submatrix_strings(nnet:Nnet) -> list<str>
static PyObject* wrapGetSubmatrixStrings_as_get_submatrix_strings(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("nnet"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_submatrix_strings", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_submatrix_strings", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::std::vector< ::std::string> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetSubmatrixStrings(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {_1});
}

// get_whole_submatrices() -> list<int>
static PyObject* wrapGetWholeSubmatrices_as_get_whole_submatrices(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetWholeSubmatrices(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_command_strings(nnet:Nnet) -> (preamble:str, command_strings:list<str>)
static PyObject* wrapGetCommandStrings_as_get_command_strings(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("nnet"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_command_strings", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Nnet* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_command_strings", names[0], "::kaldi::nnet3::Nnet", a[0]);
  ::std::string ret0{};
  ::std::vector< ::std::string> ret1{};
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetCommandStrings(*arg1, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), _1)) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {_1})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// clear()
static PyObject* wrapClear_as_clear(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::NnetComputation* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Clear();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:NnetComputation) -> NnetComputation
static PyObject* wrapNnetComputation_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::NnetComputation* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::NnetComputation", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::NnetComputation> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::NnetComputation>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyGetSetDef Properties[] = {
  {C("matrices"), get_matrices, set_matrices, C("C++ ::std::vector< ::kaldi::nnet3::NnetComputation::MatrixInfo> NnetComputation.matrices")},
  {C("matrix_debug_info"), get_matrix_debug_info, set_matrix_debug_info, C("C++ ::std::vector< ::kaldi::nnet3::NnetComputation::MatrixDebugInfo> NnetComputation.matrix_debug_info")},
  {C("submatrices"), get_submatrices, set_submatrices, C("C++ ::std::vector< ::kaldi::nnet3::NnetComputation::SubMatrixInfo> NnetComputation.submatrices")},
  {C("component_precomputed_indexes"), get_component_precomputed_indexes, set_component_precomputed_indexes, C("C++ ::std::vector< ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo> NnetComputation.component_precomputed_indexes")},
  {C("indexes"), get_indexes, set_indexes, C("C++ ::std::vector< ::std::vector< ::int32> > NnetComputation.indexes")},
  {C("indexes_multi"), get_indexes_multi, set_indexes_multi, C("C++ ::std::vector< ::std::vector< ::std::pair< ::int32, ::int32> > > NnetComputation.indexes_multi")},
  {C("indexes_ranges"), get_indexes_ranges, set_indexes_ranges, C("C++ ::std::vector< ::std::vector< ::std::pair< ::int32, ::int32> > > NnetComputation.indexes_ranges")},
  {C("commands"), get_commands, set_commands, C("C++ ::std::vector< ::kaldi::nnet3::NnetComputation::Command> NnetComputation.commands")},
  {C("need_model_derivative"), get_need_model_derivative, set_need_model_derivative, C("C++ bool NnetComputation.need_model_derivative")},
  {C("indexes_cuda"), get_indexes_cuda, set_indexes_cuda, C("C++ ::std::vector< ::kaldi::CuArray< ::int32> > NnetComputation.indexes_cuda")},
  {C("indexes_ranges_cuda"), get_indexes_ranges_cuda, set_indexes_ranges_cuda, C("C++ ::std::vector< ::kaldi::CuArray< ::Int32Pair> > NnetComputation.indexes_ranges_cuda")},
  {}
};

static PyMethodDef Methods[] = {
  {C("new_matrix"), (PyCFunction)wrapNewMatrix_as_new_matrix, METH_VARARGS | METH_KEYWORDS, C("new_matrix(num_rows:int, num_cols:int, stride_type:MatrixStrideType) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::NnetComputation::NewMatrix(int, int, ::kaldi::MatrixStrideType)")},
  {C("new_sub_matrix"), (PyCFunction)wrapNewSubMatrix_as_new_sub_matrix, METH_VARARGS | METH_KEYWORDS, C("new_sub_matrix(base_submatrix:int, row_offset:int, num_rows:int, col_offset:int, num_cols:int) -> int\n  Calls C++ function\n  int ::kaldi::nnet3::NnetComputation::NewSubMatrix(int, int, int, int, int)")},
  {C("is_whole_matrix"), (PyCFunction)wrapIsWholeMatrix_as_is_whole_matrix, METH_VARARGS | METH_KEYWORDS, C("is_whole_matrix(submatrix_index:int) -> bool\n  Calls C++ function\n  bool ::kaldi::nnet3::NnetComputation::IsWholeMatrix(int)")},
  {C("compute_cuda_indexes"), (PyCFunction)wrapComputeCudaIndexes_as_compute_cuda_indexes, METH_NOARGS, C("compute_cuda_indexes()\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::ComputeCudaIndexes()")},
  {C("print_computation"), (PyCFunction)wrapPrint_as_print_computation, METH_VARARGS | METH_KEYWORDS, C("print_computation(os:ostream, nnet:Nnet)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Print(::std::basic_ostream<char, ::std::char_traits<char> >, ::kaldi::nnet3::Nnet)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("get_submatrix_strings"), (PyCFunction)wrapGetSubmatrixStrings_as_get_submatrix_strings, METH_VARARGS | METH_KEYWORDS, C("get_submatrix_strings(nnet:Nnet) -> list<str>\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::GetSubmatrixStrings(::kaldi::nnet3::Nnet, ::std::vector< ::std::string>*)")},
  {C("get_whole_submatrices"), (PyCFunction)wrapGetWholeSubmatrices_as_get_whole_submatrices, METH_NOARGS, C("get_whole_submatrices() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::GetWholeSubmatrices(::std::vector< ::int32>*)")},
  {C("get_command_strings"), (PyCFunction)wrapGetCommandStrings_as_get_command_strings, METH_VARARGS | METH_KEYWORDS, C("get_command_strings(nnet:Nnet) -> (preamble:str, command_strings:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::GetCommandStrings(::kaldi::nnet3::Nnet, ::std::string*, ::std::vector< ::std::string>*)")},
  {C("clear"), (PyCFunction)wrapClear_as_clear, METH_NOARGS, C("clear()\n  Calls C++ function\n  void ::kaldi::nnet3::NnetComputation::Clear()")},
  {C("from_other"), (PyCFunction)wrapNnetComputation_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:NnetComputation) -> NnetComputation\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::NnetComputation> ::kaldi::nnet3::NnetComputation::NnetComputation(::kaldi::nnet3::NnetComputation)")},
  {}
};

// NnetComputation __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// NnetComputation __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// NnetComputation __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_computation.NnetComputation", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::NnetComputation", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "NnetComputation takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::NnetComputation* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_NnetComputation"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::NnetComputation"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::NnetComputation* c = static_cast<::kaldi::nnet3::NnetComputation*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::NnetComputation*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyNnetComputation


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyIoSpecification::wrapper_Type) < 0) return false;
  Py_INCREF(&pyIoSpecification::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyComputationRequest::wrapper_Type) < 0) return false;
  Py_INCREF(&pyComputationRequest::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::pyMatrixInfo::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::pyMatrixInfo::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::pyMatrixDebugInfo::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::pyMatrixDebugInfo::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::pySubMatrixInfo::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::pySubMatrixInfo::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::pyCommand::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::pyCommand::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyNnetComputation::wrapper_Type) < 0) return false;
  Py_INCREF(&pyNnetComputation::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_nnet_computation",  // module name
  "CLIF-generated module for nnet3/nnet-computation.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrixdim")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_array")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_misc_computation_info")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_nnet")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyDict_SetItemString(pyNnetComputation::wrapper_Type.tp_dict, "MatrixInfo", reinterpret_cast<PyObject*>(&pyNnetComputation::pyMatrixInfo::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyNnetComputation::wrapper_Type.tp_dict, "MatrixDebugInfo", reinterpret_cast<PyObject*>(&pyNnetComputation::pyMatrixDebugInfo::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyNnetComputation::wrapper_Type.tp_dict, "SubMatrixInfo", reinterpret_cast<PyObject*>(&pyNnetComputation::pySubMatrixInfo::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyNnetComputation::wrapper_Type.tp_dict, "Command", reinterpret_cast<PyObject*>(&pyNnetComputation::pyCommand::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyNnetComputation::wrapper_Type.tp_dict, "PrecomputedIndexesInfo", reinterpret_cast<PyObject*>(&pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "IoSpecification", reinterpret_cast<PyObject*>(&pyIoSpecification::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ComputationRequest", reinterpret_cast<PyObject*>(&pyComputationRequest::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CommandType", (_CommandType=wrapCommandType())) < 0) goto err;
  if (PyModule_AddObject(module, "NnetComputation", reinterpret_cast<PyObject*>(&pyNnetComputation::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __nnet__computation_clifwrap

namespace kaldi { namespace nnet3 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CommandType:IntEnum to/from enum ::kaldi::nnet3::CommandType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::CommandType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __nnet__computation_clifwrap::_CommandType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum CommandType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::nnet3::CommandType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::nnet3::CommandType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::CommandType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__nnet__computation_clifwrap::_CommandType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::nnet3::CommandType>::type>(c)), nullptr);
}

// ComputationRequest to/from ::kaldi::nnet3::ComputationRequest conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ComputationRequest** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ComputationRequest* cpp = __nnet__computation_clifwrap::pyComputationRequest::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ComputationRequest>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ComputationRequest* cpp = __nnet__computation_clifwrap::pyComputationRequest::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ComputationRequest>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ComputationRequest* cpp = __nnet__computation_clifwrap::pyComputationRequest::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ComputationRequest instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ComputationRequest* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ComputationRequest* cpp = __nnet__computation_clifwrap::pyComputationRequest::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::ComputationRequest>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ComputationRequest* cpp = __nnet__computation_clifwrap::pyComputationRequest::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ComputationRequest* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyComputationRequest::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ComputationRequest>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ComputationRequest> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyComputationRequest::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ComputationRequest>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ComputationRequest> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyComputationRequest::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ComputationRequest>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::ComputationRequest& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyComputationRequest::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyComputationRequest::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::ComputationRequest>(c);
  return py;
}

// IoSpecification to/from ::kaldi::nnet3::IoSpecification conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::IoSpecification** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::IoSpecification* cpp = __nnet__computation_clifwrap::pyIoSpecification::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::IoSpecification>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::IoSpecification* cpp = __nnet__computation_clifwrap::pyIoSpecification::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::IoSpecification>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::IoSpecification* cpp = __nnet__computation_clifwrap::pyIoSpecification::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert IoSpecification instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::IoSpecification* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::IoSpecification* cpp = __nnet__computation_clifwrap::pyIoSpecification::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::IoSpecification>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::IoSpecification* cpp = __nnet__computation_clifwrap::pyIoSpecification::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::IoSpecification* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyIoSpecification::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::IoSpecification>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::IoSpecification> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyIoSpecification::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::IoSpecification>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::IoSpecification> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyIoSpecification::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::IoSpecification>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::IoSpecification& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyIoSpecification::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyIoSpecification::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::IoSpecification>(c);
  return py;
}

// NnetComputation to/from ::kaldi::nnet3::NnetComputation conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation* cpp = __nnet__computation_clifwrap::pyNnetComputation::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation* cpp = __nnet__computation_clifwrap::pyNnetComputation::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation* cpp = __nnet__computation_clifwrap::pyNnetComputation::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation* cpp = __nnet__computation_clifwrap::pyNnetComputation::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation* cpp = __nnet__computation_clifwrap::pyNnetComputation::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation>(c);
  return py;
}

// NnetComputation.Command to/from ::kaldi::nnet3::NnetComputation::Command conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::Command** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation::Command* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyCommand::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation::Command>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::Command* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyCommand::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation::Command>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::Command* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyCommand::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation.Command instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::Command* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::Command* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyCommand::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation::Command>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::Command* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyCommand::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation::Command* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::Command>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation::Command> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::Command>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation::Command> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::Command>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation::Command& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyCommand::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::Command>(c);
  return py;
}

// NnetComputation.MatrixDebugInfo to/from ::kaldi::nnet3::NnetComputation::MatrixDebugInfo conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::MatrixDebugInfo** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation.MatrixDebugInfo instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixDebugInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation::MatrixDebugInfo* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation::MatrixDebugInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixDebugInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation::MatrixDebugInfo& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixDebugInfo::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::MatrixDebugInfo>(c);
  return py;
}

// NnetComputation.MatrixInfo to/from ::kaldi::nnet3::NnetComputation::MatrixInfo conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::MatrixInfo** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation::MatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation.MatrixInfo instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::MatrixInfo* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation::MatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::MatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation::MatrixInfo* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixInfo>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixInfo>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation::MatrixInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::MatrixInfo>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation::MatrixInfo& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyMatrixInfo::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::MatrixInfo>(c);
  return py;
}

// NnetComputation.PrecomputedIndexesInfo to/from ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation.PrecomputedIndexesInfo instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pyPrecomputedIndexesInfo::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::PrecomputedIndexesInfo>(c);
  return py;
}

// NnetComputation.SubMatrixInfo to/from ::kaldi::nnet3::NnetComputation::SubMatrixInfo conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::SubMatrixInfo** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert NnetComputation.SubMatrixInfo instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::NnetComputation::SubMatrixInfo* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::NnetComputation::SubMatrixInfo>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::NnetComputation::SubMatrixInfo* cpp = __nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::NnetComputation::SubMatrixInfo* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::SubMatrixInfo>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::SubMatrixInfo>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::NnetComputation::SubMatrixInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::NnetComputation::SubMatrixInfo>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::NnetComputation::SubMatrixInfo& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__computation_clifwrap::pyNnetComputation::pySubMatrixInfo::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::NnetComputation::SubMatrixInfo>(c);
  return py;
}

} }  // namespace kaldi::nnet3
