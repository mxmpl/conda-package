//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/nnet3/nnet-descriptor.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "nnet3/nnet-common-clifwrap.h"
#include "nnet-descriptor-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __nnet__descriptor_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


namespace pyForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::ForwardingDescriptor* ThisPtr(PyObject*);

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::ForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::ForwardingDescriptor::Copy()")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ForwardingDescriptor::Modulus()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::ForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::ForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::ForwardingDescriptor::GetScaleForNode(int)")},
  {}
};

// ForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.ForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ForwardingDescriptor* c = static_cast<::kaldi::nnet3::ForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyForwardingDescriptor

namespace pySimpleForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SimpleForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::SimpleForwardingDescriptor* ThisPtr(PyObject*);

// __init__(src_node:int, scale:float=default)
static PyObject* wrapSimpleForwardingDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("src_node"),
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:__init__", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)1.000000e+00;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SimpleForwardingDescriptor>(std::move(arg1)); break;
  case 2:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SimpleForwardingDescriptor>(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::ForwardingDescriptor*
static PyObject* as_kaldi_nnet3_ForwardingDescriptor(PyObject* self) {
  ::kaldi::nnet3::ForwardingDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::ForwardingDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSimpleForwardingDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src_node:int, scale:float=default)\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleForwardingDescriptor::SimpleForwardingDescriptor(int, float)")},
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::SimpleForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::SimpleForwardingDescriptor::Copy()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::SimpleForwardingDescriptor::GetScaleForNode(int)")},
  {C("as_kaldi_nnet3_ForwardingDescriptor"), (PyCFunction)as_kaldi_nnet3_ForwardingDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::ForwardingDescriptor*")},
  {}
};

// SimpleForwardingDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SimpleForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SimpleForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.SimpleForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SimpleForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSimpleForwardingDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SimpleForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SimpleForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SimpleForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SimpleForwardingDescriptor* c = static_cast<::kaldi::nnet3::SimpleForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SimpleForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySimpleForwardingDescriptor

namespace pyOffsetForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::OffsetForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::OffsetForwardingDescriptor* ThisPtr(PyObject*);

// __init__(src:ForwardingDescriptor, offset:Index)
static PyObject* wrapOffsetForwardingDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("offset"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::ForwardingDescriptor * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::ForwardingDescriptor *", a[0]);
  ::kaldi::nnet3::Index* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::nnet3::Index", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::OffsetForwardingDescriptor>(arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::OffsetForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::ForwardingDescriptor*
static PyObject* as_kaldi_nnet3_ForwardingDescriptor(PyObject* self) {
  ::kaldi::nnet3::ForwardingDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::ForwardingDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapOffsetForwardingDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:ForwardingDescriptor, offset:Index)\n  Calls C++ function\n  void ::kaldi::nnet3::OffsetForwardingDescriptor::OffsetForwardingDescriptor(::kaldi::nnet3::ForwardingDescriptor *, ::kaldi::nnet3::Index)")},
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::OffsetForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::OffsetForwardingDescriptor::Copy()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::OffsetForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::OffsetForwardingDescriptor::Modulus()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::OffsetForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::OffsetForwardingDescriptor::GetScaleForNode(int)")},
  {C("as_kaldi_nnet3_ForwardingDescriptor"), (PyCFunction)as_kaldi_nnet3_ForwardingDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::ForwardingDescriptor*")},
  {}
};

// OffsetForwardingDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OffsetForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OffsetForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.OffsetForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::OffsetForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapOffsetForwardingDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::OffsetForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_OffsetForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::OffsetForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::OffsetForwardingDescriptor* c = static_cast<::kaldi::nnet3::OffsetForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::OffsetForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOffsetForwardingDescriptor

namespace pySwitchingForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SwitchingForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::SwitchingForwardingDescriptor* ThisPtr(PyObject*);

// __init__(src:list<ForwardingDescriptor>)
static PyObject* wrapSwitchingForwardingDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::nnet3::ForwardingDescriptor *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::std::vector< ::kaldi::nnet3::ForwardingDescriptor *>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SwitchingForwardingDescriptor>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SwitchingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::ForwardingDescriptor*
static PyObject* as_kaldi_nnet3_ForwardingDescriptor(PyObject* self) {
  ::kaldi::nnet3::ForwardingDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::ForwardingDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSwitchingForwardingDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:list<ForwardingDescriptor>)\n  Calls C++ function\n  void ::kaldi::nnet3::SwitchingForwardingDescriptor::SwitchingForwardingDescriptor(::std::vector< ::kaldi::nnet3::ForwardingDescriptor *>)")},
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::SwitchingForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::SwitchingForwardingDescriptor::Copy()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::SwitchingForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SwitchingForwardingDescriptor::Modulus()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::SwitchingForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::SwitchingForwardingDescriptor::GetScaleForNode(int)")},
  {C("as_kaldi_nnet3_ForwardingDescriptor"), (PyCFunction)as_kaldi_nnet3_ForwardingDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::ForwardingDescriptor*")},
  {}
};

// SwitchingForwardingDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SwitchingForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SwitchingForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.SwitchingForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SwitchingForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSwitchingForwardingDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SwitchingForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SwitchingForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SwitchingForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SwitchingForwardingDescriptor* c = static_cast<::kaldi::nnet3::SwitchingForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SwitchingForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySwitchingForwardingDescriptor

namespace pyRoundingForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::RoundingForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::RoundingForwardingDescriptor* ThisPtr(PyObject*);

// __init__(src:ForwardingDescriptor, t_modulus:int)
static PyObject* wrapRoundingForwardingDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("t_modulus"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  ::kaldi::nnet3::ForwardingDescriptor * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::ForwardingDescriptor *", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::RoundingForwardingDescriptor>(arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::RoundingForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::ForwardingDescriptor*
static PyObject* as_kaldi_nnet3_ForwardingDescriptor(PyObject* self) {
  ::kaldi::nnet3::ForwardingDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::ForwardingDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapRoundingForwardingDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:ForwardingDescriptor, t_modulus:int)\n  Calls C++ function\n  void ::kaldi::nnet3::RoundingForwardingDescriptor::RoundingForwardingDescriptor(::kaldi::nnet3::ForwardingDescriptor *, int)")},
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::RoundingForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::RoundingForwardingDescriptor::Copy()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::RoundingForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::RoundingForwardingDescriptor::Modulus()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::RoundingForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::RoundingForwardingDescriptor::GetScaleForNode(int)")},
  {C("as_kaldi_nnet3_ForwardingDescriptor"), (PyCFunction)as_kaldi_nnet3_ForwardingDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::ForwardingDescriptor*")},
  {}
};

// RoundingForwardingDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RoundingForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RoundingForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.RoundingForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::RoundingForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapRoundingForwardingDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::RoundingForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_RoundingForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::RoundingForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::RoundingForwardingDescriptor* c = static_cast<::kaldi::nnet3::RoundingForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::RoundingForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRoundingForwardingDescriptor

namespace pyReplaceIndexForwardingDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ReplaceIndexForwardingDescriptor> cpp;
};
static ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* ThisPtr(PyObject*);

// Create Python Enum object (cached in _VariableName) for ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName
static PyObject* wrapVariableName() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("N"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>::type>(::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName::kN)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("T"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>::type>(::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName::kT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("X"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>::type>(::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName::kX)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("ReplaceIndexForwardingDescriptor.VariableName");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _VariableName{};  // set by above func in Init()

// __init__(src:ForwardingDescriptor, variable_name:VariableName, value:int)
static PyObject* wrapReplaceIndexForwardingDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("src"),
      C("variable_name"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:__init__", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::ForwardingDescriptor * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::ForwardingDescriptor *", a[0]);
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "int", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>(arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// map_to_input(output:Index) -> tuple<int, Index>
static PyObject* wrapMapToInput_as_map_to_input(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:map_to_input", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("map_to_input", names[0], "::kaldi::nnet3::Index", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Cindex ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MapToInput(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> ForwardingDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::ForwardingDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::nnet3::ForwardingDescriptor*
static PyObject* as_kaldi_nnet3_ForwardingDescriptor(PyObject* self) {
  ::kaldi::nnet3::ForwardingDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::ForwardingDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapReplaceIndexForwardingDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:ForwardingDescriptor, variable_name:VariableName, value:int)\n  Calls C++ function\n  void ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::ReplaceIndexForwardingDescriptor(::kaldi::nnet3::ForwardingDescriptor *, ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName, int)")},
  {C("map_to_input"), (PyCFunction)wrapMapToInput_as_map_to_input, METH_VARARGS | METH_KEYWORDS, C("map_to_input(output:Index) -> tuple<int, Index>\n  Calls C++ function\n  ::kaldi::nnet3::Cindex ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::MapToInput(::kaldi::nnet3::Index)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> ForwardingDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::ForwardingDescriptor * ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::Copy()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ForwardingDescriptor::Modulus()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::GetScaleForNode(int)")},
  {C("as_kaldi_nnet3_ForwardingDescriptor"), (PyCFunction)as_kaldi_nnet3_ForwardingDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::ForwardingDescriptor*")},
  {}
};

// ReplaceIndexForwardingDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ReplaceIndexForwardingDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ReplaceIndexForwardingDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.ReplaceIndexForwardingDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ReplaceIndexForwardingDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapReplaceIndexForwardingDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ReplaceIndexForwardingDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ReplaceIndexForwardingDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c = static_cast<::kaldi::nnet3::ReplaceIndexForwardingDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ReplaceIndexForwardingDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyReplaceIndexForwardingDescriptor

namespace pySumDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SumDescriptor> cpp;
};
static ::kaldi::nnet3::SumDescriptor* ThisPtr(PyObject*);

// get_dependencies(ind:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ind"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(ind:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::SumDescriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {}
};

// SumDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SumDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.SumDescriptor",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SumDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SumDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SumDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SumDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SumDescriptor* c = static_cast<::kaldi::nnet3::SumDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SumDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySumDescriptor

namespace pyOptionalSumDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::OptionalSumDescriptor> cpp;
};
static ::kaldi::nnet3::OptionalSumDescriptor* ThisPtr(PyObject*);

// __init__(src:SumDescriptor)
static PyObject* wrapOptionalSumDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::SumDescriptor * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::SumDescriptor *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::OptionalSumDescriptor>(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_dependencies(ind:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ind"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> SumDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::SumDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::OptionalSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::SumDescriptor*
static PyObject* as_kaldi_nnet3_SumDescriptor(PyObject* self) {
  ::kaldi::nnet3::SumDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::SumDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapOptionalSumDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:SumDescriptor)\n  Calls C++ function\n  void ::kaldi::nnet3::OptionalSumDescriptor::OptionalSumDescriptor(::kaldi::nnet3::SumDescriptor *)")},
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(ind:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::OptionalSumDescriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> SumDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::SumDescriptor * ::kaldi::nnet3::OptionalSumDescriptor::Copy()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::OptionalSumDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::OptionalSumDescriptor::GetScaleForNode(int)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::OptionalSumDescriptor::Modulus()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::OptionalSumDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("as_kaldi_nnet3_SumDescriptor"), (PyCFunction)as_kaldi_nnet3_SumDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::SumDescriptor*")},
  {}
};

// OptionalSumDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OptionalSumDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OptionalSumDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.OptionalSumDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::OptionalSumDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapOptionalSumDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::OptionalSumDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_OptionalSumDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::OptionalSumDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::OptionalSumDescriptor* c = static_cast<::kaldi::nnet3::OptionalSumDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::OptionalSumDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOptionalSumDescriptor

namespace pySimpleSumDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::SimpleSumDescriptor> cpp;
};
static ::kaldi::nnet3::SimpleSumDescriptor* ThisPtr(PyObject*);

// __init__(src:ForwardingDescriptor)
static PyObject* wrapSimpleSumDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::kaldi::nnet3::ForwardingDescriptor * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::ForwardingDescriptor *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::SimpleSumDescriptor>(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_dependencies(ind:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ind"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> SumDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::SumDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::SimpleSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::SumDescriptor*
static PyObject* as_kaldi_nnet3_SumDescriptor(PyObject* self) {
  ::kaldi::nnet3::SumDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::SumDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapSimpleSumDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(src:ForwardingDescriptor)\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleSumDescriptor::SimpleSumDescriptor(::kaldi::nnet3::ForwardingDescriptor *)")},
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(ind:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleSumDescriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> SumDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::SumDescriptor * ::kaldi::nnet3::SimpleSumDescriptor::Copy()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleSumDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::SimpleSumDescriptor::GetScaleForNode(int)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::SimpleSumDescriptor::Modulus()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::SimpleSumDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("as_kaldi_nnet3_SumDescriptor"), (PyCFunction)as_kaldi_nnet3_SumDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::SumDescriptor*")},
  {}
};

// SimpleSumDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// SimpleSumDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// SimpleSumDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.SimpleSumDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::SimpleSumDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapSimpleSumDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::SimpleSumDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_SimpleSumDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::SimpleSumDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::SimpleSumDescriptor* c = static_cast<::kaldi::nnet3::SimpleSumDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::SimpleSumDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pySimpleSumDescriptor

namespace pyConstantSumDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::ConstantSumDescriptor> cpp;
};
static ::kaldi::nnet3::ConstantSumDescriptor* ThisPtr(PyObject*);

// __init__(value:float, dim:int)
static PyObject* wrapConstantSumDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "float", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::ConstantSumDescriptor>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_dependencies(ind:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ind"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> SumDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::SumDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::ConstantSumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::SumDescriptor*
static PyObject* as_kaldi_nnet3_SumDescriptor(PyObject* self) {
  ::kaldi::nnet3::SumDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::SumDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapConstantSumDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(value:float, dim:int)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantSumDescriptor::ConstantSumDescriptor(float, int)")},
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(ind:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantSumDescriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> SumDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::SumDescriptor * ::kaldi::nnet3::ConstantSumDescriptor::Copy()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantSumDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::ConstantSumDescriptor::GetScaleForNode(int)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::ConstantSumDescriptor::Modulus()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::ConstantSumDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("as_kaldi_nnet3_SumDescriptor"), (PyCFunction)as_kaldi_nnet3_SumDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::SumDescriptor*")},
  {}
};

// ConstantSumDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// ConstantSumDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// ConstantSumDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.ConstantSumDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::ConstantSumDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapConstantSumDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::ConstantSumDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_ConstantSumDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::ConstantSumDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::ConstantSumDescriptor* c = static_cast<::kaldi::nnet3::ConstantSumDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::ConstantSumDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyConstantSumDescriptor

namespace pyBinarySumDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::BinarySumDescriptor> cpp;
};
static ::kaldi::nnet3::BinarySumDescriptor* ThisPtr(PyObject*);

// Create Python Enum object (cached in _Operation) for ::kaldi::nnet3::BinarySumDescriptor::Operation
static PyObject* wrapOperation() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SUM_OPERATION"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::BinarySumDescriptor::Operation>::type>(::kaldi::nnet3::BinarySumDescriptor::Operation::kSumOperation)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("FAILOVER_OPERATION"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::BinarySumDescriptor::Operation>::type>(::kaldi::nnet3::BinarySumDescriptor::Operation::kFailoverOperation)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("BinarySumDescriptor.Operation");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _Operation{};  // set by above func in Init()

// __init__(op:Operation, src1:SumDescriptor, src2:SumDescriptor)
static PyObject* wrapBinarySumDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("op"),
      C("src1"),
      C("src2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:__init__", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::nnet3::BinarySumDescriptor::Operation arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::BinarySumDescriptor::Operation", a[0]);
  ::kaldi::nnet3::SumDescriptor * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::nnet3::SumDescriptor *", a[1]);
  ::kaldi::nnet3::SumDescriptor * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "::kaldi::nnet3::SumDescriptor *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::BinarySumDescriptor>(std::move(arg1), arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_dependencies(ind:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ind"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy() -> SumDescriptor
static PyObject* wrapCopy_as_copy(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::SumDescriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Copy();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_scale_for_node(node_index:int) -> float
static PyObject* wrapGetScaleForNode_as_get_scale_for_node(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("node_index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_scale_for_node", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_scale_for_node", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetScaleForNode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::BinarySumDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::nnet3::SumDescriptor*
static PyObject* as_kaldi_nnet3_SumDescriptor(PyObject* self) {
  ::kaldi::nnet3::SumDescriptor* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::nnet3::SumDescriptor"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapBinarySumDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(op:Operation, src1:SumDescriptor, src2:SumDescriptor)\n  Calls C++ function\n  void ::kaldi::nnet3::BinarySumDescriptor::BinarySumDescriptor(::kaldi::nnet3::BinarySumDescriptor::Operation, ::kaldi::nnet3::SumDescriptor *, ::kaldi::nnet3::SumDescriptor *)")},
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(ind:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::BinarySumDescriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {C("copy"), (PyCFunction)wrapCopy_as_copy, METH_NOARGS, C("copy() -> SumDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::SumDescriptor * ::kaldi::nnet3::BinarySumDescriptor::Copy()")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::BinarySumDescriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("get_scale_for_node"), (PyCFunction)wrapGetScaleForNode_as_get_scale_for_node, METH_VARARGS | METH_KEYWORDS, C("get_scale_for_node(node_index:int) -> float\n  Calls C++ function\n  float ::kaldi::nnet3::BinarySumDescriptor::GetScaleForNode(int)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::BinarySumDescriptor::Modulus()")},
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::BinarySumDescriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("as_kaldi_nnet3_SumDescriptor"), (PyCFunction)as_kaldi_nnet3_SumDescriptor, METH_NOARGS, C("Upcast to ::kaldi::nnet3::SumDescriptor*")},
  {}
};

// BinarySumDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// BinarySumDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// BinarySumDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.BinarySumDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::BinarySumDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapBinarySumDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::BinarySumDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_BinarySumDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::BinarySumDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::BinarySumDescriptor* c = static_cast<::kaldi::nnet3::BinarySumDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::BinarySumDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyBinarySumDescriptor

namespace pyDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::Descriptor> cpp;
};
static ::kaldi::nnet3::Descriptor* ThisPtr(PyObject*);

// write_config(os:ostream, node_names:list<str>)
static PyObject* wrapWriteConfig_as_write_config(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("node_names"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_config", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_config", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::string> arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_config", names[1], "::std::vector< ::std::string>", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::Descriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->WriteConfig(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_dependencies(index:Index) -> list<tuple<int, Index>>
static PyObject* wrapGetDependencies_as_get_dependencies(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_dependencies", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Index* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_dependencies", names[0], "::kaldi::nnet3::Index", a[0]);
  ::std::vector< ::kaldi::nnet3::Cindex> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::Descriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetDependencies(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_node_dependencies() -> list<int>
static PyObject* wrapGetNodeDependencies_as_get_node_dependencies(PyObject* self) {
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  ::kaldi::nnet3::Descriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GetNodeDependencies(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// modulus() -> int
static PyObject* wrapModulus_as_modulus(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::Descriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Modulus();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_parts() -> int
static PyObject* wrapNumParts_as_num_parts(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::Descriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumParts();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(other:Descriptor) -> Descriptor
static PyObject* wrapDescriptor_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::nnet3::Descriptor* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::nnet3::Descriptor", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::Descriptor> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::Descriptor>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_parts(parts:list<SumDescriptor>) -> Descriptor
static PyObject* wrapDescriptor_as_from_parts(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("parts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_parts", names, &a[0])) return nullptr;
  ::std::vector< ::kaldi::nnet3::SumDescriptor *> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_parts", names[0], "::std::vector< ::kaldi::nnet3::SumDescriptor *>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::nnet3::Descriptor> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::nnet3::Descriptor>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("write_config"), (PyCFunction)wrapWriteConfig_as_write_config, METH_VARARGS | METH_KEYWORDS, C("write_config(os:ostream, node_names:list<str>)\n  Calls C++ function\n  void ::kaldi::nnet3::Descriptor::WriteConfig(::std::basic_ostream<char, ::std::char_traits<char> >, ::std::vector< ::std::string>)")},
  {C("get_dependencies"), (PyCFunction)wrapGetDependencies_as_get_dependencies, METH_VARARGS | METH_KEYWORDS, C("get_dependencies(index:Index) -> list<tuple<int, Index>>\n  Calls C++ function\n  void ::kaldi::nnet3::Descriptor::GetDependencies(::kaldi::nnet3::Index, ::std::vector< ::kaldi::nnet3::Cindex>*)")},
  {C("get_node_dependencies"), (PyCFunction)wrapGetNodeDependencies_as_get_node_dependencies, METH_NOARGS, C("get_node_dependencies() -> list<int>\n  Calls C++ function\n  void ::kaldi::nnet3::Descriptor::GetNodeDependencies(::std::vector< ::int32>*)")},
  {C("modulus"), (PyCFunction)wrapModulus_as_modulus, METH_NOARGS, C("modulus() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::Descriptor::Modulus()")},
  {C("num_parts"), (PyCFunction)wrapNumParts_as_num_parts, METH_NOARGS, C("num_parts() -> int\n  Calls C++ function\n  int ::kaldi::nnet3::Descriptor::NumParts()")},
  {C("from_other"), (PyCFunction)wrapDescriptor_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:Descriptor) -> Descriptor\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::Descriptor> ::kaldi::nnet3::Descriptor::Descriptor(::kaldi::nnet3::Descriptor)")},
  {C("from_parts"), (PyCFunction)wrapDescriptor_as_from_parts, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_parts(parts:list<SumDescriptor>) -> Descriptor\n  Calls C++ function\n  std::unique_ptr<::kaldi::nnet3::Descriptor> ::kaldi::nnet3::Descriptor::Descriptor(::std::vector< ::kaldi::nnet3::SumDescriptor *>)")},
  {}
};

// Descriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Descriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Descriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.Descriptor",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::Descriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Descriptor takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::Descriptor>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::Descriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_Descriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::Descriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::Descriptor* c = static_cast<::kaldi::nnet3::Descriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::Descriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDescriptor

namespace pyGeneralDescriptor {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::nnet3::GeneralDescriptor> cpp;
};
static ::kaldi::nnet3::GeneralDescriptor* ThisPtr(PyObject*);

// Create Python Enum object (cached in _DescriptorType) for ::kaldi::nnet3::GeneralDescriptor::DescriptorType
static PyObject* wrapDescriptorType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(11);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("APPEND"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kAppend)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SUM"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kSum)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("FAILOVER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kFailover)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("IF_DEFINED"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kIfDefined)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("OFFSET"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kOffset)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SWITCH"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kSwitch)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ROUND"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kRound)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 6, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REPLACE_INDEX"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kReplaceIndex)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 7, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NODE_NAME"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kNodeName)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 8, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("kConst"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kConst)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 9, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("kScale"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(::kaldi::nnet3::GeneralDescriptor::DescriptorType::kScale)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 10, py);
  py = PyUnicode_FromString("GeneralDescriptor.DescriptorType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _DescriptorType{};  // set by above func in Init()

// __init__(t:DescriptorType, value1:int=default, value2:int=default)
static PyObject* wrapGeneralDescriptor_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("t"),
      C("value1"),
      C("value2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|OO:__init__", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::nnet3::GeneralDescriptor::DescriptorType arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::nnet3::GeneralDescriptor::DescriptorType", a[0]);
  int arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (int)-1;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  }
  int arg3;
  if (nargs > 2) {
    if (!a[2]) arg3 = (int)-1;
    else if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "int", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::GeneralDescriptor>(std::move(arg1)); break;
  case 2:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::GeneralDescriptor>(std::move(arg1), std::move(arg2)); break;
  case 3:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::nnet3::GeneralDescriptor>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// get_normalized_descriptor() -> GeneralDescriptor
static PyObject* wrapGetNormalizedDescriptor_as_get_normalized_descriptor(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::GeneralDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::kaldi::nnet3::GeneralDescriptor *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetNormalizedDescriptor();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// convert_to_descriptor() -> Descriptor
static PyObject* wrapConvertToDescriptor_as_convert_to_descriptor(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::nnet3::GeneralDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::kaldi::nnet3::Descriptor * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ConvertToDescriptor();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// print_descriptor(node_names:list<str>, os:ostream)
static PyObject* wrapPrint_as_print_descriptor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("node_names"),
      C("os"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:print_descriptor", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::std::string> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("print_descriptor", names[0], "::std::vector< ::std::string>", a[0]);
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("print_descriptor", names[1], "::std::basic_ostream<char, ::std::char_traits<char> >", a[1]);
  // Call actual C++ method.
  ::kaldi::nnet3::GeneralDescriptor* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Print(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapGeneralDescriptor_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(t:DescriptorType, value1:int=default, value2:int=default)\n  Calls C++ function\n  void ::kaldi::nnet3::GeneralDescriptor::GeneralDescriptor(::kaldi::nnet3::GeneralDescriptor::DescriptorType, int, int)")},
  {C("get_normalized_descriptor"), (PyCFunction)wrapGetNormalizedDescriptor_as_get_normalized_descriptor, METH_NOARGS, C("get_normalized_descriptor() -> GeneralDescriptor\n  Calls C++ function\n  ::kaldi::nnet3::GeneralDescriptor * ::kaldi::nnet3::GeneralDescriptor::GetNormalizedDescriptor()")},
  {C("convert_to_descriptor"), (PyCFunction)wrapConvertToDescriptor_as_convert_to_descriptor, METH_NOARGS, C("convert_to_descriptor() -> Descriptor\n  Calls C++ function\n  ::kaldi::nnet3::Descriptor * ::kaldi::nnet3::GeneralDescriptor::ConvertToDescriptor()")},
  {C("print_descriptor"), (PyCFunction)wrapPrint_as_print_descriptor, METH_VARARGS | METH_KEYWORDS, C("print_descriptor(node_names:list<str>, os:ostream)\n  Calls C++ function\n  void ::kaldi::nnet3::GeneralDescriptor::Print(::std::vector< ::std::string>, ::std::basic_ostream<char, ::std::char_traits<char> >)")},
  {}
};

// GeneralDescriptor __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// GeneralDescriptor __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// GeneralDescriptor __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_nnet_descriptor.GeneralDescriptor", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::nnet3::GeneralDescriptor", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapGeneralDescriptor_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::nnet3::GeneralDescriptor* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_nnet3_GeneralDescriptor"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::nnet3::GeneralDescriptor"));
      if (!PyErr_Occurred()) {
        ::kaldi::nnet3::GeneralDescriptor* c = static_cast<::kaldi::nnet3::GeneralDescriptor*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::nnet3::GeneralDescriptor*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyGeneralDescriptor


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pySimpleForwardingDescriptor::wrapper_Type.tp_base = &pyForwardingDescriptor::wrapper_Type;
  if (PyType_Ready(&pySimpleForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pySimpleForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyOffsetForwardingDescriptor::wrapper_Type.tp_base = &pyForwardingDescriptor::wrapper_Type;
  if (PyType_Ready(&pyOffsetForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOffsetForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pySwitchingForwardingDescriptor::wrapper_Type.tp_base = &pyForwardingDescriptor::wrapper_Type;
  if (PyType_Ready(&pySwitchingForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pySwitchingForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyRoundingForwardingDescriptor::wrapper_Type.tp_base = &pyForwardingDescriptor::wrapper_Type;
  if (PyType_Ready(&pyRoundingForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRoundingForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyReplaceIndexForwardingDescriptor::wrapper_Type.tp_base = &pyForwardingDescriptor::wrapper_Type;
  if (PyType_Ready(&pyReplaceIndexForwardingDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyReplaceIndexForwardingDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pySumDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pySumDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyOptionalSumDescriptor::wrapper_Type.tp_base = &pySumDescriptor::wrapper_Type;
  if (PyType_Ready(&pyOptionalSumDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOptionalSumDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pySimpleSumDescriptor::wrapper_Type.tp_base = &pySumDescriptor::wrapper_Type;
  if (PyType_Ready(&pySimpleSumDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pySimpleSumDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyConstantSumDescriptor::wrapper_Type.tp_base = &pySumDescriptor::wrapper_Type;
  if (PyType_Ready(&pyConstantSumDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyConstantSumDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  pyBinarySumDescriptor::wrapper_Type.tp_base = &pySumDescriptor::wrapper_Type;
  if (PyType_Ready(&pyBinarySumDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyBinarySumDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyGeneralDescriptor::wrapper_Type) < 0) return false;
  Py_INCREF(&pyGeneralDescriptor::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_nnet_descriptor",  // module name
  "CLIF-generated module for nnet3/nnet-descriptor.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_common")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyDict_SetItemString(pyReplaceIndexForwardingDescriptor::wrapper_Type.tp_dict, "VariableName", (pyReplaceIndexForwardingDescriptor::_VariableName=pyReplaceIndexForwardingDescriptor::wrapVariableName())) < 0) goto err;
  if (PyDict_SetItemString(pyBinarySumDescriptor::wrapper_Type.tp_dict, "Operation", (pyBinarySumDescriptor::_Operation=pyBinarySumDescriptor::wrapOperation())) < 0) goto err;
  if (PyDict_SetItemString(pyGeneralDescriptor::wrapper_Type.tp_dict, "DescriptorType", (pyGeneralDescriptor::_DescriptorType=pyGeneralDescriptor::wrapDescriptorType())) < 0) goto err;
  if (PyModule_AddObject(module, "ForwardingDescriptor", reinterpret_cast<PyObject*>(&pyForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SimpleForwardingDescriptor", reinterpret_cast<PyObject*>(&pySimpleForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OffsetForwardingDescriptor", reinterpret_cast<PyObject*>(&pyOffsetForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SwitchingForwardingDescriptor", reinterpret_cast<PyObject*>(&pySwitchingForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RoundingForwardingDescriptor", reinterpret_cast<PyObject*>(&pyRoundingForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ReplaceIndexForwardingDescriptor", reinterpret_cast<PyObject*>(&pyReplaceIndexForwardingDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SumDescriptor", reinterpret_cast<PyObject*>(&pySumDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OptionalSumDescriptor", reinterpret_cast<PyObject*>(&pyOptionalSumDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "SimpleSumDescriptor", reinterpret_cast<PyObject*>(&pySimpleSumDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ConstantSumDescriptor", reinterpret_cast<PyObject*>(&pyConstantSumDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "BinarySumDescriptor", reinterpret_cast<PyObject*>(&pyBinarySumDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Descriptor", reinterpret_cast<PyObject*>(&pyDescriptor::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "GeneralDescriptor", reinterpret_cast<PyObject*>(&pyGeneralDescriptor::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __nnet__descriptor_clifwrap

namespace kaldi { namespace nnet3 {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// BinarySumDescriptor to/from ::kaldi::nnet3::BinarySumDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::BinarySumDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::BinarySumDescriptor* cpp = __nnet__descriptor_clifwrap::pyBinarySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::BinarySumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BinarySumDescriptor* cpp = __nnet__descriptor_clifwrap::pyBinarySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::BinarySumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BinarySumDescriptor* cpp = __nnet__descriptor_clifwrap::pyBinarySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert BinarySumDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::BinarySumDescriptor* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BinarySumDescriptor* cpp = __nnet__descriptor_clifwrap::pyBinarySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::BinarySumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::BinarySumDescriptor* cpp = __nnet__descriptor_clifwrap::pyBinarySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::BinarySumDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BinarySumDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::BinarySumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BinarySumDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::BinarySumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::BinarySumDescriptor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::BinarySumDescriptor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyBinarySumDescriptor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::BinarySumDescriptor>(c);
  return py;
}

// BinarySumDescriptor.Operation:IntEnum to/from enum ::kaldi::nnet3::BinarySumDescriptor::Operation conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::BinarySumDescriptor::Operation* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __nnet__descriptor_clifwrap::pyBinarySumDescriptor::_Operation)) {
    PyErr_Format(PyExc_TypeError, "expecting enum BinarySumDescriptor.Operation, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::nnet3::BinarySumDescriptor::Operation>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::nnet3::BinarySumDescriptor::Operation>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::BinarySumDescriptor::Operation& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__nnet__descriptor_clifwrap::pyBinarySumDescriptor::_Operation, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::nnet3::BinarySumDescriptor::Operation>::type>(c)), nullptr);
}

// ConstantSumDescriptor to/from ::kaldi::nnet3::ConstantSumDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ConstantSumDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ConstantSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyConstantSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ConstantSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyConstantSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ConstantSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyConstantSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ConstantSumDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ConstantSumDescriptor* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyConstantSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::ConstantSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ConstantSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyConstantSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ConstantSumDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantSumDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ConstantSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantSumDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ConstantSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ConstantSumDescriptor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::ConstantSumDescriptor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyConstantSumDescriptor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::ConstantSumDescriptor>(c);
  return py;
}

// Descriptor to/from ::kaldi::nnet3::Descriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::Descriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::Descriptor* cpp = __nnet__descriptor_clifwrap::pyDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::Descriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::Descriptor* cpp = __nnet__descriptor_clifwrap::pyDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::Descriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::Descriptor* cpp = __nnet__descriptor_clifwrap::pyDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Descriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::Descriptor* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::Descriptor* cpp = __nnet__descriptor_clifwrap::pyDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::Descriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::Descriptor* cpp = __nnet__descriptor_clifwrap::pyDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::Descriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::Descriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::Descriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::Descriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::Descriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::Descriptor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::Descriptor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyDescriptor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::Descriptor>(c);
  return py;
}

// ForwardingDescriptor to/from ::kaldi::nnet3::ForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ForwardingDescriptor>(std::move(c));
  return py;
}

// GeneralDescriptor to/from ::kaldi::nnet3::GeneralDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::GeneralDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::GeneralDescriptor* cpp = __nnet__descriptor_clifwrap::pyGeneralDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::GeneralDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::GeneralDescriptor* cpp = __nnet__descriptor_clifwrap::pyGeneralDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::GeneralDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::GeneralDescriptor* cpp = __nnet__descriptor_clifwrap::pyGeneralDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert GeneralDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::GeneralDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::GeneralDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::GeneralDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::GeneralDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::GeneralDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyGeneralDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::GeneralDescriptor>(std::move(c));
  return py;
}

// GeneralDescriptor.DescriptorType:IntEnum to/from enum ::kaldi::nnet3::GeneralDescriptor::DescriptorType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::GeneralDescriptor::DescriptorType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __nnet__descriptor_clifwrap::pyGeneralDescriptor::_DescriptorType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum GeneralDescriptor.DescriptorType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::nnet3::GeneralDescriptor::DescriptorType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::GeneralDescriptor::DescriptorType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__nnet__descriptor_clifwrap::pyGeneralDescriptor::_DescriptorType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::nnet3::GeneralDescriptor::DescriptorType>::type>(c)), nullptr);
}

// OffsetForwardingDescriptor to/from ::kaldi::nnet3::OffsetForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::OffsetForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::OffsetForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::OffsetForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OffsetForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::OffsetForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OffsetForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OffsetForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::OffsetForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OffsetForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::OffsetForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OffsetForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::OffsetForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOffsetForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OffsetForwardingDescriptor>(std::move(c));
  return py;
}

// OptionalSumDescriptor to/from ::kaldi::nnet3::OptionalSumDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::OptionalSumDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::OptionalSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyOptionalSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::OptionalSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OptionalSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyOptionalSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::OptionalSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OptionalSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyOptionalSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OptionalSumDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::OptionalSumDescriptor* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OptionalSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyOptionalSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::OptionalSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::OptionalSumDescriptor* cpp = __nnet__descriptor_clifwrap::pyOptionalSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::OptionalSumDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OptionalSumDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::OptionalSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OptionalSumDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::OptionalSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::OptionalSumDescriptor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::OptionalSumDescriptor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyOptionalSumDescriptor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::OptionalSumDescriptor>(c);
  return py;
}

// ReplaceIndexForwardingDescriptor to/from ::kaldi::nnet3::ReplaceIndexForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ReplaceIndexForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::ReplaceIndexForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert ReplaceIndexForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::ReplaceIndexForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::ReplaceIndexForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::ReplaceIndexForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::ReplaceIndexForwardingDescriptor>(std::move(c));
  return py;
}

// ReplaceIndexForwardingDescriptor.VariableName:IntEnum to/from enum ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::_VariableName)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ReplaceIndexForwardingDescriptor.VariableName, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__nnet__descriptor_clifwrap::pyReplaceIndexForwardingDescriptor::_VariableName, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::nnet3::ReplaceIndexForwardingDescriptor::VariableName>::type>(c)), nullptr);
}

// RoundingForwardingDescriptor to/from ::kaldi::nnet3::RoundingForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::RoundingForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::RoundingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::RoundingForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RoundingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::RoundingForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::RoundingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RoundingForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::RoundingForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RoundingForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::RoundingForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RoundingForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::RoundingForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pyRoundingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::RoundingForwardingDescriptor>(std::move(c));
  return py;
}

// SimpleForwardingDescriptor to/from ::kaldi::nnet3::SimpleForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SimpleForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SimpleForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SimpleForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SimpleForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SimpleForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SimpleForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SimpleForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SimpleForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleForwardingDescriptor>(std::move(c));
  return py;
}

// SimpleSumDescriptor to/from ::kaldi::nnet3::SimpleSumDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SimpleSumDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SimpleSumDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SimpleSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleSumDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SimpleSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleSumDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SimpleSumDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SimpleSumDescriptor* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleSumDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::nnet3::SimpleSumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SimpleSumDescriptor* cpp = __nnet__descriptor_clifwrap::pySimpleSumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SimpleSumDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleSumDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SimpleSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleSumDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SimpleSumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SimpleSumDescriptor>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::nnet3::SimpleSumDescriptor& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySimpleSumDescriptor::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::nnet3::SimpleSumDescriptor>(c);
  return py;
}

// SumDescriptor to/from ::kaldi::nnet3::SumDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SumDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SumDescriptor* cpp = __nnet__descriptor_clifwrap::pySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumDescriptor* cpp = __nnet__descriptor_clifwrap::pySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pySumDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SumDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SumDescriptor* cpp = __nnet__descriptor_clifwrap::pySumDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pySumDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SumDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SumDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SumDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySumDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySumDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SumDescriptor>(std::move(c));
  return py;
}

// SwitchingForwardingDescriptor to/from ::kaldi::nnet3::SwitchingForwardingDescriptor conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::nnet3::SwitchingForwardingDescriptor** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::nnet3::SwitchingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::nnet3::SwitchingForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SwitchingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::nnet3::SwitchingForwardingDescriptor>* c) {
  assert(c != nullptr);
  ::kaldi::nnet3::SwitchingForwardingDescriptor* cpp = __nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert SwitchingForwardingDescriptor instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::nnet3::SwitchingForwardingDescriptor* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SwitchingForwardingDescriptor>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::nnet3::SwitchingForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SwitchingForwardingDescriptor>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::nnet3::SwitchingForwardingDescriptor> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper_Type, NULL, NULL);
  reinterpret_cast<__nnet__descriptor_clifwrap::pySwitchingForwardingDescriptor::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::nnet3::SwitchingForwardingDescriptor>(std::move(c));
  return py;
}

} }  // namespace kaldi::nnet3
