//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/context-fst-inl.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "fstext/context-fst.h"
#include "context-fst-inl-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __context__fst__inl_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// write_ilabel_info(os:ostream, binary:bool, info:list<list<int>>)
static PyObject* wrapWriteILabelInfo_as_write_ilabel_info(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("binary"),
      C("info"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write_ilabel_info", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_ilabel_info", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_ilabel_info", names[1], "bool", a[1]);
  ::std::vector< ::std::vector<int> > arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write_ilabel_info", names[2], "::std::vector< ::std::vector<int> >", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::WriteILabelInfo(*arg1, std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read_ilabel_info(is:istream, binary:bool) -> list<list<int>>
static PyObject* wrapReadILabelInfo_as_read_ilabel_info(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_ilabel_info", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_ilabel_info", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_ilabel_info", names[1], "bool", a[1]);
  ::std::vector< ::std::vector<int> > ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::fst::ReadILabelInfo(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// create_ilabel_info_symbol_table(info:list<list<int>>, phones_symtab:SymbolTable, separator:str, disambig_prefix:str) -> SymbolTable
static PyObject* wrapCreateILabelInfoSymbolTable_as_create_ilabel_info_symbol_table(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("info"),
      C("phones_symtab"),
      C("separator"),
      C("disambig_prefix"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:create_ilabel_info_symbol_table", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::std::vector< ::std::vector<int> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("create_ilabel_info_symbol_table", names[0], "::std::vector< ::std::vector<int> >", a[0]);
  ::fst::SymbolTable* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("create_ilabel_info_symbol_table", names[1], "::fst::SymbolTable", a[1]);
  ::std::string arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("create_ilabel_info_symbol_table", names[2], "::std::string", a[2]);
  ::std::string arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("create_ilabel_info_symbol_table", names[3], "::std::string", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::CreateILabelInfoSymbolTable(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("write_ilabel_info"), (PyCFunction)wrapWriteILabelInfo_as_write_ilabel_info, METH_VARARGS | METH_KEYWORDS, C("write_ilabel_info(os:ostream, binary:bool, info:list<list<int>>)\n\nWrites ilabel info to output stream.")},
  {C("read_ilabel_info"), (PyCFunction)wrapReadILabelInfo_as_read_ilabel_info, METH_VARARGS | METH_KEYWORDS, C("read_ilabel_info(is:istream, binary:bool) -> list<list<int>>\n\nReads ilabel info from input stream.")},
  {C("create_ilabel_info_symbol_table"), (PyCFunction)wrapCreateILabelInfoSymbolTable_as_create_ilabel_info_symbol_table, METH_VARARGS | METH_KEYWORDS, C("create_ilabel_info_symbol_table(info:list<list<int>>, phones_symtab:SymbolTable, separator:str, disambig_prefix:str) -> SymbolTable\n\nCreates a symbol table from the ilabel info and phones symbol table.\n\nThis is mainly used for debugging.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_context_fst_inl",  // module name
  "CLIF-generated module for fstext/context-fst-inl.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __context__fst__inl_clifwrap
