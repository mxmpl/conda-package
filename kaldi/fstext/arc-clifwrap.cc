//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/arc.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/float-weight-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/lexicographic-weight-clifwrap.h"
#include "arc-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __arc_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyStdArc {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >> cpp;
};
static ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:TropicalWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nextstate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->nextstate, {});
}

static int set_nextstate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nextstate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nextstate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nextstate:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_attrs(ilabel:int, olabel:int, weight:TropicalWeight, nextstate:int) -> StdArc
static PyObject* wrapArcTpl_as_from_attrs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("ilabel"),
      C("olabel"),
      C("weight"),
      C("nextstate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:from_attrs", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_attrs", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_attrs", names[1], "int", a[1]);
  ::fst::TropicalWeightTpl<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_attrs", names[2], "::fst::TropicalWeightTpl<float>", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_attrs", names[3], "int", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>(std::move(arg1), std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod type() -> str
static PyObject* wrapType_as_type(PyObject* cls) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::ArcTpl<fst::TropicalWeightTpl<float> >::Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("int: The input label.")},
  {C("olabel"), get_olabel, set_olabel, C("int: The output label.")},
  {C("weight"), get_weight, set_weight, C("TropicalWeight: The arc weight.")},
  {C("nextstate"), get_nextstate, set_nextstate, C("int: The destination state for the arc.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_attrs"), (PyCFunction)wrapArcTpl_as_from_attrs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_attrs(ilabel:int, olabel:int, weight:TropicalWeight, nextstate:int) -> StdArc\n\nCreates a new arc with the given attributes.\n\nArgs:\n    ilabel (int): The input label.\n    olabel (int): The output label.\n    weight (TropicalWeight): The arc weight.\n    nextstate (int): The destination state for the arc.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS | METH_CLASS, C("type() -> str\n\nReturns arc type.")},
  {}
};

// StdArc __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdArc __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdArc __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_arc.StdArc",                       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "FST Arc with tropical weight.\n\nAttributes of the arc can be accessed and mutated.\n\nStdArc():\n  Creates an uninitialized StdArc.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "StdArc takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >"));
      if (!PyErr_Occurred()) {
        ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* c = static_cast<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdArc

namespace pyLogArc {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ArcTpl< ::fst::LogWeightTpl<float> >> cpp;
};
static ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:LogWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nextstate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->nextstate, {});
}

static int set_nextstate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nextstate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nextstate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nextstate:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_attrs(ilabel:int, olabel:int, weight:LogWeight, nextstate:int) -> LogArc
static PyObject* wrapArcTpl_as_from_attrs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("ilabel"),
      C("olabel"),
      C("weight"),
      C("nextstate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:from_attrs", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_attrs", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_attrs", names[1], "int", a[1]);
  ::fst::LogWeightTpl<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_attrs", names[2], "::fst::LogWeightTpl<float>", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_attrs", names[3], "int", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::ArcTpl< ::fst::LogWeightTpl<float> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>(std::move(arg1), std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod type() -> str
static PyObject* wrapType_as_type(PyObject* cls) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::ArcTpl<fst::LogWeightTpl<float> >::Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("int: The input label.")},
  {C("olabel"), get_olabel, set_olabel, C("int: The output label.")},
  {C("weight"), get_weight, set_weight, C("LogWeight: The arc weight.")},
  {C("nextstate"), get_nextstate, set_nextstate, C("int: The destination state for the arc.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_attrs"), (PyCFunction)wrapArcTpl_as_from_attrs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_attrs(ilabel:int, olabel:int, weight:LogWeight, nextstate:int) -> LogArc\n\nCreates a new arc with the given attributes.\n\nArgs:\n    ilabel (int): The input label.\n    olabel (int): The output label.\n    weight (LogWeight): The arc weight.\n    nextstate (int): The destination state for the arc.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS | METH_CLASS, C("type() -> str\n\nReturns arc type.")},
  {}
};

// LogArc __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LogArc __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LogArc __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_arc.LogArc",                       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "FST Arc with log weight.\n\nAttributes of the arc can be accessed and mutated.\n\nLogArc():\n  Creates an uninitialized LogArc.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LogArc takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ArcTpl__fst_LogWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ArcTpl< ::fst::LogWeightTpl<float> >"));
      if (!PyErr_Occurred()) {
        ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* c = static_cast<::fst::ArcTpl< ::fst::LogWeightTpl<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ArcTpl< ::fst::LogWeightTpl<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLogArc

namespace pyLatticeArc {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >> cpp;
};
static ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:LatticeWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nextstate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->nextstate, {});
}

static int set_nextstate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nextstate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nextstate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nextstate:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_attrs(ilabel:int, olabel:int, weight:LatticeWeight, nextstate:int) -> LatticeArc
static PyObject* wrapArcTpl_as_from_attrs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("ilabel"),
      C("olabel"),
      C("weight"),
      C("nextstate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:from_attrs", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_attrs", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_attrs", names[1], "int", a[1]);
  ::fst::LatticeWeightTpl<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_attrs", names[2], "::fst::LatticeWeightTpl<float>", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_attrs", names[3], "int", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>(std::move(arg1), std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod type() -> str
static PyObject* wrapType_as_type(PyObject* cls) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::ArcTpl<fst::LatticeWeightTpl<float> >::Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("int: The input label.")},
  {C("olabel"), get_olabel, set_olabel, C("int: The output label.")},
  {C("weight"), get_weight, set_weight, C("LatticeWeight: The arc weight.")},
  {C("nextstate"), get_nextstate, set_nextstate, C("int: The destination state for the arc.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_attrs"), (PyCFunction)wrapArcTpl_as_from_attrs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_attrs(ilabel:int, olabel:int, weight:LatticeWeight, nextstate:int) -> LatticeArc\n\nCreates a new arc with the given attributes.\n\nArgs:\n    ilabel (int): The input label.\n    olabel (int): The output label.\n    weight (LatticeWeight): The arc weight.\n    nextstate (int): The destination state for the arc.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS | METH_CLASS, C("type() -> str\n\nReturns arc type.")},
  {}
};

// LatticeArc __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LatticeArc __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LatticeArc __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_arc.LatticeArc",                   // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "FST Arc with lattice weight.\n\nAttributes of the arc can be accessed and mutated.\n\nLatticeArc():\n  Creates an uninitialized LatticeArc.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LatticeArc takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ArcTpl__fst_LatticeWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >"));
      if (!PyErr_Occurred()) {
        ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* c = static_cast<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLatticeArc

namespace pyCompactLatticeArc {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >> cpp;
};
static ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:CompactLatticeWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nextstate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->nextstate, {});
}

static int set_nextstate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nextstate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nextstate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nextstate:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_attrs(ilabel:int, olabel:int, weight:CompactLatticeWeight, nextstate:int) -> CompactLatticeArc
static PyObject* wrapArcTpl_as_from_attrs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("ilabel"),
      C("olabel"),
      C("weight"),
      C("nextstate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:from_attrs", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_attrs", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_attrs", names[1], "int", a[1]);
  ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_attrs", names[2], "::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int>", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_attrs", names[3], "int", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>(std::move(arg1), std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod type() -> str
static PyObject* wrapType_as_type(PyObject* cls) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int> >::Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("int: The input label.")},
  {C("olabel"), get_olabel, set_olabel, C("int: The output label.")},
  {C("weight"), get_weight, set_weight, C("CompactLatticeWeight: The arc weight.")},
  {C("nextstate"), get_nextstate, set_nextstate, C("int: The destination state for the arc.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_attrs"), (PyCFunction)wrapArcTpl_as_from_attrs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_attrs(ilabel:int, olabel:int, weight:CompactLatticeWeight, nextstate:int) -> CompactLatticeArc\n\nCreates a new arc with the given attributes.\n\nArgs:\n    ilabel (int): The input label.\n    olabel (int): The output label.\n    weight (CompactLatticeWeight): The arc weight.\n    nextstate (int): The destination state for the arc.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS | METH_CLASS, C("type() -> str\n\nReturns arc type.")},
  {}
};

// CompactLatticeArc __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompactLatticeArc __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompactLatticeArc __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_arc.CompactLatticeArc",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "FST Arc with compact lattice weight.\n\nAttributes of the arc can be accessed and mutated.\n\nCompactLatticeArc():\n  Creates an uninitialized CompactLatticeArc.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CompactLatticeArc takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ArcTpl__fst_CompactLatticeWeightTpl__fst_LatticeWeightTpl_float__int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >"));
      if (!PyErr_Occurred()) {
        ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* c = static_cast<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompactLatticeArc

namespace pyKwsIndexArc {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >> cpp;
};
static ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:KwsIndexWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_nextstate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->nextstate, {});
}

static int set_nextstate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the nextstate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->nextstate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for nextstate:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// @classmethod from_attrs(ilabel:int, olabel:int, weight:KwsIndexWeight, nextstate:int) -> KwsIndexArc
static PyObject* wrapArcTpl_as_from_attrs(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("ilabel"),
      C("olabel"),
      C("weight"),
      C("nextstate"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:from_attrs", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_attrs", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_attrs", names[1], "int", a[1]);
  ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > >* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_attrs", names[2], "::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > >", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_attrs", names[3], "int", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>(std::move(arg1), std::move(arg2), *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod type() -> str
static PyObject* wrapType_as_type(PyObject* cls) {
  // Call actual C++ method.
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::std::string ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::ArcTpl<fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::TropicalWeightTpl<float> > > >::Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), _1);
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("int: The input label.")},
  {C("olabel"), get_olabel, set_olabel, C("int: The output label.")},
  {C("weight"), get_weight, set_weight, C("TropicalWeight: The arc weight.")},
  {C("nextstate"), get_nextstate, set_nextstate, C("int: The destination state for the arc.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("from_attrs"), (PyCFunction)wrapArcTpl_as_from_attrs, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_attrs(ilabel:int, olabel:int, weight:KwsIndexWeight, nextstate:int) -> KwsIndexArc\n\nCreates a new arc with the given attributes.\n\nArgs:\n    ilabel (int): The input label.\n    olabel (int): The output label.\n    weight (KwsIndexWeight): The arc weight.\n    nextstate (int): The destination state for the arc.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS | METH_CLASS, C("type() -> str\n\nReturns arc type.")},
  {}
};

// KwsIndexArc __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// KwsIndexArc __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// KwsIndexArc __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_arc.KwsIndexArc",                  // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "FST Arc with KWS index weight.\n\nAttributes of the arc can be accessed and mutated.\n\nKwsIndexArc():\n  Creates an uninitialized KwsIndexArc.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "KwsIndexArc takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ArcTpl__fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >"));
      if (!PyErr_Occurred()) {
        ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* c = static_cast<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyKwsIndexArc


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyStdArc::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdArc::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLogArc::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLogArc::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLatticeArc::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLatticeArc::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompactLatticeArc::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompactLatticeArc::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyKwsIndexArc::wrapper_Type) < 0) return false;
  Py_INCREF(&pyKwsIndexArc::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_arc",  // module name
  "CLIF-generated module for fst/arc.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_float_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lexicographic_weight")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "StdArc", reinterpret_cast<PyObject*>(&pyStdArc::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LogArc", reinterpret_cast<PyObject*>(&pyLogArc::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LatticeArc", reinterpret_cast<PyObject*>(&pyLatticeArc::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompactLatticeArc", reinterpret_cast<PyObject*>(&pyCompactLatticeArc::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "KwsIndexArc", reinterpret_cast<PyObject*>(&pyKwsIndexArc::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __arc_clifwrap

namespace fst {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CompactLatticeArc to/from ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* cpp = __arc_clifwrap::pyCompactLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* cpp = __arc_clifwrap::pyCompactLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* cpp = __arc_clifwrap::pyCompactLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompactLatticeArc instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* cpp = __arc_clifwrap::pyCompactLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* cpp = __arc_clifwrap::pyCompactLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyCompactLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyCompactLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyCompactLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyCompactLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyCompactLatticeArc::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >>(c);
  return py;
}

// KwsIndexArc to/from ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* cpp = __arc_clifwrap::pyKwsIndexArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* cpp = __arc_clifwrap::pyKwsIndexArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* cpp = __arc_clifwrap::pyKwsIndexArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert KwsIndexArc instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* cpp = __arc_clifwrap::pyKwsIndexArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* cpp = __arc_clifwrap::pyKwsIndexArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyKwsIndexArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyKwsIndexArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyKwsIndexArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyKwsIndexArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyKwsIndexArc::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >>(c);
  return py;
}

// LatticeArc to/from ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* cpp = __arc_clifwrap::pyLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* cpp = __arc_clifwrap::pyLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* cpp = __arc_clifwrap::pyLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LatticeArc instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* cpp = __arc_clifwrap::pyLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* cpp = __arc_clifwrap::pyLatticeArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLatticeArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLatticeArc::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >>(c);
  return py;
}

// LogArc to/from ::fst::ArcTpl< ::fst::LogWeightTpl<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LogWeightTpl<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* cpp = __arc_clifwrap::pyLogArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* cpp = __arc_clifwrap::pyLogArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* cpp = __arc_clifwrap::pyLogArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LogArc instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* cpp = __arc_clifwrap::pyLogArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* cpp = __arc_clifwrap::pyLogArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ArcTpl< ::fst::LogWeightTpl<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLogArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ArcTpl< ::fst::LogWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLogArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ArcTpl< ::fst::LogWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLogArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ArcTpl< ::fst::LogWeightTpl<float> >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyLogArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyLogArc::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::LogWeightTpl<float> >>(c);
  return py;
}

// StdArc to/from ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* cpp = __arc_clifwrap::pyStdArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* cpp = __arc_clifwrap::pyStdArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* cpp = __arc_clifwrap::pyStdArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdArc instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* cpp = __arc_clifwrap::pyStdArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>* c) {
  assert(c != nullptr);
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* cpp = __arc_clifwrap::pyStdArc::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyStdArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyStdArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyStdArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp = ::clif::Instance<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__arc_clifwrap::pyStdArc::wrapper_Type, NULL, NULL);
  reinterpret_cast<__arc_clifwrap::pyStdArc::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >>(c);
  return py;
}

}  // namespace fst
