//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/push-special.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "push-special-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __push__special_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// push_special(fst:StdVectorFst, delta:float=default)
static PyObject* wrapPushSpecial_as_push_special(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("fst"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:push_special", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("push_special", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >, ::std::allocator< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > > > *", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!a[1]) arg2 = (float)9.765625e-04;
    else if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("push_special", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ::fst::PushSpecial(arg1); break;
  case 2:
    ::fst::PushSpecial(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("push_special"), (PyCFunction)wrapPushSpecial_as_push_special, METH_VARARGS | METH_KEYWORDS, C("push_special(fst:StdVectorFst, delta:float=default)\n\nPushes weights in log semiring in a special way.\n\nDestructively pushes weights in the log semiring such that any leftover\nweight after pushing gets distributed evenly along the FST, and doesn't\nend up either at the start or at the end.  Basically it pushes the\nweights such that the total weight of each state (i.e. the sum of the arc\nprobabilities plus the final-prob) is the same for all states.\n\nArgs:\n    fst (StdFst): Input fst over the tropical semiring.\n    delta: Comparison/quantization delta (default: 0.0009765625).")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_push_special",  // module name
  "CLIF-generated module for fstext/push-special.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __push__special_clifwrap
