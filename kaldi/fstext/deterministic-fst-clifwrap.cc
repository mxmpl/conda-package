//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/deterministic-fst.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/float-weight-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/arc-clifwrap.h"
#include "fstext/fst-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "deterministic-fst-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __deterministic__fst_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyStdDeterministicOnDemandFst {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// start() -> int
static PyObject* wrapStart_as_start(PyObject* self) {
  // Call actual C++ method.
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Start();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// final(state:int) -> TropicalWeight
static PyObject* wrapFinal_as_final(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("state"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:final", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("final", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::TropicalWeightTpl<float> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Final(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_arc(s:int, ilabel:int) -> (success:bool, oarc:StdArc)
static PyObject* wrapGetArc_as_get_arc(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("s"),
      C("ilabel"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_arc", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_arc", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_arc", names[1], "int", a[1]);
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > ret1{};
  // Call actual C++ method.
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetArc(std::move(arg1), std::move(arg2), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

static PyMethodDef Methods[] = {
  {C("start"), (PyCFunction)wrapStart_as_start, METH_NOARGS, C("start() -> int\n\nReturns the start state index.")},
  {C("final"), (PyCFunction)wrapFinal_as_final, METH_VARARGS | METH_KEYWORDS, C("final(state:int) -> TropicalWeight\n\nReturns the final weight of the given state.")},
  {C("get_arc"), (PyCFunction)wrapGetArc_as_get_arc, METH_VARARGS | METH_KEYWORDS, C("get_arc(s:int, ilabel:int) -> (success:bool, oarc:StdArc)\n\nCreates an on demand arc and returns it.\n\nArgs:\n  s (int): State index.\n  ilabel (int): Arc label.\n\nReturns:\n  The created arc.")},
  {}
};

// StdDeterministicOnDemandFst __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdDeterministicOnDemandFst __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_deterministic_fst.StdDeterministicOnDemandFst", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IS_ABSTRACT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Base class for deterministic on demand FSTs over the tropical semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdDeterministicOnDemandFst

namespace pyStdBackoffDeterministicOnDemandFst {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(fst_:StdFst)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("fst_"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*
static PyObject* as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float(PyObject* self) {
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(fst_:StdFst)\n  Calls C++ function\n  void ::fst::BackoffDeterministicOnDemandFst<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::BackoffDeterministicOnDemandFst(::fst::Fst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >)")},
  {C("as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), (PyCFunction)as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float, METH_NOARGS, C("Upcast to ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*")},
  {}
};

// StdBackoffDeterministicOnDemandFst __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdBackoffDeterministicOnDemandFst __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdBackoffDeterministicOnDemandFst __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_deterministic_fst.StdBackoffDeterministicOnDemandFst", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Deterministic on demand backoff language model.\n\nThis class wraps a conventional Fst, representing a language model, with\na \"DeterministicOnDemandFst\" interface. Backoff arcs in the language\nmodel should have the epsilon label (label 0) on the arcs, and that there\nshould be no other epsilons in the language model. The backoff (i.e.\nepsilon) arcs are followed if a particular arc (or a final-prob) is not\nfound at the current state.\n\nArgs:\n  fst (StdFst): Input language model FST.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_BackoffDeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdBackoffDeterministicOnDemandFst

namespace pyStdUnweightedNgramFst {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(n:int)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("n"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*
static PyObject* as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float(PyObject* self) {
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(n:int)\n  Calls C++ function\n  void ::fst::UnweightedNgramFst<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::UnweightedNgramFst(int)")},
  {C("as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), (PyCFunction)as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float, METH_NOARGS, C("Upcast to ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*")},
  {}
};

// StdUnweightedNgramFst __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdUnweightedNgramFst __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdUnweightedNgramFst __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_deterministic_fst.StdUnweightedNgramFst", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "A DeterministicOnDemandFst in which states encode an n-gram history.\n\nConceptually, for n-gram order n and k labels, the FST is an unweighted\nacceptor with about k^(n-1) states (ignoring end effects). However, the\nFST is created on demand and doesn't need the label vocabulary; get_arc\nmatches on any input label. This class is primarily used by\n`compose_deterministic_on_demand_fst` to expand the n-gram history of\nlattices.\n\nArgs:\n  n (int): N-gram order.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_UnweightedNgramFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdUnweightedNgramFst

namespace pyStdComposeDeterministicOnDemandFst {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(fst1:StdDeterministicOnDemandFst, fst2:StdDeterministicOnDemandFst)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("fst1"),
      C("fst2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(arg1, arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*
static PyObject* as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float(PyObject* self) {
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(fst1:StdDeterministicOnDemandFst, fst2:StdDeterministicOnDemandFst)\n  Calls C++ function\n  void ::fst::ComposeDeterministicOnDemandFst<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::ComposeDeterministicOnDemandFst(::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *)")},
  {C("as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), (PyCFunction)as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float, METH_NOARGS, C("Upcast to ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*")},
  {}
};

// StdComposeDeterministicOnDemandFst __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdComposeDeterministicOnDemandFst __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdComposeDeterministicOnDemandFst __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_deterministic_fst.StdComposeDeterministicOnDemandFst", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "A DeterministicOnDemandFst implementing the composition of others.\n\nArgs:\n  fst1 (StdFst): The first deterministic on demand FST.\n  fst2 (StdFst): The second deterministic on demand FST.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_ComposeDeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdComposeDeterministicOnDemandFst

namespace pyStdCacheDeterministicOnDemandFst {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(fst:StdDeterministicOnDemandFst, num_cached_arcs:int=default)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("fst"),
      C("num_cached_arcs"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:__init__", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *", a[0]);
  int arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(arg1); break;
  case 2:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*
static PyObject* as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float(PyObject* self) {
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(fst:StdDeterministicOnDemandFst, num_cached_arcs:int=default)\n  Calls C++ function\n  void ::fst::CacheDeterministicOnDemandFst<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::CacheDeterministicOnDemandFst(::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *, int)")},
  {C("as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), (PyCFunction)as_fst_DeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float, METH_NOARGS, C("Upcast to ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*")},
  {}
};

// StdCacheDeterministicOnDemandFst __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdCacheDeterministicOnDemandFst __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdCacheDeterministicOnDemandFst __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_deterministic_fst.StdCacheDeterministicOnDemandFst", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "A DeterministicOnDemandFst caching the arcs of another.\n\nArgs:\n  fst (StdFst): The input deterministic on demand FST.\n  num_cached_arcs (int): Number of arcs to keep in the cache.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_CacheDeterministicOnDemandFst__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdCacheDeterministicOnDemandFst


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyStdDeterministicOnDemandFst::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdDeterministicOnDemandFst::wrapper_Type);  // For PyModule_AddObject to steal.
  pyStdBackoffDeterministicOnDemandFst::wrapper_Type.tp_base = &pyStdDeterministicOnDemandFst::wrapper_Type;
  if (PyType_Ready(&pyStdBackoffDeterministicOnDemandFst::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdBackoffDeterministicOnDemandFst::wrapper_Type);  // For PyModule_AddObject to steal.
  pyStdUnweightedNgramFst::wrapper_Type.tp_base = &pyStdDeterministicOnDemandFst::wrapper_Type;
  if (PyType_Ready(&pyStdUnweightedNgramFst::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdUnweightedNgramFst::wrapper_Type);  // For PyModule_AddObject to steal.
  pyStdComposeDeterministicOnDemandFst::wrapper_Type.tp_base = &pyStdDeterministicOnDemandFst::wrapper_Type;
  if (PyType_Ready(&pyStdComposeDeterministicOnDemandFst::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdComposeDeterministicOnDemandFst::wrapper_Type);  // For PyModule_AddObject to steal.
  pyStdCacheDeterministicOnDemandFst::wrapper_Type.tp_base = &pyStdDeterministicOnDemandFst::wrapper_Type;
  if (PyType_Ready(&pyStdCacheDeterministicOnDemandFst::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdCacheDeterministicOnDemandFst::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_deterministic_fst",  // module name
  "CLIF-generated module for fstext/deterministic-fst.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_float_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_arc")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "StdDeterministicOnDemandFst", reinterpret_cast<PyObject*>(&pyStdDeterministicOnDemandFst::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "StdBackoffDeterministicOnDemandFst", reinterpret_cast<PyObject*>(&pyStdBackoffDeterministicOnDemandFst::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "StdUnweightedNgramFst", reinterpret_cast<PyObject*>(&pyStdUnweightedNgramFst::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "StdComposeDeterministicOnDemandFst", reinterpret_cast<PyObject*>(&pyStdComposeDeterministicOnDemandFst::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "StdCacheDeterministicOnDemandFst", reinterpret_cast<PyObject*>(&pyStdCacheDeterministicOnDemandFst::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __deterministic__fst_clifwrap

namespace fst {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// StdBackoffDeterministicOnDemandFst to/from ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdBackoffDeterministicOnDemandFst instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdBackoffDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::BackoffDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

// StdCacheDeterministicOnDemandFst to/from ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdCacheDeterministicOnDemandFst instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c) {
  assert(c != nullptr);
  ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdCacheDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::CacheDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

// StdComposeDeterministicOnDemandFst to/from ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdComposeDeterministicOnDemandFst instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c) {
  assert(c != nullptr);
  ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdComposeDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::ComposeDeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

// StdDeterministicOnDemandFst to/from ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdDeterministicOnDemandFst instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdDeterministicOnDemandFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::DeterministicOnDemandFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

// StdUnweightedNgramFst to/from ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdUnweightedNgramFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdUnweightedNgramFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdUnweightedNgramFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdUnweightedNgramFst instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c) {
  assert(c != nullptr);
  ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdUnweightedNgramFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __deterministic__fst_clifwrap::pyStdUnweightedNgramFst::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp = ::clif::Instance<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper_Type, NULL, NULL);
  reinterpret_cast<__deterministic__fst_clifwrap::pyStdUnweightedNgramFst::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::UnweightedNgramFst< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

}  // namespace fst
