//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/rnnlm/rnnlm-example.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "itf/options-itf-clifwrap.h"
#include "cudamatrix/cu-vector-clifwrap.h"
#include "rnnlm/sampling-lm-clifwrap.h"
#include "rnnlm-example-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __rnnlm__example_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyRnnlmExample {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::RnnlmExample> cpp;
};
static ::kaldi::rnnlm::RnnlmExample* ThisPtr(PyObject*);

static PyObject* get_vocab_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->vocab_size, {});
}

static int set_vocab_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the vocab_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->vocab_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for vocab_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_chunks(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_chunks, {});
}

static int set_num_chunks(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_chunks attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_chunks)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_chunks:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_chunk_length(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->chunk_length, {});
}

static int set_chunk_length(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the chunk_length attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->chunk_length)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for chunk_length:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_sample_group_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->sample_group_size, {});
}

static int set_sample_group_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the sample_group_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->sample_group_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for sample_group_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_samples(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_samples, {});
}

static int set_num_samples(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_samples attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_samples)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_samples:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_input_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->input_words, {});
}

static int set_input_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the input_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->input_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for input_words:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_output_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->output_words, {});
}

static int set_output_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the output_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->output_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for output_words:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_output_weights(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->output_weights), {});
}

static int set_output_weights(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the output_weights attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->output_weights)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for output_weights:CuVector", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_sampled_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->sampled_words, {});
}

static int set_sampled_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the sampled_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->sampled_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for sampled_words:list<int>", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_sample_inv_probs(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->sample_inv_probs), {});
}

static int set_sample_inv_probs(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the sample_inv_probs attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->sample_inv_probs)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for sample_inv_probs:CuVector", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// swap(other:RnnlmExample)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::RnnlmExample * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::rnnlm::RnnlmExample *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExample* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExample* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExample* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("vocab_size"), get_vocab_size, set_vocab_size, C("The vocabulary size.\n\nThe vocabulary size (defined as largest integer word-id plus one) for\nwhich this example was obtained; mostly used in bounds checking.")},
  {C("num_chunks"), get_num_chunks, set_num_chunks, C("The number of parallel word sequences/chunks.\n\nSome of the word sequences may actually be made up of smaller\nsubsequences appended together.")},
  {C("chunk_length"), get_chunk_length, set_chunk_length, C("The length of each sequence in a minibatch.\n\nThe length of each sequence in a minibatch, including any terminating\n</s> symbols, which are included explicitly in the sequences. When </s>\nappears in the middle of sequences because we splice shorter word\nsequences together, we will replace it with <s> on the input side of the\nnetwork. Sentences, or pieces of sentences, that were shorter than\n`chunk_length`, will be padded as needed.")},
  {C("sample_group_size"), get_sample_group_size, set_sample_group_size, C("The sampling group size.\n\nThis is the number of consecutive time-steps which form a single unit for\nsampling purposes.  This number will always divide `chunk_length`.\nExample: if `sample_group_size==2`, we'll sample one set of words for\n`t={0,1}`, another for `t={2,3}`, and so on. The sampling is for the\ndenominator of the objective function.")},
  {C("num_samples"), get_num_samples, set_num_samples, C("The number of samples.\n\nThis is the number of words that we sample at the output of the nnet for\neach of the `num_sample_groups` groups. If we didn't do sampling because\nthe user didn't provide the ARPA language model, this will be zero (in\nthis case we'll do the summation over all words in the vocab).")},
  {C("input_words"), get_input_words, set_input_words, C("The input word labels.\n\nContains the input word symbols 0 <= i < vocab_size for each position in\neach chunk; dimension == chunk_length * num_chunks, where 0 <= t <\nchunk_length has larger stride than 0 <= n < num_chunks.  In the common\ncase these will be the same as the previous output symbol.")},
  {C("output_words"), get_output_words, set_output_words, C("The output word labels.\n\nThe output (predicted) word symbols for each position in each chunk;\nindexed in the same way as 'input_words'.  What this contains is\ndifferent from 'input_words' in the sampling case (i.e. if\n!sampled_words.empty()).  In this case, instead of the word-index it\ncontains the relative index 0 <= i < num_samples within the block of\nsampled words.  In the not-sampled case it contains actual word indexes\n0 <= i < vocab_size.")},
  {C("output_weights"), get_output_weights, set_output_weights, C("The output weights.\n\nWeights for each of the `output_words`, indexed the same way as\n`output_words`. These reflect any data-weighting we had in the original\ndata, plus some zeros that relate to padding sequences of uneven length.")},
  {C("sampled_words"), get_sampled_words, set_sampled_words, C("The sampled word labels.\n\nThis list contains the word-indexes that we sampled for each position in\nthe chunk and for each group of chunks.  (It will be empty if the user\ndidn't provide the ARPA language model).  Its dimension is\nnum_sample_groups * num_samples, where num_sample_groups == (chunk_length\n/ sample_group_size). The sample-group index has the largest stride (you\ncan think of the sample group index as the number i = t /\nsample_group_size, in integer division, where 0 <= t < chunk_length is\nthe position in the chunk).  The sampled words within each block of size\n`num_samples` are sorted and unique.")},
  {C("sample_inv_probs"), get_sample_inv_probs, set_sample_inv_probs, C("The inverses probabilities.\n\nThis vector has the same dimension as 'sampled_words', and contains the\ninverses of the probabilities probability 0 < p <= 1 with which that word\nwas included in the sampled set of words.  These inverse probabilities\nappear in the objective function computation (it's related to importance\nsampling).")},
  {}
};

static PyMethodDef Methods[] = {
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:RnnlmExample)\n\nSwaps contents with another RNNLM example.\n\nArgs:\n  other (RnnlmExample): The other RNNLM example.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the RNNLM example to output stream.\n\nArgs:\n  os (ostream): The output C++ stream.\n  binary (bool): Whether the stream is binary.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n\nReads the RNNLM example from input stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.")},
  {}
};

// RnnlmExample __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmExample __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmExample __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_rnnlm_example.RnnlmExample",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "A single minibatch for training an RNNLM.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RnnlmExample takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmExample>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::RnnlmExample* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_RnnlmExample"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::RnnlmExample"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::RnnlmExample* c = static_cast<::kaldi::rnnlm::RnnlmExample*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::RnnlmExample*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmExample

namespace pyRnnlmEgsConfig {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::RnnlmEgsConfig> cpp;
};
static ::kaldi::rnnlm::RnnlmEgsConfig* ThisPtr(PyObject*);

static PyObject* get_vocab_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->vocab_size, {});
}

static int set_vocab_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the vocab_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->vocab_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for vocab_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_chunks_per_minibatch(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_chunks_per_minibatch, {});
}

static int set_num_chunks_per_minibatch(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_chunks_per_minibatch attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_chunks_per_minibatch)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_chunks_per_minibatch:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_chunk_length(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->chunk_length, {});
}

static int set_chunk_length(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the chunk_length attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->chunk_length)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for chunk_length:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_min_split_context(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->min_split_context, {});
}

static int set_min_split_context(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the min_split_context attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->min_split_context)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for min_split_context:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_sample_group_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->sample_group_size, {});
}

static int set_sample_group_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the sample_group_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->sample_group_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for sample_group_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_num_samples(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->num_samples, {});
}

static int set_num_samples(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the num_samples attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->num_samples)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for num_samples:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_chunk_buffer_size(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->chunk_buffer_size, {});
}

static int set_chunk_buffer_size(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the chunk_buffer_size attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->chunk_buffer_size)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for chunk_buffer_size:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_bos_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->bos_symbol, {});
}

static int set_bos_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the bos_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->bos_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for bos_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_eos_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->eos_symbol, {});
}

static int set_eos_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the eos_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->eos_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for eos_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_brk_symbol(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->brk_symbol, {});
}

static int set_brk_symbol(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the brk_symbol attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->brk_symbol)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for brk_symbol:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_special_symbol_prob(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->special_symbol_prob, {});
}

static int set_special_symbol_prob(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the special_symbol_prob attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->special_symbol_prob)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for special_symbol_prob:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_uniform_prob_mass(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->uniform_prob_mass, {});
}

static int set_uniform_prob_mass(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the uniform_prob_mass attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->uniform_prob_mass)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for uniform_prob_mass:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmEgsConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// check()
static PyObject* wrapCheck_as_check(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmEgsConfig* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Check();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("vocab_size"), get_vocab_size, set_vocab_size, C("The vocabulary size.\n\nMore specifically, the largest integer word-id plus one.  Must be\nprovided, as it gets included in each minibatch (mostly for checking\npurposes).")},
  {C("num_chunks_per_minibatch"), get_num_chunks_per_minibatch, set_num_chunks_per_minibatch, C("The number of parallel word sequences/chunks per minibatch.")},
  {C("chunk_length"), get_chunk_length, set_chunk_length, C("The length of each sequence in a minibatch.\n\nThe length of each sequence in a minibatch, including any terminating\n</s> symbols, which are included explicitly in the sequences. When </s>\nappears in the middle of sequences because we splice shorter word\nsequences together, we will replace it with <s> on the input side of the\nnetwork. Sentences, or pieces of sentences, that were shorter than\n`chunk_length`, will be padded as needed.")},
  {C("min_split_context"), get_min_split_context, set_min_split_context, C("Min left-context supplied for each training sentence piece.")},
  {C("sample_group_size"), get_sample_group_size, set_sample_group_size, C("The sampling group size.\n\nThis is the number of consecutive time-steps which form a single unit for\nsampling purposes.  This number will always divide `chunk_length`.\nExample: if `sample_group_size==2`, we'll sample one set of words for\n`t={0,1}`, another for `t={2,3}`, and so on. We support merging\ntime-steps in this way (but not splitting them smaller), due to\nconsiderations of computing time if you assume we also have a network\nthat learns word representation from their character-level features.")},
  {C("num_samples"), get_num_samples, set_num_samples, C("The number of words we choose each time we do the sampling.")},
  {C("chunk_buffer_size"), get_chunk_buffer_size, set_chunk_buffer_size, C("The number of chunks that are buffered while processing the input.\n\nLarger means more complete randomization but also more I/O before we\nproduce any output, and more memory used.")},
  {C("bos_symbol"), get_bos_symbol, set_bos_symbol, C("Beginning of sentence symbol.\n\nIt must be set.")},
  {C("eos_symbol"), get_eos_symbol, set_eos_symbol, C("End of sentence symbol.\n\nIt must be set.")},
  {C("brk_symbol"), get_brk_symbol, set_brk_symbol, C("Break symbol.\n\nIt must be set.")},
  {C("special_symbol_prob"), get_special_symbol_prob, set_special_symbol_prob, C("Sampling probability for words that aren't supposed to be predicted.\n\nSampling probability at the output for words that aren't supposed to be\npredicted (<s>, <brk>)-- this ensures that the model makes their output\nprobs small, which avoids hassle when computing the normalizer in test\ntime (if we didn't sample them with some probability to ensure their\nprobs are small, we'd have to exclude them from the denominator sum.")},
  {C("uniform_prob_mass"), get_uniform_prob_mass, set_uniform_prob_mass, C("The probability mass to uniformly distribute over all words.\n\nThis value should be < 1.0; it is the proportion of the unigram\ndistribution used for sampling assigned to uniformly predicting all\nwords. This may avoid certain pathologies during training, and ensure\nthat all words' probs are bounded away from zero, which might be\nnecessary for the theory of importance sampling.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n\nRegisters options with an object implementing the options interface.\n\nArgs:\n  opts (OptionsItf): An object implementing the options interface.\n    Typically a command-line option parser.")},
  {C("check"), (PyCFunction)wrapCheck_as_check, METH_NOARGS, C("check()\n\nValidates the options.\n\nRaises:\n  RuntimeError: If validation fails.")},
  {}
};

// RnnlmEgsConfig __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmEgsConfig __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmEgsConfig __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_rnnlm_example.RnnlmEgsConfig",     // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "RNNLM example configuration.",      // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RnnlmEgsConfig takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmEgsConfig>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::RnnlmEgsConfig* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_RnnlmEgsConfig"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::RnnlmEgsConfig"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::RnnlmEgsConfig* c = static_cast<::kaldi::rnnlm::RnnlmEgsConfig*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::RnnlmEgsConfig*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmEgsConfig

namespace pyRnnlmExampleSampler {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::RnnlmExampleSampler> cpp;
};
static ::kaldi::rnnlm::RnnlmExampleSampler* ThisPtr(PyObject*);

// __init__(config:RnnlmEgsConfig, arpa_sampling:SamplingLm)
static PyObject* wrapRnnlmExampleSampler_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("config"),
      C("arpa_sampling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  ::kaldi::rnnlm::RnnlmEgsConfig* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::rnnlm::RnnlmEgsConfig", a[0]);
  ::kaldi::rnnlm::SamplingLm* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::rnnlm::SamplingLm", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmExampleSampler>(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sample_for_minibatch(minibatch:RnnlmExample)
static PyObject* wrapSampleForMinibatch_as_sample_for_minibatch(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("minibatch"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sample_for_minibatch", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::RnnlmExample * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sample_for_minibatch", names[0], "::kaldi::rnnlm::RnnlmExample *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExampleSampler* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SampleForMinibatch(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// vocab_size() -> int
static PyObject* wrapVocabSize_as_vocab_size(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExampleSampler* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->VocabSize();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapRnnlmExampleSampler_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(config:RnnlmEgsConfig, arpa_sampling:SamplingLm)\n  Calls C++ function\n  void ::kaldi::rnnlm::RnnlmExampleSampler::RnnlmExampleSampler(::kaldi::rnnlm::RnnlmEgsConfig, ::kaldi::rnnlm::SamplingLm)")},
  {C("sample_for_minibatch"), (PyCFunction)wrapSampleForMinibatch_as_sample_for_minibatch, METH_VARARGS | METH_KEYWORDS, C("sample_for_minibatch(minibatch:RnnlmExample)\n\nDoes the sampling for a minibatch.\n\nArgs:\n  minibatch (RnnlmExample): The minibatch. It is expected to already\n    have all fields populated except for `sampled_words` and\n    `sample_probs`. This method does the sampling and sets those\n    fields.")},
  {C("vocab_size"), (PyCFunction)wrapVocabSize_as_vocab_size, METH_NOARGS, C("vocab_size() -> int\n\nGets vocabulary size.\n\nReturns:\n  int: The vocabulary size, i.e. the highest-numbered word plus one.")},
  {}
};

// RnnlmExampleSampler __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmExampleSampler __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmExampleSampler __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_rnnlm_example.RnnlmExampleSampler", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "RNNLM example sampler.\n\nThis class encapsulates the logic for sampling words for a minibatch.\nThe words at the output of the RNNLM are sampled and we train with an\nimportance-sampling algorithm.\n\nArgs:\n  config (RnnlmEgsConfig): The RNNLM example configuration.\n  arpa_sampling (SamplingLm): The sampling LM.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapRnnlmExampleSampler_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::RnnlmExampleSampler* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_RnnlmExampleSampler"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::RnnlmExampleSampler"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::RnnlmExampleSampler* c = static_cast<::kaldi::rnnlm::RnnlmExampleSampler*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::RnnlmExampleSampler*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmExampleSampler


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyRnnlmExample::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmExample::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRnnlmEgsConfig::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmEgsConfig::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRnnlmExampleSampler::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmExampleSampler::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_rnnlm_example",  // module name
  "CLIF-generated module for rnnlm/rnnlm-example.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sampling_lm")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "RnnlmExample", reinterpret_cast<PyObject*>(&pyRnnlmExample::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RnnlmEgsConfig", reinterpret_cast<PyObject*>(&pyRnnlmEgsConfig::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RnnlmExampleSampler", reinterpret_cast<PyObject*>(&pyRnnlmExampleSampler::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __rnnlm__example_clifwrap

namespace kaldi { namespace rnnlm {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// RnnlmEgsConfig to/from ::kaldi::rnnlm::RnnlmEgsConfig conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmEgsConfig** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::RnnlmEgsConfig* cpp = __rnnlm__example_clifwrap::pyRnnlmEgsConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::RnnlmEgsConfig>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmEgsConfig* cpp = __rnnlm__example_clifwrap::pyRnnlmEgsConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::RnnlmEgsConfig>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmEgsConfig* cpp = __rnnlm__example_clifwrap::pyRnnlmEgsConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmEgsConfig instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmEgsConfig* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmEgsConfig* cpp = __rnnlm__example_clifwrap::pyRnnlmEgsConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::RnnlmEgsConfig>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmEgsConfig* cpp = __rnnlm__example_clifwrap::pyRnnlmEgsConfig::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::RnnlmEgsConfig* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmEgsConfig>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::RnnlmEgsConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmEgsConfig>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::RnnlmEgsConfig> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmEgsConfig>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::RnnlmEgsConfig& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmEgsConfig::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmEgsConfig>(c);
  return py;
}

// RnnlmExample to/from ::kaldi::rnnlm::RnnlmExample conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmExample** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::RnnlmExample* cpp = __rnnlm__example_clifwrap::pyRnnlmExample::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::RnnlmExample>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExample* cpp = __rnnlm__example_clifwrap::pyRnnlmExample::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::RnnlmExample>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExample* cpp = __rnnlm__example_clifwrap::pyRnnlmExample::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmExample instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmExample* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExample* cpp = __rnnlm__example_clifwrap::pyRnnlmExample::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::RnnlmExample>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExample* cpp = __rnnlm__example_clifwrap::pyRnnlmExample::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::RnnlmExample* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExample::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExample>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::RnnlmExample> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExample::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExample>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::RnnlmExample> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExample::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExample>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::RnnlmExample& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExample::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExample::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmExample>(c);
  return py;
}

// RnnlmExampleSampler to/from ::kaldi::rnnlm::RnnlmExampleSampler conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmExampleSampler** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::RnnlmExampleSampler* cpp = __rnnlm__example_clifwrap::pyRnnlmExampleSampler::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::RnnlmExampleSampler>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleSampler* cpp = __rnnlm__example_clifwrap::pyRnnlmExampleSampler::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::RnnlmExampleSampler>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleSampler* cpp = __rnnlm__example_clifwrap::pyRnnlmExampleSampler::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmExampleSampler instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::RnnlmExampleSampler* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleSampler>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::RnnlmExampleSampler> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleSampler>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::RnnlmExampleSampler> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example_clifwrap::pyRnnlmExampleSampler::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleSampler>(std::move(c));
  return py;
}

} }  // namespace kaldi::rnnlm
