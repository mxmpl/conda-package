//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/rnnlm/rnnlm-utils.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/sparse-matrix-clifwrap.h"
#include "rnnlm-utils-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __rnnlm__utils_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// read_sparse_word_features(is:istream, feature_dim:int) -> SparseMatrix
static PyObject* wrapReadSparseWordFeatures_as_read_sparse_word_features(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("feature_dim"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read_sparse_word_features", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_sparse_word_features", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_sparse_word_features", names[1], "int", a[1]);
  ::kaldi::SparseMatrix<float> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::rnnlm::ReadSparseWordFeatures(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("read_sparse_word_features"), (PyCFunction)wrapReadSparseWordFeatures_as_read_sparse_word_features, METH_VARARGS | METH_KEYWORDS, C("read_sparse_word_features(is:istream, feature_dim:int) -> SparseMatrix\n\nReads sparse word features from input stream.\n\n Reads a text file (e.g. exp/rnnlm/word_feats.txt) which maps words to\n sparse combinations of features.  The text file contains lines of the\n format:\n   <word-index> <feat1-index> <feat1-value> <feat2-index> <feat2-value>...\n with the feature-indexes in sorted order, for example:\n   2056  11 3.0 25 1.0 1069 1.0\n The word-indexes are expected to be in order 0, 1, 2, ...; so they don't\n really add any information; they are included for human readability.\n\n Args:\n   is (istream): The stream we are reading.\n   feature_dim (int): The feature dimension, i.e. the highest-numbered\n     possible feature plus one. We don't attempt to work this out from the\n     input, in case for some reason this vocabulary does not use the\n     highest-numbered feature.\n\nReturns:\n  A sparse matrix of dimension num-words by feature-dim, containing the\n  word feature information in the file we read.\n\n Raises:\n   RuntimeError: If the input is not as expected.\n ")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_rnnlm_utils",  // module name
  "CLIF-generated module for rnnlm/rnnlm-utils.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sparse_matrix")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __rnnlm__utils_clifwrap
