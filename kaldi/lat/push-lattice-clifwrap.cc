//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/lat/push-lattice.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "push-lattice-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __push__lattice_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// push_compact_lattice_strings(clat:CompactLatticeMutableFst) -> bool
static PyObject* wrapPushCompactLatticeStrings_as_push_compact_lattice_strings(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:push_compact_lattice_strings", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("push_compact_lattice_strings", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::PushCompactLatticeStrings(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// push_compact_lattice_weights(clat:CompactLatticeMutableFst) -> bool
static PyObject* wrapPushCompactLatticeWeights_as_push_compact_lattice_weights(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("clat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:push_compact_lattice_weights", names, &a[0])) return nullptr;
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("push_compact_lattice_weights", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::PushCompactLatticeWeights(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("push_compact_lattice_strings"), (PyCFunction)wrapPushCompactLatticeStrings_as_push_compact_lattice_strings, METH_VARARGS | METH_KEYWORDS, C("push_compact_lattice_strings(clat:CompactLatticeMutableFst) -> bool\n\nPushes the transition-ids as far towards the start as they will go.\n\nIt can be useful prior to :meth:`word_align_lattice` (for non-linear\nlattices).  We can't use the generic OpenFst \"push\" function because\nit uses the sum as the divisor, which is not appropriate in this case\n(a+b generally won't divide a or b in this semiring).\n\nReturns:\n  True on success, False if topological sorting fails.")},
  {C("push_compact_lattice_weights"), (PyCFunction)wrapPushCompactLatticeWeights_as_push_compact_lattice_weights, METH_VARARGS | METH_KEYWORDS, C("push_compact_lattice_weights(clat:CompactLatticeMutableFst) -> bool\n\nPushes the weights in compact lattice toward the start state.\n\nThis function pushes the weights in the compact lattice so that all\nstates except possibly the start state, have weight components (of type\nLatticeWeight) that \"sum to one\" in the lattice semiring (i.e.\ninterpreting the weights as negated log-probs).\n\nReturns:\n  True on success, False if topological sorting fails.")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_push_lattice",  // module name
  "CLIF-generated module for lat/push-lattice.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __push__lattice_clifwrap
