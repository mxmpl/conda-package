//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/kaldi-matrix.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "kaldi-matrix-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__matrix_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyMatrixBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::MatrixBase<float>> cpp;
};
static ::kaldi::MatrixBase<float>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumRows(), {});
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumCols(), {});
}

static PyObject* get_stride(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Stride(), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _getitem(row:int, col:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("row"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _setitem_(row:int, col:int, value:float)
static PyObject* wrapSet_as__setitem_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("row"),
      C("col"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_setitem_", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_setitem_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_setitem_", names[1], "int", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_setitem_", names[2], "float", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_zero_()
static PyObject* wrapSetZero_as_set_zero_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_unit_()
static PyObject* wrapSetUnit_as_set_unit_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetUnit();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_randn_()
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_rand_uniform_()
static PyObject* wrapSetRandUniform_as_set_rand_uniform_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _copy_from_mat_(M:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as__copy_from_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_copy_from_mat_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_mat_", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_rows_from_vec_(v:VectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_cols_from_vec_(v:VectorBase)
static PyObject* wrapCopyColsFromVec_as_copy_cols_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_cols_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_col_from_vec_(v:VectorBase, col:int)
static PyObject* wrapCopyColFromVec_as_copy_col_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_col_from_vec_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_col_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_col_from_vec_", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_row_from_vec_(v:VectorBase, row:int)
static PyObject* wrapCopyRowFromVec_as_copy_row_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_row_from_vec_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_row_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_row_from_vec_", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_diag_from_vec_(v:VectorBase)
static PyObject* wrapCopyDiagFromVec_as_copy_diag_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_diag_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_diag_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyDiagFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace(check_square:bool=default) -> float
static PyObject* wrapTrace_as_trace(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("check_square"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:trace", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("trace", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->Trace(); break;
  case 1:
    ret0 = c->Trace(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// mul_elements_(A:MatrixBase)
static PyObject* wrapMulElements_as_mul_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_elements_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_elements_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// div_elements_(A:MatrixBase)
static PyObject* wrapDivElements_as_div_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_elements_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_elements_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max_with_mat_(A:MatrixBase)
static PyObject* wrapMax_as_max_with_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:max_with_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("max_with_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Max(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// min_with_mat_(A:MatrixBase)
static PyObject* wrapMin_as_min_with_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:min_with_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("min_with_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Min(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_cols_vec_(scale:VectorBase)
static PyObject* wrapMulColsVec_as_mul_cols_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_cols_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_cols_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulColsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_rows_vec_(scale:VectorBase)
static PyObject* wrapMulRowsVec_as_mul_rows_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_rows_group_mat_(src:MatrixBase)
static PyObject* wrapMulRowsGroupMat_as_mul_rows_group_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_group_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_group_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsGroupMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// log_det() -> (log_det:float, det_sign:float)
static PyObject* wrapLogDet_as_log_det(PyObject* self) {
  float ret1{};
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LogDet(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// invert_elements_()
static PyObject* wrapInvertElements_as_invert_elements_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// transpose_()
static PyObject* wrapTranspose_as_transpose_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_(floor:float)
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_ceiling_(ceiling:float)
static PyObject* wrapApplyCeiling_as_apply_ceiling_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_()
static PyObject* wrapApplyLog_as_apply_log_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_exp_()
static PyObject* wrapApplyExp_as_apply_exp_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_(power:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_abs_(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs_", names[0], "float", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs_", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_heaviside_()
static PyObject* wrapApplyHeaviside_as_apply_heaviside_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyHeaviside();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _eig(P:MatrixBase, eigs_real:VectorBase, eigs_imag:VectorBase)
static PyObject* wrapEig_as__eig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("P"),
      C("eigs_real"),
      C("eigs_imag"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_eig", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_eig", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::VectorBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_eig", names[1], "::kaldi::VectorBase<float> *", a[1]);
  ::kaldi::VectorBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_eig", names[2], "::kaldi::VectorBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Eig(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// power_(pow:float) -> bool
static PyObject* wrapPower_as_power_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("pow"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:power_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("power_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Power(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _destructive_svd_(s:VectorBase, U:MatrixBase, Vt:MatrixBase)
static PyObject* wrapDestructiveSvd_as__destructive_svd_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_destructive_svd_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_destructive_svd_", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_destructive_svd_", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_destructive_svd_", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DestructiveSvd(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _svd(s:VectorBase, U:MatrixBase, Vt:MatrixBase)
static PyObject* wrapSvd_as__svd(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_svd", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_svd", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_svd", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_svd", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Svd(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _singular_values(s:VectorBase)
static PyObject* wrapSvd_as__singular_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("s"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_singular_values", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_singular_values", names[0], "::kaldi::VectorBase<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Svd(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// min_singular_value() -> float
static PyObject* wrapMinSingularValue_as_min_singular_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MinSingularValue();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// cond() -> float
static PyObject* wrapCond_as_cond(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Cond();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_symmetric(cutoff:float=default) -> bool
static PyObject* wrapIsSymmetric_as_is_symmetric(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_symmetric", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_symmetric", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsSymmetric(); break;
  case 1:
    ret0 = c->IsSymmetric(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_diagonal(cutoff:float=default) -> bool
static PyObject* wrapIsDiagonal_as_is_diagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_diagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_diagonal", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsDiagonal(); break;
  case 1:
    ret0 = c->IsDiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(cutoff:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal(other:MatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal", names[0], "::kaldi::MatrixBase<float>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// equal(other:MatrixBase) -> bool
static PyObject* wrapEqual_as_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:equal", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equal", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Equal(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// largest_abs_elem() -> float
static PyObject* wrapLargestAbsElem_as_largest_abs_elem(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LargestAbsElem();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_sum_exp(prune:float=default) -> float
static PyObject* wrapLogSumExp_as_log_sum_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("prune"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:log_sum_exp", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_sum_exp", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LogSumExp(); break;
  case 1:
    ret0 = c->LogSumExp(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_softmax_() -> float
static PyObject* wrapApplySoftMax_as_apply_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplySoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sigmoid_(src:MatrixBase)
static PyObject* wrapSigmoid_as_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// heaviside_(src:MatrixBase)
static PyObject* wrapHeaviside_as_heaviside_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:heaviside_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("heaviside_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Heaviside(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// soft_hinge_(src:MatrixBase)
static PyObject* wrapSoftHinge_as_soft_hinge_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:soft_hinge_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("soft_hinge_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SoftHinge(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_pnorm_(src:MatrixBase, power:float)
static PyObject* wrapGroupPnorm_as_group_pnorm_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_pnorm_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm_", names[1], "float", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnorm(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_pnorm_deriv_(input:MatrixBase, output:MatrixBase, power:float)
static PyObject* wrapGroupPnormDeriv_as_group_pnorm_deriv_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("input"),
      C("output"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:group_pnorm_deriv_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm_deriv_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm_deriv_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  float arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("group_pnorm_deriv_", names[2], "float", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnormDeriv(*arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_max_(src:MatrixBase)
static PyObject* wrapGroupMax_as_group_max_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:group_max_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMax(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_max_deriv_(input:MatrixBase, output:MatrixBase)
static PyObject* wrapGroupMaxDeriv_as_group_max_deriv_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input"),
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_max_deriv_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_deriv_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_max_deriv_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMaxDeriv(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// tanh_(src:MatrixBase)
static PyObject* wrapTanh_as_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// diff_sigmoid_(value:MatrixBase, diff:MatrixBase)
static PyObject* wrapDiffSigmoid_as_diff_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_sigmoid_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_sigmoid_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_sigmoid_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSigmoid(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// diff_tanh_(value:MatrixBase, diff:MatrixBase)
static PyObject* wrapDiffTanh_as_diff_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_tanh_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_tanh_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_tanh_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffTanh(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sym_pos_semi_def_eig(s:VectorBase, P:MatrixBase, check_thresh:float=default)
static PyObject* wrapSymPosSemiDefEig_as_sym_pos_semi_def_eig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("s"),
      C("P"),
      C("check_thresh"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:sym_pos_semi_def_eig", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_pos_semi_def_eig", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_pos_semi_def_eig", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_pos_semi_def_eig", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->SymPosSemiDefEig(arg1, arg2); break;
  case 3:
    c->SymPosSemiDefEig(arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_(alpha:float)
static PyObject* wrapAdd_as_add_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_to_diag_(alpha:float)
static PyObject* wrapAddToDiag_as_add_to_diag_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_to_diag_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_diag_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToDiag(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, a:VectorBase, b:VectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("a"),
      C("b"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec_", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_to_rows_(alpha:float, v:VectorBase)
static PyObject* wrapAddVecToRows_as_add_vec_to_rows_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec_to_rows_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_rows_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_rows_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecToRows(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_to_cols_(alpha:float, v:VectorBase)
static PyObject* wrapAddVecToCols_as_add_vec_to_cols_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec_to_cols_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_cols_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_cols_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecToCols(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_(alpha:float, M:MatrixBase, transM:MatrixTransposeType=default)
static PyObject* wrapAddMat_as__add_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_add_mat_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMat(std::move(arg1), *arg2); break;
  case 3:
    c->AddMat(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sym_add_mat2_(alpha:float, M:MatrixBase, transA:MatrixTransposeType, beta:float)
static PyObject* wrapSymAddMat2_as_sym_add_mat2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transA"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:sym_add_mat2_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_add_mat2_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_add_mat2_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_add_mat2_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("sym_add_mat2_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymAddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_diag_vec_mat_(alpha:float, v:VectorBase, M:MatrixBase, transM:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagVecMat_as_add_diag_vec_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("v"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_diag_vec_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_mat_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_mat_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_diag_vec_mat_", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_diag_vec_mat_", names[3], "::kaldi::MatrixTransposeType", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_diag_vec_mat_", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4)); break;
  case 5:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_diag_vec_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, v:VectorBase, beta:float=default)
static PyObject* wrapAddMatDiagVec_as_add_mat_diag_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_diag_vec_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_diag_vec_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_diag_vec_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_diag_vec_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::VectorBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_diag_vec_", names[3], "::kaldi::VectorBase<float>", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_diag_vec_", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_mat_elements_(alpha:float, A:MatrixBase, B:MatrixBase, beta:float)
static PyObject* wrapAddMatMatElements_as_add_mat_mat_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat_mat_elements_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_elements_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_elements_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_elements_", names[2], "::kaldi::MatrixBase<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_elements_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatElements(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMat_as__add_mat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_mat_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_mat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_mat_", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_mat_", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_mat_mat_div_mat_(A:MatrixBase, B:MatrixBase, C:MatrixBase)
static PyObject* wrapSetMatMatDivMat_as_set_mat_mat_div_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("A"),
      C("B"),
      C("C"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:set_mat_mat_div_mat_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_mat_mat_div_mat_", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_mat_mat_div_mat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("set_mat_mat_div_mat_", names[2], "::kaldi::MatrixBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetMatMatDivMat(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_smat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatSmat_as__add_mat_smat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_smat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_smat_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_smat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_smat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_smat_", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_smat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_smat_", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatSmat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_smat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddSmatMat_as__add_smat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_smat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_smat_mat_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_smat_mat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_smat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_smat_mat_", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_smat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_smat_mat_", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddSmatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_mat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMatMat_as_add_mat_mat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:add_mat_mat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_mat_", names[0], "float", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_mat_", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_mat_", names[3], "::kaldi::MatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_mat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  ::kaldi::MatrixBase<float>* arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("add_mat_mat_mat_", names[5], "::kaldi::MatrixBase<float>", a[5]);
  ::kaldi::MatrixTransposeType arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("add_mat_mat_mat_", names[6], "::kaldi::MatrixTransposeType", a[6]);
  float arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("add_mat_mat_mat_", names[7], "float", a[7]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), *arg6, std::move(arg7), std::move(arg8));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_lower_to_upper_()
static PyObject* wrapCopyLowerToUpper_as_copy_lower_to_upper_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyLowerToUpper();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_upper_to_lower_()
static PyObject* wrapCopyUpperToLower_as_copy_upper_to_lower_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyUpperToLower();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// orthogonalize_rows_()
static PyObject* wrapOrthogonalizeRows_as_orthogonalize_rows_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->OrthogonalizeRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("num_rows"), get_num_rows, nullptr, C("Number of rows (zero for empty matrix).")},
  {C("num_cols"), get_num_cols, nullptr, C("Number of columns (zero for empty matrix).")},
  {C("stride"), get_stride, nullptr, C("Row stride (distance in memory between each row, >= num_cols).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n\nReturns the size (in bytes) of the data held by the matrix.")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(row:int, col:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  row (int): The row index of the element.\n  col (int): The column index of the element.\n\nReturns:\n  The element at the given index.")},
  {C("_setitem_"), (PyCFunction)wrapSet_as__setitem_, METH_VARARGS | METH_KEYWORDS, C("_setitem_(row:int, col:int, value:float)\n\nSets the element at the given index.\n\nArgs:\n  row (int): The row index of the element.\n  col (int): The column index of the element.\n  value (float): The value to set.")},
  {C("set_zero_"), (PyCFunction)wrapSetZero_as_set_zero_, METH_NOARGS, C("set_zero_()\n\nSets the elements to zero.")},
  {C("set_unit_"), (PyCFunction)wrapSetUnit_as_set_unit_, METH_NOARGS, C("set_unit_()\n\nSets diagonal elements to one, off-diagonal elements to zero.\n\nNote:\n  Works for non-square matrices too.")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_NOARGS, C("set_randn_()\n\nSets the elements to numbers from standard normal distribution.")},
  {C("set_rand_uniform_"), (PyCFunction)wrapSetRandUniform_as_set_rand_uniform_, METH_NOARGS, C("set_rand_uniform_()\n\nSets the elements to numbers uniformly distributed on (0,1).")},
  {C("_copy_from_mat_"), (PyCFunction)wrapCopyFromMat_as__copy_from_mat_, METH_VARARGS | METH_KEYWORDS, C("_copy_from_mat_(M:MatrixBase, trans:MatrixTransposeType=default)\n\nCopies the elements from another matrix.\n\nArgs:\n  M (Matrix): The input matrix.\n  trans (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_rows_from_vec_"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_vec_(v:VectorBase)\n\nCopies row elements from a vector.\n\nThis method has two modes of operation. If the number of elements in\n`self` and `v` are the same, then elements of `v` are copied into\n`self` row by row. If the number of elements in `v` is equal to\n`self.num_cols`, then the elements of `v` are copied into each row of\n`self`.\n\nArgs:\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_cols_from_vec_"), (PyCFunction)wrapCopyColsFromVec_as_copy_cols_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_cols_from_vec_(v:VectorBase)\n\nCopies column elements from a vector.\n\nThis method has two modes of operation. If the number of elements in\n`self` and `v` are the same, then elements of `v` are copied into\n`self` column by column. If the number of elements in `v` is equal to\n`self.num_rows`, then the elements of `v` are copied into each column\nof `self`.\n\nArgs:\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_col_from_vec_"), (PyCFunction)wrapCopyColFromVec_as_copy_col_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_col_from_vec_(v:VectorBase, col:int)\n\nCopies a vector into the specified column.\n\nArgs:\n  v (Vector): The input vector.\n  col (int): The column index.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_row_from_vec_"), (PyCFunction)wrapCopyRowFromVec_as_copy_row_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_row_from_vec_(v:VectorBase, row:int)\n\nCopies a vector into the specified row.\n\nArgs:\n  v (Vector): The input vector.\n  row (int): The row index.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_diag_from_vec_"), (PyCFunction)wrapCopyDiagFromVec_as_copy_diag_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_diag_from_vec_(v:VectorBase)\n\nCopies a vector into the diagonal.\n\nArgs:\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elements.")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_VARARGS | METH_KEYWORDS, C("trace(check_square:bool=default) -> float\n\nReturns the trace.\n\nIf matrix is not square it will return the trace of the square matrix\nformed from the minimum dimension, e.g. if the matrix is 3x5 it will\nreturn the trace of the 3x3 submatrix at the beginning.\n\nArgs:\n  check_square(bool): Check if the matrix is square.\n    Defaults to ``True``.\n\nRaises:\n  RuntimeError: If the matrix is not square and\n  **check_square** is ``True``.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n\nReturns the maximum value in the matrix.")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n\nReturns the minimum value in the matrix.")},
  {C("mul_elements_"), (PyCFunction)wrapMulElements_as_mul_elements_, METH_VARARGS | METH_KEYWORDS, C("mul_elements_(A:MatrixBase)\n\nMultiplies element-wise with another matrix.\n\nPerforms the operation `M = M \\odot A`.\n\nArgs:\n  A (Matrix): The multiplier.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("div_elements_"), (PyCFunction)wrapDivElements_as_div_elements_, METH_VARARGS | METH_KEYWORDS, C("div_elements_(A:MatrixBase)\n\nDivides element-wise with another matrix.\n\nPerforms the operation `M = M \\oslash A`.\n\nArgs:\n  A (Matrix): The denominator.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScales the matrix.\n\nArgs:\n  alpha (float): The scalar multiplier.")},
  {C("max_with_mat_"), (PyCFunction)wrapMax_as_max_with_mat_, METH_VARARGS | METH_KEYWORDS, C("max_with_mat_(A:MatrixBase)\n\nApplies an element-wise max operation.\n\nPerforms the operation `M[i,j] = max(M[i,j], A[i,j])`.\n\nArgs:\n  A (Matrix): The input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("min_with_mat_"), (PyCFunction)wrapMin_as_min_with_mat_, METH_VARARGS | METH_KEYWORDS, C("min_with_mat_(A:MatrixBase)\n\nApplies an element-wise min operation.\n\nPerforms the operation `M[i,j] = min(M[i,j], A[i,j])`.\n\nArgs:\n  A (Matrix): The input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_cols_vec_"), (PyCFunction)wrapMulColsVec_as_mul_cols_vec_, METH_VARARGS | METH_KEYWORDS, C("mul_cols_vec_(scale:VectorBase)\n\nScales columns with the elements in a vector.\n\nPerforms the operation `M[i,j] = scale[j] * M[i,j]`.\n\nArgs:\n  scale (Vector): The scaling vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_rows_vec_"), (PyCFunction)wrapMulRowsVec_as_mul_rows_vec_, METH_VARARGS | METH_KEYWORDS, C("mul_rows_vec_(scale:VectorBase)\n\nScales rows with the elements in a vector.\n\nPerforms the operation `M[i,j] = scale[i] * M[i,j]`.\n\nArgs:\n  scale (Vector): The scaling vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_rows_group_mat_"), (PyCFunction)wrapMulRowsGroupMat_as_mul_rows_group_mat_, METH_VARARGS | METH_KEYWORDS, C("mul_rows_group_mat_(src:MatrixBase)\n\nScales matrix with another matrix.\n\nDivides each row of `self` into `src.num_cols` equal groups, and then\nscales `i`th row's `j`th group of elements with `src[i,j]`.\n\nArgs:\n  src (Matrix): The scaling matrix.\n\nRaises:\n  RuntimeError: If `self.num_rows != src.num_rows` or\n    `self.num_cols % src.num_cols != 0`.")},
  {C("log_det"), (PyCFunction)wrapLogDet_as_log_det, METH_NOARGS, C("log_det() -> (log_det:float, det_sign:float)\n\nComputes log determinant of the matrix.\n\nReturns:\n  2-element tuple containing\n\n  - **log_det** (:class:`float`): The log determinant.\n  - **det_sign** (:class:`float`): The sign of the determinant, 1 or -1.")},
  {C("invert_elements_"), (PyCFunction)wrapInvertElements_as_invert_elements_, METH_NOARGS, C("invert_elements_()\n\nInverts the elements.")},
  {C("transpose_"), (PyCFunction)wrapTranspose_as_transpose_, METH_NOARGS, C("transpose_()\n\nTransposes the matrix.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float)\n\nApplies floor operation to each element.\n\nPerforms the operation `M[i,j] = max(M[i,j], floor)`.\n\nArgs:\n  floor (float): The floor value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_ceiling_"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling_, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling_(ceiling:float)\n\nApplies ceiling operation to each element.\n\nPerforms the operation `M[i,j] = min(M[i,j], ceiling)`.\n\nArgs:\n  ceiling (float): The ceiling value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_log_"), (PyCFunction)wrapApplyLog_as_apply_log_, METH_NOARGS, C("apply_log_()\n\nApplies natural log operation to each element.")},
  {C("apply_exp_"), (PyCFunction)wrapApplyExp_as_apply_exp_, METH_NOARGS, C("apply_exp_()\n\nApplies exponential operation to each element.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(power:float)\n\nTakes each element to the given power.\n\nArgs:\n  power (float): The exponent value.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_pow_abs_"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs_(power:float, include_sign:bool=default)\n\nTakes the absolute value of each element raised to the given power.\n\nIf the power is negative and the input is zero, the output is zero.\n\nArgs:\n  power (float): The power value.\n  include_sign (bool): Whether to include the sign of the input value.\n    Defaults to ``False``.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_heaviside_"), (PyCFunction)wrapApplyHeaviside_as_apply_heaviside_, METH_NOARGS, C("apply_heaviside_()\n\nApplies the Heaviside step function to each element.")},
  {C("_eig"), (PyCFunction)wrapEig_as__eig, METH_VARARGS | METH_KEYWORDS, C("_eig(P:MatrixBase, eigs_real:VectorBase, eigs_imag:VectorBase)\n\nComputes eigendecomposition.\n\nFactorizes a square matrix into `P D P^{-1}`.\n\nThe relationship of D to the eigenvalues is slightly complicated, due\nto the need for P to be real. In the symmetric case, D is diagonal and\nreal, but in the non-symmetric case there may be complex-conjugate\npairs of eigenvalues. In this case, for the equation\n`self = P D P^{-1}`\nto hold, D must actually be block diagonal, with 2x2 blocks\ncorresponding to any such pairs. If a pair is `lambda +- i*mu`, D will\nhave a corresponding 2x2 block `[lambda, mu; -mu, lambda]`. Note that\nif the matrix is not invertible, P may not be invertible so in this\ncase instead of the equation `self = P D P^{-1}` holding, we have\n`self P = P D`.\n\nArgs:\n  P (MatrixBase): The matrix of eigenvectors.\n  eigs_real (Vector): The real part of the eigenvalues.\n  eigs_imag (Vector): The imaginary part of the eigenvalues.")},
  {C("power_"), (PyCFunction)wrapPower_as_power_, METH_VARARGS | METH_KEYWORDS, C("power_(pow:float) -> bool\n\nTakes the matrix to the specified power.\n\nThis method uses an algorithm that works in general for fractional\nand negative powers. The input matrix must be invertible and have a\nreasonable condition number. The algorithm is based on eigenvalue\ndecomposition. It will return False and leave the matrix unchanged,\nif the matrix has real negative eigenvalues (or if it has zero\neigenvalues and the power is negative).\n\nArgs:\n  pow (float): The exponent.\n\nReturns:\n  True if the operation was successful.")},
  {C("_destructive_svd_"), (PyCFunction)wrapDestructiveSvd_as__destructive_svd_, METH_VARARGS | METH_KEYWORDS, C("_destructive_svd_(s:VectorBase, U:MatrixBase, Vt:MatrixBase)\n\nComputes singular-value decomposition.\n\nThis is the destructive version which mutates self.\n\nFactorizes a matrix into  U diag(s) Vt.\n\nFor non-square matrices, requires self.num_rows >= self.num_cols.\n\nArgs:\n  s(Vector): The vector of singular values.\n  U(Matrix): The left orthonormal matrix.\n  Vt(Matrix): The right orthonormal matrix.\n\nNotes:\n  Vt in the output is already transposed.\n  The singular values in s are not sorted.\n\nRaises:\n  RuntimeError: If self.num_rows<self.num_cols,\n    or if U is not self.num_rows x self.num_cols,\n    or if Vt is not self.num_cols x self.num_cols.")},
  {C("_svd"), (PyCFunction)wrapSvd_as__svd, METH_VARARGS | METH_KEYWORDS, C("_svd(s:VectorBase, U:MatrixBase, Vt:MatrixBase)\n\nComputes singular-value decomposition.\n\nFactorizes a matrix into  U diag(s) Vt.\n\nFor non-square matrices, requires self.num_rows >= self.num_cols.\n\nArgs:\n  s(Vector): The vector of singular values.\n  U(Matrix): The left orthonormal matrix.\n  Vt(Matrix): The right orthonormal matrix.\n\nNotes:\n  Vt in the output is already transposed.\n  The singular values in s are not sorted.\n\nRaises:\n  RuntimeError: If self.num_rows<self.num_cols,\n    or if U is not self.num_rows x self.num_cols,\n    or if Vt is not self.num_cols x self.num_cols.")},
  {C("_singular_values"), (PyCFunction)wrapSvd_as__singular_values, METH_VARARGS | METH_KEYWORDS, C("_singular_values(s:VectorBase)\n\nComputes singular values.\n\nArgs:\n    s(Vector): The vector of singular values.")},
  {C("min_singular_value"), (PyCFunction)wrapMinSingularValue_as_min_singular_value, METH_NOARGS, C("min_singular_value() -> float\n\nReturns the smallest singular value.")},
  {C("cond"), (PyCFunction)wrapCond_as_cond, METH_NOARGS, C("cond() -> float\n\nReturns the condition number of the SVD computation.")},
  {C("is_symmetric"), (PyCFunction)wrapIsSymmetric_as_is_symmetric, METH_VARARGS | METH_KEYWORDS, C("is_symmetric(cutoff:float=default) -> bool\n\nChecks if the matrix is approximately symmetric.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if the matrix is approximately symmetric. False otherwise.")},
  {C("is_diagonal"), (PyCFunction)wrapIsDiagonal_as_is_diagonal, METH_VARARGS | METH_KEYWORDS, C("is_diagonal(cutoff:float=default) -> bool\n\nChecks if the matrix is approximately diagonal.\n\nArgs:\n  cutoff(float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `sum(digonal_elements)*cutoff > sum(nondiagonal_elements)`.\n  False otherwise.")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(cutoff:float=default) -> bool\n\nChecks if the matrix is identity-like.\n\nChecks if `max(M - I) <= cutoff` where `I` is a matrix with the same\nsize as `M`, ones on the diagonal and zeros elsewhere.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `max(M - I) <= cutoff`.\n\nNote:\n  The matrix does not have to be square.")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if the elements are all zeros.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `max(abs(M)) <= cutoff`.")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nReturns the Frobenius norm of the matrix")},
  {C("_approx_equal"), (PyCFunction)wrapApproxEqual_as__approx_equal, METH_VARARGS | METH_KEYWORDS, C("_approx_equal(other:MatrixBase, tol:float=default) -> bool\n\nChecks if matrices are approximately equal.\n\nChecks if `self` is equal to `other` by calculating the Frobenius\nnorm of their difference.\n\nArgs:\n  other (Matrix): The matrix to check against.\n  tol (float): The tolerance for equality check. Defaults to ``0.01``.\n\nReturns:\n  True if `||(self-other)||_F <= tol * ||self||_F`. False otherwise.")},
  {C("equal"), (PyCFunction)wrapEqual_as_equal, METH_VARARGS | METH_KEYWORDS, C("equal(other:MatrixBase) -> bool\n\nChecks if matrices are exactly equal.\n\nArgs:\n  other (Matrix): The matrix to check against\n\nReturns:\n  True if `self[i,j] == other[i,j]`` for all `i,j`. False otherwise.")},
  {C("largest_abs_elem"), (PyCFunction)wrapLargestAbsElem_as_largest_abs_elem, METH_NOARGS, C("largest_abs_elem() -> float\n\nReturns the largest of the absolute values of the elements.")},
  {C("log_sum_exp"), (PyCFunction)wrapLogSumExp_as_log_sum_exp, METH_VARARGS | METH_KEYWORDS, C("log_sum_exp(prune:float=default) -> float\n\nComputes :math:`f(M)=\\log(\\sum_{i,j} \\exp(M_{i,j}))` without exp overflow.\n\nIf `prune > 0.0`, ignores terms less than `max(M) - prune`.\n\nArgs:\n  prune (float): The pruning beam. Defaults to `-1.0`.\n\nReturns:\n  :math:`\\log(\\sum_{i,j} \\exp(M_{i,j}))`.")},
  {C("apply_softmax_"), (PyCFunction)wrapApplySoftMax_as_apply_softmax_, METH_NOARGS, C("apply_softmax_() -> float\n\nApplies the softmax operation to each element.\n\nPerforms the operation\n:math:`M_{i,j} = \\frac{\\exp(M_{i,j})}{\\sum_{k,j} \\exp(M_{k,j})}`.\n\nReturns:\n  :math:`\\log(\\sum_{k,j} \\exp(M_{k,j}))`.")},
  {C("sigmoid_"), (PyCFunction)wrapSigmoid_as_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("sigmoid_(src:MatrixBase)\n\nApplies sigmoid function to elements of another matrix.\n\nArgs:\n  src (Matrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("heaviside_"), (PyCFunction)wrapHeaviside_as_heaviside_, METH_VARARGS | METH_KEYWORDS, C("heaviside_(src:MatrixBase)\n\nApplies Heaviside step function to elements of another matrix.\n\nArgs:\n  src (Matrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("soft_hinge_"), (PyCFunction)wrapSoftHinge_as_soft_hinge_, METH_VARARGS | METH_KEYWORDS, C("soft_hinge_(src:MatrixBase)\n\nApplies soft hinge function to elements of another matrix.\n\nPerforms the operation `M[i,j] = log(1 + exp(src[i,j]))`.\n\nArgs:\n  src (Matrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("group_pnorm_"), (PyCFunction)wrapGroupPnorm_as_group_pnorm_, METH_VARARGS | METH_KEYWORDS, C("group_pnorm_(src:MatrixBase, power:float)\n\nComputes group p-norm of elements in another matrix.\n\nPerforms the operation `self[i,j] = norm(src[i,j*gs:(j+1)*gs], power)`\nwhere `gs = src.num_cols / self.num_cols`.\n\nArgs:\n  src (Matrix): The source matrix.\n  power (float): The p value for p-norm. It must be non-negative.\n\nRaises:\n  RuntimeError: If `src.num_rows != self.num_rows`\n                or `src.num_rows % self.num_rows != 0`.")},
  {C("group_pnorm_deriv_"), (PyCFunction)wrapGroupPnormDeriv_as_group_pnorm_deriv_, METH_VARARGS | METH_KEYWORDS, C("group_pnorm_deriv_(input:MatrixBase, output:MatrixBase, power:float)\n\nComputes derivatives for the group p-norm operation.\n\nArgs:\n  input (Matrix): The input to group p-norm operation (src in\n    :meth:`group_pnorm_`).\n  output (Matrix): The output of group p-norm operation.\n  power (float): The p value for p-norm. It must be non-negative.")},
  {C("group_max_"), (PyCFunction)wrapGroupMax_as_group_max_, METH_VARARGS | METH_KEYWORDS, C("group_max_(src:MatrixBase)\n\nComputes group max of elements in another matrix.\n\nPerforms the operation `self[i,j] = max(src[i,j*gs:(j+1)*gs])`\nwhere `gs = src.num_cols / self.num_cols`.\n\nArgs:\n  src (MatrixBase): The source matrix.\n\nRaises:\n  RuntimeError: If `src.num_rows != self.num_rows`\n                or `src.num_rows % self.num_rows != 0`.")},
  {C("group_max_deriv_"), (PyCFunction)wrapGroupMaxDeriv_as_group_max_deriv_, METH_VARARGS | METH_KEYWORDS, C("group_max_deriv_(input:MatrixBase, output:MatrixBase)\n\nComputes derivatives for the group max operation.\n\nArgs:\n  input (Matrix): The input to group max operation (src in\n    :meth:`group_max_`).\n  output (Matrix): The output of group max operation.")},
  {C("tanh_"), (PyCFunction)wrapTanh_as_tanh_, METH_VARARGS | METH_KEYWORDS, C("tanh_(src:MatrixBase)\n\nApplies tanh function to elements of another matrix.\n\nArgs:\n  src (Matrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("diff_sigmoid_"), (PyCFunction)wrapDiffSigmoid_as_diff_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("diff_sigmoid_(value:MatrixBase, diff:MatrixBase)\n\nBackpropagates derivatives through the sigmoid function.\n\nPerforms the operation\n`M[i,j] = diff[i,j] * value[i,j] * (1 - value[i,j])`.\n\nArgs:\n  value (Matrix): The activations.\n  diff (Matrix): The derivatives.")},
  {C("diff_tanh_"), (PyCFunction)wrapDiffTanh_as_diff_tanh_, METH_VARARGS | METH_KEYWORDS, C("diff_tanh_(value:MatrixBase, diff:MatrixBase)\n\nBackpropagates derivatives through the tanh function.\n\nPerforms the operation `M[i,j] = diff[i,j] * (1 - value[i,j]^2)`.\n\nArgs:\n  value (Matrix): The activations.\n  diff (Matrix): The derivatives.")},
  {C("sym_pos_semi_def_eig"), (PyCFunction)wrapSymPosSemiDefEig_as_sym_pos_semi_def_eig, METH_VARARGS | METH_KEYWORDS, C("sym_pos_semi_def_eig(s:VectorBase, P:MatrixBase, check_thresh:float=default)\n\nComputes eigendecomposition of a positive semi-definite matrix.\n\nUses SVD to compute the eigendecomposition of a symmetric positive\nsemi-definite matrix: :math:`M = P\\ diag(s) \\ P^T`, where :math:`P`\nis an orthogonal matrix, i.e. :math:`P^{-1} = P^T`.\n\nArgs:\n  s (Vector): The eigenvalue vector.\n  P (Matrix): The eigenvector matrix.\n  check_thresh (float): The threshold used for checking if input is\n    positive semi-definite. Defaults to ``0.001``.\n\nNote:\n  Set check_thresh to 2 to ensure the positive semi-definite check\n  won't ever complain, however it will zero out negative dimensions\n  in the matrix.\n\nRaises:\n  RuntimeError: If input is not positive semi-definite.")},
  {C("add_"), (PyCFunction)wrapAdd_as_add_, METH_VARARGS | METH_KEYWORDS, C("add_(alpha:float)\n\nAdds a scalar to each element of the matrix.\n\nArgs:\n  alpha(float): The scalar to add.")},
  {C("add_to_diag_"), (PyCFunction)wrapAddToDiag_as_add_to_diag_, METH_VARARGS | METH_KEYWORDS, C("add_to_diag_(alpha:float)\n\nAdds a scalar to the diagonal elements of the matrix.\n\nArgs:\n  alpha (float): The scalar to add.")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, a:VectorBase, b:VectorBase)\n\nAdds outer product of input vectors to this matrix.\n\nPerforms the operation :math:`M = M + \\alpha\\ a \\ b^T`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  a (Vector): The first input vector.\n  b (Vector): The second input vector.")},
  {C("add_vec_to_rows_"), (PyCFunction)wrapAddVecToRows_as_add_vec_to_rows_, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_rows_(alpha:float, v:VectorBase)\n\nAdds input vector to each row of this matrix.\n\nPerforms the operation :math:`M_{ij} = M_{ij} + \\alpha\\ v_{j}`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_vec_to_cols_"), (PyCFunction)wrapAddVecToCols_as_add_vec_to_cols_, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_cols_(alpha:float, v:VectorBase)\n\nAdds input vector to each column of this matrix.\n\nPerforms the operation :math:`M_{ij} = M_{ij} + \\alpha\\ v_{i}`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_"), (PyCFunction)wrapAddMat_as__add_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_(alpha:float, M:MatrixBase, transM:MatrixTransposeType=default)\n\nAdds given matrix to this one.\n\nPerforms the operation :math:`S += \\alpha\\ M`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  M (Matrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sym_add_mat2_"), (PyCFunction)wrapSymAddMat2_as_sym_add_mat2_, METH_VARARGS | METH_KEYWORDS, C("sym_add_mat2_(alpha:float, M:MatrixBase, transA:MatrixTransposeType, beta:float)\n\nAdds the square of given matrix to this one.\n\nPerforms the operation on symmetric matrices\n:math:`S = \\alpha\\ M\\ M^T + \\beta\\ S`.\n\nNote:\n  It only updates the lower triangle of self. It will leave the\n  matrix asymmetric. If you need it symmetric as a regular matrix,\n  call :meth:`copy_lower_to_upper_` after this operation.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`M\\ M^T`.\n  M (Matrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_diag_vec_mat_"), (PyCFunction)wrapAddDiagVecMat_as_add_diag_vec_mat_, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_mat_(alpha:float, v:VectorBase, M:MatrixBase, transM:MatrixTransposeType, beta:float=default)\n\nAdds given matrix to this one after scaling its rows.\n\nPerform the operation :math:`S = \\alpha\\ diag(v)\\ M + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`diag(v) M`.\n  v (Vector): The scaling vector.\n  M (Matrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  beta (float): The scalar multiplier for the destination matrix.\n    Defaults to ``1.0``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_diag_vec_"), (PyCFunction)wrapAddMatDiagVec_as_add_mat_diag_vec_, METH_VARARGS | METH_KEYWORDS, C("add_mat_diag_vec_(alpha:float, M:MatrixBase, transM:MatrixTransposeType, v:VectorBase, beta:float=default)\n\nAdds given matrix to this one after scaling its columns.\n\nPerform the operation :math:`S = \\alpha\\ M\\ diag(v) + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`M\\ diag(v)`.\n  M (Matrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  v (Vector): The scaling vector.\n  beta (float): The scalar multiplier for the destination matrix.\n    Defaults to ``1.0``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_mat_elements_"), (PyCFunction)wrapAddMatMatElements_as_add_mat_mat_elements_, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_elements_(alpha:float, A:MatrixBase, B:MatrixBase, beta:float)\n\nAdds the element-wise multiplication of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\odot B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A \\odot B`.\n  A (Matrix): The first input matrix.\n  B (Matrix): The second input matrix.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_mat_"), (PyCFunction)wrapAddMatMat_as__add_mat_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (Matrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("set_mat_mat_div_mat_"), (PyCFunction)wrapSetMatMatDivMat_as_set_mat_mat_div_mat_, METH_VARARGS | METH_KEYWORDS, C("set_mat_mat_div_mat_(A:MatrixBase, B:MatrixBase, C:MatrixBase)\n\nComputes an elementwise multiplication followed by division.\n\nPerforms the operation :math:`S = A \\odot B \\oslash C` where\n:math:`\\odot` and :math:`\\oslash` are elementwise multiplication and\ndivision. If :math:`C[i,j] == 0` then :math:`S[i,j]` remains intact.\n\nArgs:\n  A (Matrix): The first input matrix.\n  B (Matrix): The second input matrix.\n  C (Matrix): The third input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_smat_"), (PyCFunction)wrapAddMatSmat_as__add_mat_smat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_smat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (Matrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nNote:\n  This opearation is like :meth:`add_mat_mat_` but optimized for\n  sparse **B**.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_smat_mat_"), (PyCFunction)wrapAddSmatMat_as__add_smat_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_smat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (Matrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nNote:\n  This opearation is like :meth:`add_mat_mat_` but optimized for\n  sparse **A**.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_mat_mat_"), (PyCFunction)wrapAddMatMatMat_as_add_mat_mat_mat_, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_mat_(alpha:float, A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType, beta:float)\n\nAdds the product of three matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B\\ C + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B\\ C`.\n  A (Matrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (Matrix): The third input matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_lower_to_upper_"), (PyCFunction)wrapCopyLowerToUpper_as_copy_lower_to_upper_, METH_NOARGS, C("copy_lower_to_upper_()\n\nCopies lower triangle to upper triangle.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("copy_upper_to_lower_"), (PyCFunction)wrapCopyUpperToLower_as_copy_upper_to_lower_, METH_NOARGS, C("copy_upper_to_lower_()\n\nCopies upper triangle to lower triangle.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("orthogonalize_rows_"), (PyCFunction)wrapOrthogonalizeRows_as_orthogonalize_rows_, METH_NOARGS, C("orthogonalize_rows_()\n\nOrthogonalizes rows using the Gram-Schmidt process.\n\nUses random number generation to fill in rows with something non-zero,\nin cases where the original matrix was of deficient row rank.\n\nRaises:\n  RuntimeError: If `self.num_rows > self.num_cols`.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the matrix from the given C++ stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read matrix.\n    Defaults to ``False``.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the matrix to given C++ stream.\n\nArgs:\n    os (ostream): The output C++ straem.\n    binary (bool): Whether the stream is binary.")},
  {}
};

// MatrixBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// MatrixBase __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_matrix.MatrixBase",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Base class for single precision matrices.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::MatrixBase<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_MatrixBase_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::MatrixBase<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::MatrixBase<float>* c = static_cast<::kaldi::MatrixBase<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::MatrixBase<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrixBase

namespace pyMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Matrix<float>> cpp;
};
static ::kaldi::Matrix<float>* ThisPtr(PyObject*);

// @classmethod from_size(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> Matrix
static PyObject* wrapMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("r"),
      C("c"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:from_size", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("from_size", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_size", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_size", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Matrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<float>>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<float>>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<float>>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:Matrix)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::Matrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::Matrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::Matrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_matrix(M:MatrixBase, trans:MatrixTransposeType=default) -> Matrix
static PyObject* wrapMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Matrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<float>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<float>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::Matrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _remove_row_(index:int)
static PyObject* wrapRemoveRow_as__remove_row_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_row_", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_row_", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::Matrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->RemoveRow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// transpose_()
static PyObject* wrapTranspose_as_transpose_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Matrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// resize_(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("r"),
      C("c"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:resize_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("resize_", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize_", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("resize_", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  ::kaldi::Matrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// Implicit cast this as ::kaldi::MatrixBase<float>*
static PyObject* as_kaldi_MatrixBase_float(PyObject* self) {
  ::kaldi::MatrixBase<float>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::MatrixBase<float>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> Matrix\n\nCreates a new matrix of given size.\n\nArgs:\n  r (int): The number or rows.\n  c (int): The number or columns.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or ``MatrixResizeType.COPY_DATA``,\n    they are set to zero. If ``MatrixResizeType.UNDEFINED``, they are\n    left uninitialized. Defaults to ``MatrixResizeType.SET_ZERO``.\n  stride_type(MatrixStrideType): Determines how the elements are laid\n    out in memory. If ``MatrixStrideType.STRIDE_EQUAL_NUM_COLS``, the\n    stride is equal to the number of columns. If\n    ``MatrixStrideType.DEFAULT_STRIDE``, the stride is equal to the\n    smallest multiple of 16 that is larger than the number of columns.\n    Defaults to ``MatrixStrideType.DEFAULT_STRIDE``.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:Matrix)\n\nSwaps the contents of matrices.\n\nShallow swap.\n\nArgs:\n  other (Matrix): The matrix to swap contents with.")},
  {C("from_matrix"), (PyCFunction)wrapMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(M:MatrixBase, trans:MatrixTransposeType=default) -> Matrix\n\nCreates a new matrix from a given matrix.\n\nArgs:\n  M (Matrix): The input matrix.\n  trans (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the matrix from the given C++ stream.\n\nResizes the matrix to match the size of the matrix read from stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read matrix.\n    Defaults to ``False``.")},
  {C("_remove_row_"), (PyCFunction)wrapRemoveRow_as__remove_row_, METH_VARARGS | METH_KEYWORDS, C("_remove_row_(index:int)\n\nRemoves the row at the given index.\n\nArgs:\n  index (int): The row index.\n\nRaises:\n  RuntimeError: If `index >= num_rows`.")},
  {C("transpose_"), (PyCFunction)wrapTranspose_as_transpose_, METH_NOARGS, C("transpose_()\n\nTransposes the matrix.")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)\n\nResizes the matrix.\n\nArgs:\n  r (int): The new number of rows.\n  c (int): The new number of columns.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or ``MatrixResizeType.COPY_DATA``,\n    they are set to zero. If ``MatrixResizeType.UNDEFINED``, they are\n    left uninitialized. Defaults to ``MatrixResizeType.SET_ZERO``.\n  stride_type(MatrixStrideType): Determines how the elements are laid\n    out in memory. If ``MatrixStrideType.STRIDE_EQUAL_NUM_COLS``, the\n    stride is equal to the number of columns. If\n    ``MatrixStrideType.DEFAULT_STRIDE``, the stride is equal to the\n    smallest multiple of 16 that is larger than the number of columns.\n    Defaults to ``MatrixStrideType.DEFAULT_STRIDE``.")},
  {C("as_kaldi_MatrixBase_float"), (PyCFunction)as_kaldi_MatrixBase_float, METH_NOARGS, C("Upcast to ::kaldi::MatrixBase<float>*")},
  {}
};

// Matrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Matrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Matrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_matrix.Matrix",              // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Single precision matrix.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Matrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Matrix<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Matrix<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Matrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Matrix<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::Matrix<float>* c = static_cast<::kaldi::Matrix<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Matrix<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyMatrix

// _trace_mat(A:MatrixBase) -> float
static PyObject* wrapTraceMat_as__trace_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_trace_mat", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_mat_mat(A:MatrixBase, B:MatrixBase, trans:MatrixTransposeType=default) -> float
static PyObject* wrapTraceMatMat_as__trace_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_trace_mat_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_mat", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::TraceMatMat(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::TraceMatMat(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_mat_mat_mat(A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType) -> float
static PyObject* wrapTraceMatMatMat_as__trace_mat_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_trace_mat_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_mat_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_mat_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_mat_mat", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_mat_mat_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_mat_mat_mat", names[4], "::kaldi::MatrixBase<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_mat_mat_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatMatMat(*arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_mat_mat_mat_mat(A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType, D:MatrixBase, transD:MatrixTransposeType) -> float
static PyObject* wrapTraceMatMatMatMat_as__trace_mat_mat_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      C("D"),
      C("transD"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:_trace_mat_mat_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_mat_mat_mat_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_mat_mat_mat_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::MatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_mat_mat_mat_mat", names[2], "::kaldi::MatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_mat_mat_mat_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_mat_mat_mat_mat", names[4], "::kaldi::MatrixBase<float>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_mat_mat_mat_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  ::kaldi::MatrixBase<float>* arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_trace_mat_mat_mat_mat", names[6], "::kaldi::MatrixBase<float>", a[6]);
  ::kaldi::MatrixTransposeType arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("_trace_mat_mat_mat_mat", names[7], "::kaldi::MatrixTransposeType", a[7]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatMatMatMat(*arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), *arg7, std::move(arg8));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal_matrix(A:MatrixBase, B:MatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_approx_equal_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal_matrix", names[1], "::kaldi::MatrixBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_approx_equal_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _assert_equal_matrix(A:MatrixBase, B:MatrixBase, tol:float=default)
static PyObject* wrapAssertEqual_as__assert_equal_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_assert_equal_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assert_equal_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assert_equal_matrix", names[1], "::kaldi::MatrixBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_assert_equal_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _sort_svd(s:VectorBase, U:MatrixBase, Vt:MatrixBase=default, sort_on_absolute_value:bool=default)
static PyObject* wrapSortSvd_as__sort_svd(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      C("sort_on_absolute_value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:_sort_svd", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_sort_svd", names[0], "::kaldi::VectorBase<float> *", a[0]);
  ::kaldi::MatrixBase<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_sort_svd", names[1], "::kaldi::MatrixBase<float> *", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("_sort_svd", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_sort_svd", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_sort_svd", names[3], "bool", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::SortSvd(arg1, arg2); break;
  case 3:
    ::kaldi::SortSvd(arg1, arg2, arg3); break;
  case 4:
    ::kaldi::SortSvd(arg1, arg2, arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _create_eigenvalue_matrix(real:VectorBase, imag:VectorBase, D:MatrixBase)
static PyObject* wrapCreateEigenvalueMatrix_as__create_eigenvalue_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("real"),
      C("imag"),
      C("D"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_create_eigenvalue_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_create_eigenvalue_matrix", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_create_eigenvalue_matrix", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::MatrixBase<float> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_create_eigenvalue_matrix", names[2], "::kaldi::MatrixBase<float> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CreateEigenvalueMatrix(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _same_dim_matrix(M:MatrixBase, N:MatrixBase) -> bool
static PyObject* wrapSameDim_as__same_dim_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_same_dim_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_same_dim_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_same_dim_matrix", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDim(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyDoubleMatrixBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::MatrixBase<double>> cpp;
};
static ::kaldi::MatrixBase<double>* ThisPtr(PyObject*);

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_num_rows(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumRows(), {});
}

static PyObject* get_num_cols(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->NumCols(), {});
}

static PyObject* get_stride(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Stride(), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _getitem(row:int, col:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("row"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _setitem_(row:int, col:int, value:float)
static PyObject* wrapSet_as__setitem_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("row"),
      C("col"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_setitem_", names, &a[0], &a[1], &a[2])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_setitem_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_setitem_", names[1], "int", a[1]);
  double arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_setitem_", names[2], "double", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1), std::move(arg2), std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_zero_()
static PyObject* wrapSetZero_as_set_zero_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_unit_()
static PyObject* wrapSetUnit_as_set_unit_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetUnit();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_randn_()
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_rand_uniform_()
static PyObject* wrapSetRandUniform_as_set_rand_uniform_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _copy_from_mat_(M:DoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as__copy_from_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_copy_from_mat_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_copy_from_mat_", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_rows_from_vec_(v:DoubleVectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_cols_from_vec_(v:DoubleVectorBase)
static PyObject* wrapCopyColsFromVec_as_copy_cols_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_cols_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_col_from_vec_(v:DoubleVectorBase, col:int)
static PyObject* wrapCopyColFromVec_as_copy_col_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_col_from_vec_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_col_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_col_from_vec_", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_row_from_vec_(v:DoubleVectorBase, row:int)
static PyObject* wrapCopyRowFromVec_as_copy_row_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("row"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_row_from_vec_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_row_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_row_from_vec_", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_diag_from_vec_(v:DoubleVectorBase)
static PyObject* wrapCopyDiagFromVec_as_copy_diag_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_diag_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_diag_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyDiagFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace(check_square:bool=default) -> float
static PyObject* wrapTrace_as_trace(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("check_square"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:trace", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("trace", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->Trace(); break;
  case 1:
    ret0 = c->Trace(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// mul_elements_(A:DoubleMatrixBase)
static PyObject* wrapMulElements_as_mul_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_elements_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_elements_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// div_elements_(A:DoubleMatrixBase)
static PyObject* wrapDivElements_as_div_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_elements_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_elements_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max_with_mat_(A:DoubleMatrixBase)
static PyObject* wrapMax_as_max_with_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:max_with_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("max_with_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Max(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// min_with_mat_(A:DoubleMatrixBase)
static PyObject* wrapMin_as_min_with_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:min_with_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("min_with_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Min(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_cols_vec_(scale:DoubleVectorBase)
static PyObject* wrapMulColsVec_as_mul_cols_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_cols_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_cols_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulColsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_rows_vec_(scale:DoubleVectorBase)
static PyObject* wrapMulRowsVec_as_mul_rows_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// mul_rows_group_mat_(src:DoubleMatrixBase)
static PyObject* wrapMulRowsGroupMat_as_mul_rows_group_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_group_mat_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_group_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsGroupMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// log_det() -> (log_det:float, det_sign:float)
static PyObject* wrapLogDet_as_log_det(PyObject* self) {
  double ret1{};
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LogDet(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// invert_elements_()
static PyObject* wrapInvertElements_as_invert_elements_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// transpose_()
static PyObject* wrapTranspose_as_transpose_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_(floor:float)
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_ceiling_(ceiling:float)
static PyObject* wrapApplyCeiling_as_apply_ceiling_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_()
static PyObject* wrapApplyLog_as_apply_log_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_exp_()
static PyObject* wrapApplyExp_as_apply_exp_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_(power:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_abs_(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs_", names[0], "double", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs_", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_heaviside_()
static PyObject* wrapApplyHeaviside_as_apply_heaviside_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyHeaviside();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _eig(P:DoubleMatrixBase, eigs_real:DoubleVectorBase, eigs_imag:DoubleVectorBase)
static PyObject* wrapEig_as__eig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("P"),
      C("eigs_real"),
      C("eigs_imag"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_eig", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_eig", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::VectorBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_eig", names[1], "::kaldi::VectorBase<double> *", a[1]);
  ::kaldi::VectorBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_eig", names[2], "::kaldi::VectorBase<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Eig(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// power_(pow:float) -> bool
static PyObject* wrapPower_as_power_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("pow"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:power_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("power_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Power(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _destructive_svd_(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase)
static PyObject* wrapDestructiveSvd_as__destructive_svd_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_destructive_svd_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_destructive_svd_", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_destructive_svd_", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_destructive_svd_", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DestructiveSvd(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _svd(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase)
static PyObject* wrapSvd_as__svd(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_svd", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_svd", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_svd", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_svd", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Svd(arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _singular_values(s:DoubleVectorBase)
static PyObject* wrapSvd_as__singular_values(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("s"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_singular_values", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_singular_values", names[0], "::kaldi::VectorBase<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Svd(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// min_singular_value() -> float
static PyObject* wrapMinSingularValue_as_min_singular_value(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->MinSingularValue();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// cond() -> float
static PyObject* wrapCond_as_cond(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Cond();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_symmetric(cutoff:float=default) -> bool
static PyObject* wrapIsSymmetric_as_is_symmetric(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_symmetric", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_symmetric", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsSymmetric(); break;
  case 1:
    ret0 = c->IsSymmetric(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_diagonal(cutoff:float=default) -> bool
static PyObject* wrapIsDiagonal_as_is_diagonal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_diagonal", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_diagonal", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsDiagonal(); break;
  case 1:
    ret0 = c->IsDiagonal(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(cutoff:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal(other:DoubleMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal", names[0], "::kaldi::MatrixBase<double>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// equal(other:DoubleMatrixBase) -> bool
static PyObject* wrapEqual_as_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:equal", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equal", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Equal(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// largest_abs_elem() -> float
static PyObject* wrapLargestAbsElem_as_largest_abs_elem(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->LargestAbsElem();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_sum_exp(prune:float=default) -> float
static PyObject* wrapLogSumExp_as_log_sum_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("prune"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:log_sum_exp", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_sum_exp", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LogSumExp(); break;
  case 1:
    ret0 = c->LogSumExp(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_softmax_() -> float
static PyObject* wrapApplySoftMax_as_apply_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplySoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sigmoid_(src:DoubleMatrixBase)
static PyObject* wrapSigmoid_as_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// heaviside_(src:DoubleMatrixBase)
static PyObject* wrapHeaviside_as_heaviside_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:heaviside_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("heaviside_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Heaviside(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// soft_hinge_(src:DoubleMatrixBase)
static PyObject* wrapSoftHinge_as_soft_hinge_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:soft_hinge_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("soft_hinge_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SoftHinge(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_pnorm_(src:DoubleMatrixBase, power:float)
static PyObject* wrapGroupPnorm_as_group_pnorm_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_pnorm_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm_", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnorm(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_pnorm_deriv_(input:DoubleMatrixBase, output:DoubleMatrixBase, power:float)
static PyObject* wrapGroupPnormDeriv_as_group_pnorm_deriv_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("input"),
      C("output"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:group_pnorm_deriv_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm_deriv_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm_deriv_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  double arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("group_pnorm_deriv_", names[2], "double", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnormDeriv(*arg1, *arg2, std::move(arg3));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_max_(src:DoubleMatrixBase)
static PyObject* wrapGroupMax_as_group_max_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:group_max_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMax(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// group_max_deriv_(input:DoubleMatrixBase, output:DoubleMatrixBase)
static PyObject* wrapGroupMaxDeriv_as_group_max_deriv_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input"),
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_max_deriv_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_deriv_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_max_deriv_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMaxDeriv(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// tanh_(src:DoubleMatrixBase)
static PyObject* wrapTanh_as_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh_", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// diff_sigmoid_(value:DoubleMatrixBase, diff:DoubleMatrixBase)
static PyObject* wrapDiffSigmoid_as_diff_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_sigmoid_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_sigmoid_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_sigmoid_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSigmoid(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// diff_tanh_(value:DoubleMatrixBase, diff:DoubleMatrixBase)
static PyObject* wrapDiffTanh_as_diff_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_tanh_", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_tanh_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_tanh_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffTanh(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sym_pos_semi_def_eig(s:DoubleVectorBase, P:DoubleMatrixBase, check_thresh:float=default)
static PyObject* wrapSymPosSemiDefEig_as_sym_pos_semi_def_eig(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("s"),
      C("P"),
      C("check_thresh"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:sym_pos_semi_def_eig", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_pos_semi_def_eig", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_pos_semi_def_eig", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_pos_semi_def_eig", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->SymPosSemiDefEig(arg1, arg2); break;
  case 3:
    c->SymPosSemiDefEig(arg1, arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_(alpha:float)
static PyObject* wrapAdd_as_add_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_to_diag_(alpha:float)
static PyObject* wrapAddToDiag_as_add_to_diag_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_to_diag_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_diag_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToDiag(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, a:DoubleVectorBase, b:DoubleVectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("a"),
      C("b"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec_", names, &a[0], &a[1], &a[2])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_to_rows_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVecToRows_as_add_vec_to_rows_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec_to_rows_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_rows_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_rows_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecToRows(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_to_cols_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVecToCols_as_add_vec_to_cols_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_vec_to_cols_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_cols_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_cols_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecToCols(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType=default)
static PyObject* wrapAddMat_as__add_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_add_mat_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMat(std::move(arg1), *arg2); break;
  case 3:
    c->AddMat(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sym_add_mat2_(alpha:float, M:DoubleMatrixBase, transA:MatrixTransposeType, beta:float)
static PyObject* wrapSymAddMat2_as_sym_add_mat2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transA"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:sym_add_mat2_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_add_mat2_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_add_mat2_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_add_mat2_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("sym_add_mat2_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymAddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_diag_vec_mat_(alpha:float, v:DoubleVectorBase, M:DoubleMatrixBase, transM:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagVecMat_as_add_diag_vec_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("v"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_diag_vec_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_mat_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_mat_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_diag_vec_mat_", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_diag_vec_mat_", names[3], "::kaldi::MatrixTransposeType", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_diag_vec_mat_", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4)); break;
  case 5:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_diag_vec_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, v:DoubleVectorBase, beta:float=default)
static PyObject* wrapAddMatDiagVec_as_add_mat_diag_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_diag_vec_", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_diag_vec_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_diag_vec_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_diag_vec_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::VectorBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_diag_vec_", names[3], "::kaldi::VectorBase<double>", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_diag_vec_", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_mat_elements_(alpha:float, A:DoubleMatrixBase, B:DoubleMatrixBase, beta:float)
static PyObject* wrapAddMatMatElements_as_add_mat_mat_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat_mat_elements_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_elements_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_elements_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_elements_", names[2], "::kaldi::MatrixBase<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_elements_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatElements(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMat_as__add_mat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_mat_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_mat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_mat_", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_mat_", names[5], "double", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_mat_mat_div_mat_(A:DoubleMatrixBase, B:DoubleMatrixBase, C:DoubleMatrixBase)
static PyObject* wrapSetMatMatDivMat_as_set_mat_mat_div_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("A"),
      C("B"),
      C("C"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:set_mat_mat_div_mat_", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_mat_mat_div_mat_", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_mat_mat_div_mat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("set_mat_mat_div_mat_", names[2], "::kaldi::MatrixBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetMatMatDivMat(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_mat_smat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatSmat_as__add_mat_smat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_mat_smat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_mat_smat_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_mat_smat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_mat_smat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_mat_smat_", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_mat_smat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_mat_smat_", names[5], "double", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatSmat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_smat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddSmatMat_as__add_smat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_add_smat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_smat_mat_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_smat_mat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_add_smat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_add_smat_mat_", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_add_smat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_add_smat_mat_", names[5], "double", a[5]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddSmatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_mat_mat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMatMat_as_add_mat_mat_mat_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:add_mat_mat_mat_", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_mat_", names[0], "double", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_mat_", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_mat_", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::MatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_mat_", names[3], "::kaldi::MatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_mat_mat_", names[4], "::kaldi::MatrixTransposeType", a[4]);
  ::kaldi::MatrixBase<double>* arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("add_mat_mat_mat_", names[5], "::kaldi::MatrixBase<double>", a[5]);
  ::kaldi::MatrixTransposeType arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("add_mat_mat_mat_", names[6], "::kaldi::MatrixTransposeType", a[6]);
  double arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("add_mat_mat_mat_", names[7], "double", a[7]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), *arg6, std::move(arg7), std::move(arg8));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_lower_to_upper_()
static PyObject* wrapCopyLowerToUpper_as_copy_lower_to_upper_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyLowerToUpper();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// copy_upper_to_lower_()
static PyObject* wrapCopyUpperToLower_as_copy_upper_to_lower_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyUpperToLower();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// orthogonalize_rows_()
static PyObject* wrapOrthogonalizeRows_as_orthogonalize_rows_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->OrthogonalizeRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::MatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("num_rows"), get_num_rows, nullptr, C("Number of rows (zero for empty matrix).")},
  {C("num_cols"), get_num_cols, nullptr, C("Number of columns (zero for empty matrix).")},
  {C("stride"), get_stride, nullptr, C("Row stride (distance in memory between each row, >= num_cols).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n\nReturns the size (in bytes) of the data held by the matrix.")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(row:int, col:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  row (int): The row index of the element.\n  col (int): The column index of the element.\n\nReturns:\n  The element at the given index.")},
  {C("_setitem_"), (PyCFunction)wrapSet_as__setitem_, METH_VARARGS | METH_KEYWORDS, C("_setitem_(row:int, col:int, value:float)\n\nSets the element at the given index.\n\nArgs:\n  row (int): The row index of the element.\n  col (int): The column index of the element.\n  value (float): The value to set.")},
  {C("set_zero_"), (PyCFunction)wrapSetZero_as_set_zero_, METH_NOARGS, C("set_zero_()\n\nSets the elements to zero.")},
  {C("set_unit_"), (PyCFunction)wrapSetUnit_as_set_unit_, METH_NOARGS, C("set_unit_()\n\nSets diagonal elements to one, off-diagonal elements to zero.\n\nNote:\n  Works for non-square matrices too.")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_NOARGS, C("set_randn_()\n\nSets the elements to numbers from standard normal distribution.")},
  {C("set_rand_uniform_"), (PyCFunction)wrapSetRandUniform_as_set_rand_uniform_, METH_NOARGS, C("set_rand_uniform_()\n\nSets the elements to numbers uniformly distributed on (0,1).")},
  {C("_copy_from_mat_"), (PyCFunction)wrapCopyFromMat_as__copy_from_mat_, METH_VARARGS | METH_KEYWORDS, C("_copy_from_mat_(M:DoubleMatrixBase, trans:MatrixTransposeType=default)\n\nCopies the elements from another matrix.\n\nArgs:\n  M (DoubleMatrix): The input matrix.\n  trans (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_rows_from_vec_"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_vec_(v:DoubleVectorBase)\n\nCopies row elements from a vector.\n\nThis method has two modes of operation. If the number of elements in\n`self` and `v` are the same, then elements of `v` are copied into\n`self` row by row. If the number of elements in `v` is equal to\n`self.num_cols`, then the elements of `v` are copied into each row of\n`self`.\n\nArgs:\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_cols_from_vec_"), (PyCFunction)wrapCopyColsFromVec_as_copy_cols_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_cols_from_vec_(v:DoubleVectorBase)\n\nCopies column elements from a vector.\n\nThis method has two modes of operation. If the number of elements in\n`self` and `v` are the same, then elements of `v` are copied into\n`self` column by column. If the number of elements in `v` is equal to\n`self.num_rows`, then the elements of `v` are copied into each column\nof `self`.\n\nArgs:\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_col_from_vec_"), (PyCFunction)wrapCopyColFromVec_as_copy_col_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_col_from_vec_(v:DoubleVectorBase, col:int)\n\nCopies a vector into the specified column.\n\nArgs:\n  v (DoubleVector): The input vector.\n  col (int): The column index.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_row_from_vec_"), (PyCFunction)wrapCopyRowFromVec_as_copy_row_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_row_from_vec_(v:DoubleVectorBase, row:int)\n\nCopies a vector into the specified row.\n\nArgs:\n  v (DoubleVector): The input vector.\n  row (int): The row index.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_diag_from_vec_"), (PyCFunction)wrapCopyDiagFromVec_as_copy_diag_from_vec_, METH_VARARGS | METH_KEYWORDS, C("copy_diag_from_vec_(v:DoubleVectorBase)\n\nCopies a vector into the diagonal.\n\nArgs:\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elements.")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_VARARGS | METH_KEYWORDS, C("trace(check_square:bool=default) -> float\n\nReturns the trace.\n\nIf matrix is not square it will return the trace of the square matrix\nformed from the minimum dimension, e.g. if the matrix is 3x5 it will\nreturn the trace of the 3x3 submatrix at the beginning.\n\nArgs:\n  check_square(bool): Check if the matrix is square.\n    Defaults to ``True``.\n\nRaises:\n  RuntimeError: If the matrix is not square and\n  **check_square** is ``True``.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n\nReturns the maximum value in the matrix.")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n\nReturns the minimum value in the matrix.")},
  {C("mul_elements_"), (PyCFunction)wrapMulElements_as_mul_elements_, METH_VARARGS | METH_KEYWORDS, C("mul_elements_(A:DoubleMatrixBase)\n\nMultiplies element-wise with another matrix.\n\nPerforms the operation `M = M \\odot A`.\n\nArgs:\n  A (DoubleMatrix): The multiplier.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("div_elements_"), (PyCFunction)wrapDivElements_as_div_elements_, METH_VARARGS | METH_KEYWORDS, C("div_elements_(A:DoubleMatrixBase)\n\nDivides element-wise with another matrix.\n\nPerforms the operation `M = M \\oslash A`.\n\nArgs:\n  A (DoubleMatrix): The denominator.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScales the matrix.\n\nArgs:\n  alpha (float): The scalar multiplier.")},
  {C("max_with_mat_"), (PyCFunction)wrapMax_as_max_with_mat_, METH_VARARGS | METH_KEYWORDS, C("max_with_mat_(A:DoubleMatrixBase)\n\nApplies an element-wise max operation.\n\nPerforms the operation `M[i,j] = max(M[i,j], A[i,j])`.\n\nArgs:\n  A (DoubleMatrix): The input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("min_with_mat_"), (PyCFunction)wrapMin_as_min_with_mat_, METH_VARARGS | METH_KEYWORDS, C("min_with_mat_(A:DoubleMatrixBase)\n\nApplies an element-wise min operation.\n\nPerforms the operation `M[i,j] = min(M[i,j], A[i,j])`.\n\nArgs:\n  A (DoubleMatrix): The input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_cols_vec_"), (PyCFunction)wrapMulColsVec_as_mul_cols_vec_, METH_VARARGS | METH_KEYWORDS, C("mul_cols_vec_(scale:DoubleVectorBase)\n\nScales columns with the elements in a vector.\n\nPerforms the operation `M[i,j] = scale[j] * M[i,j]`.\n\nArgs:\n  scale (DoubleVector): The scaling vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_rows_vec_"), (PyCFunction)wrapMulRowsVec_as_mul_rows_vec_, METH_VARARGS | METH_KEYWORDS, C("mul_rows_vec_(scale:DoubleVectorBase)\n\nScales rows with the elements in a vector.\n\nPerforms the operation `M[i,j] = scale[i] * M[i,j]`.\n\nArgs:\n  scale (DoubleVector): The scaling vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("mul_rows_group_mat_"), (PyCFunction)wrapMulRowsGroupMat_as_mul_rows_group_mat_, METH_VARARGS | METH_KEYWORDS, C("mul_rows_group_mat_(src:DoubleMatrixBase)\n\nScales matrix with another matrix.\n\nDivides each row of `self` into `src.num_cols` equal groups, and then\nscales `i`th row's `j`th group of elements with `src[i,j]`.\n\nArgs:\n  src (DoubleMatrix): The scaling matrix.\n\nRaises:\n  RuntimeError: If `self.num_rows != src.num_rows` or\n    `self.num_cols % src.num_cols != 0`.")},
  {C("log_det"), (PyCFunction)wrapLogDet_as_log_det, METH_NOARGS, C("log_det() -> (log_det:float, det_sign:float)\n\nComputes log determinant of the matrix.\n\nReturns:\n  2-element tuple containing\n\n  - **log_det** (:class:`float`): The log determinant.\n  - **det_sign** (:class:`float`): The sign of the determinant, 1 or -1.")},
  {C("invert_elements_"), (PyCFunction)wrapInvertElements_as_invert_elements_, METH_NOARGS, C("invert_elements_()\n\nInverts the elements.")},
  {C("transpose_"), (PyCFunction)wrapTranspose_as_transpose_, METH_NOARGS, C("transpose_()\n\nTransposes the matrix.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float)\n\nApplies floor operation to each element.\n\nPerforms the operation `M[i,j] = max(M[i,j], floor)`.\n\nArgs:\n  floor (float): The floor value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_ceiling_"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling_, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling_(ceiling:float)\n\nApplies ceiling operation to each element.\n\nPerforms the operation `M[i,j] = min(M[i,j], ceiling)`.\n\nArgs:\n  ceiling (float): The ceiling value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_log_"), (PyCFunction)wrapApplyLog_as_apply_log_, METH_NOARGS, C("apply_log_()\n\nApplies natural log operation to each element.")},
  {C("apply_exp_"), (PyCFunction)wrapApplyExp_as_apply_exp_, METH_NOARGS, C("apply_exp_()\n\nApplies exponential operation to each element.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(power:float)\n\nTakes each element to the given power.\n\nArgs:\n  power (float): The exponent value.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_pow_abs_"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs_(power:float, include_sign:bool=default)\n\nTakes the absolute value of each element raised to the given power.\n\nIf the power is negative and the input is zero, the output is zero.\n\nArgs:\n  power (float): The power value.\n  include_sign (bool): Whether to include the sign of the input value.\n    Defaults to ``False``.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_heaviside_"), (PyCFunction)wrapApplyHeaviside_as_apply_heaviside_, METH_NOARGS, C("apply_heaviside_()\n\nApplies the Heaviside step function to each element.")},
  {C("_eig"), (PyCFunction)wrapEig_as__eig, METH_VARARGS | METH_KEYWORDS, C("_eig(P:DoubleMatrixBase, eigs_real:DoubleVectorBase, eigs_imag:DoubleVectorBase)\n\nComputes eigendecomposition.\n\nFactorizes a square matrix into `P D P^{-1}`.\n\nThe relationship of D to the eigenvalues is slightly complicated, due\nto the need for P to be real. In the symmetric case, D is diagonal and\nreal, but in the non-symmetric case there may be complex-conjugate\npairs of eigenvalues. In this case, for the equation\n`self = P D P^{-1}`\nto hold, D must actually be block diagonal, with 2x2 blocks\ncorresponding to any such pairs. If a pair is `lambda +- i*mu`, D will\nhave a corresponding 2x2 block `[lambda, mu; -mu, lambda]`. Note that\nif the matrix is not invertible, P may not be invertible so in this\ncase instead of the equation `self = P D P^{-1}` holding, we have\n`self P = P D`.\n\nArgs:\n  P (DoubleMatrix): The matrix of eigenvectors.\n  eigs_real (DoubleVector): The real part of the eigenvalues.\n  eigs_imag (DoubleVector): The imaginary part of the eigenvalues.")},
  {C("power_"), (PyCFunction)wrapPower_as_power_, METH_VARARGS | METH_KEYWORDS, C("power_(pow:float) -> bool\n\nTakes the matrix to the specified power.\n\nThis method uses an algorithm that works in general for fractional\nand negative powers. The input matrix must be invertible and have a\nreasonable condition number. The algorithm is based on eigenvalue\ndecomposition. It will return False and leave the matrix unchanged,\nif the matrix has real negative eigenvalues (or if it has zero\neigenvalues and the power is negative).\n\nArgs:\n  pow (float): The exponent.\n\nReturns:\n  True if the operation was successful.")},
  {C("_destructive_svd_"), (PyCFunction)wrapDestructiveSvd_as__destructive_svd_, METH_VARARGS | METH_KEYWORDS, C("_destructive_svd_(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase)\n\nComputes singular-value decomposition.\n\nThis is the destructive version which mutates self.\n\nFactorizes a matrix into  U diag(s) Vt.\n\nFor non-square matrices, requires self.num_rows >= self.num_cols.\n\nArgs:\n  s(DoubleVector): The vector of singular values.\n  U(DoubleMatrix): The left orthonormal matrix.\n  Vt(DoubleMatrix): The right orthonormal matrix.\n\nNotes:\n  Vt in the output is already transposed.\n  The singular values in s are not sorted.\n\nRaises:\n  RuntimeError: If self.num_rows<self.num_cols,\n    or if U is not self.num_rows x self.num_cols,\n    or if Vt is not self.num_cols x self.num_cols.")},
  {C("_svd"), (PyCFunction)wrapSvd_as__svd, METH_VARARGS | METH_KEYWORDS, C("_svd(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase)\n\nComputes singular-value decomposition.\n\nFactorizes a matrix into  U diag(s) Vt.\n\nFor non-square matrices, requires self.num_rows >= self.num_cols.\n\nArgs:\n  s(DoubleVector): The vector of singular values.\n  U(DoubleMatrix): The left orthonormal matrix.\n  Vt(DoubleMatrix): The right orthonormal matrix.\n\nNotes:\n  Vt in the output is already transposed.\n  The singular values in s are not sorted.\n\nRaises:\n  RuntimeError: If self.num_rows<self.num_cols,\n    or if U is not self.num_rows x self.num_cols,\n    or if Vt is not self.num_cols x self.num_cols.")},
  {C("_singular_values"), (PyCFunction)wrapSvd_as__singular_values, METH_VARARGS | METH_KEYWORDS, C("_singular_values(s:DoubleVectorBase)\n\nComputes singular values.\n\nArgs:\n    s(DoubleVectorBase): The vector of singular values.")},
  {C("min_singular_value"), (PyCFunction)wrapMinSingularValue_as_min_singular_value, METH_NOARGS, C("min_singular_value() -> float\n\nReturns the smallest singular value.")},
  {C("cond"), (PyCFunction)wrapCond_as_cond, METH_NOARGS, C("cond() -> float\n\nReturns the condition number of the SVD computation.")},
  {C("is_symmetric"), (PyCFunction)wrapIsSymmetric_as_is_symmetric, METH_VARARGS | METH_KEYWORDS, C("is_symmetric(cutoff:float=default) -> bool\n\nChecks if the matrix is approximately symmetric.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if the matrix is approximately symmetric. False otherwise.")},
  {C("is_diagonal"), (PyCFunction)wrapIsDiagonal_as_is_diagonal, METH_VARARGS | METH_KEYWORDS, C("is_diagonal(cutoff:float=default) -> bool\n\nChecks if the matrix is approximately diagonal.\n\nArgs:\n  cutoff(float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `sum(digonal_elements)*cutoff > sum(nondiagonal_elements)`.\n  False otherwise.")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(cutoff:float=default) -> bool\n\nChecks if the matrix is identity-like.\n\nChecks if `max(M - I) <= cutoff` where `I` is a matrix with the same\nsize as `M`, ones on the diagonal and zeros elsewhere.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `max(M - I) <= cutoff`.\n\nNote:\n  The matrix does not have to be square.")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if the elements are all zeros.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-05``.\n\nReturns:\n  True if `max(abs(M)) <= cutoff`.")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n\nReturns the Frobenius norm of the matrix")},
  {C("_approx_equal"), (PyCFunction)wrapApproxEqual_as__approx_equal, METH_VARARGS | METH_KEYWORDS, C("_approx_equal(other:DoubleMatrixBase, tol:float=default) -> bool\n\nChecks if matrices are approximately equal.\n\nChecks if self is equal to other by calculating the Frobenius\nnorm of their difference.\n\nArgs:\n  other (DoubleMatrix): The matrix to check against.\n  tol (float): The tolerance for equality check. Defaults to ``0.01``.\n\nReturns:\n  True if ``||(self-other)||_F <= tol * ||self||_F`. False otherwise.")},
  {C("equal"), (PyCFunction)wrapEqual_as_equal, METH_VARARGS | METH_KEYWORDS, C("equal(other:DoubleMatrixBase) -> bool\n\nChecks if matrices are exactly equal.\n\nArgs:\n  other (DoubleMatrix): The matrix to check against\n\nReturns:\n  True if `self[i,j] == other[i,j]`` for all `i,j`. False otherwise.")},
  {C("largest_abs_elem"), (PyCFunction)wrapLargestAbsElem_as_largest_abs_elem, METH_NOARGS, C("largest_abs_elem() -> float\n\nReturns the largest of the absolute values of the elements.")},
  {C("log_sum_exp"), (PyCFunction)wrapLogSumExp_as_log_sum_exp, METH_VARARGS | METH_KEYWORDS, C("log_sum_exp(prune:float=default) -> float\n\nComputes :math:`f(M)=\\log(\\sum_{i,j} \\exp(M_{i,j}))` without exp overflow.\n\nIf `prune > 0.0`, ignores terms less than `max(M) - prune`.\n\nArgs:\n  prune (float): The pruning beam. Defaults to `-1.0`.\n\nReturns:\n  :math:`\\log(\\sum_{i,j} \\exp(M_{i,j}))`.")},
  {C("apply_softmax_"), (PyCFunction)wrapApplySoftMax_as_apply_softmax_, METH_NOARGS, C("apply_softmax_() -> float\n\nApplies the softmax operation to each element.\n\nPerforms the operation\n:math:`M_{i,j} = \\frac{\\exp(M_{i,j})}{\\sum_{k,j} \\exp(M_{k,j})}`.\n\nReturns:\n  :math:`\\log(\\sum_{k,j} \\exp(M_{k,j}))`.")},
  {C("sigmoid_"), (PyCFunction)wrapSigmoid_as_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("sigmoid_(src:DoubleMatrixBase)\n\nApplies sigmoid function to elements of another matrix.\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("heaviside_"), (PyCFunction)wrapHeaviside_as_heaviside_, METH_VARARGS | METH_KEYWORDS, C("heaviside_(src:DoubleMatrixBase)\n\nApplies Heaviside step function to elements of another matrix.\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("soft_hinge_"), (PyCFunction)wrapSoftHinge_as_soft_hinge_, METH_VARARGS | METH_KEYWORDS, C("soft_hinge_(src:DoubleMatrixBase)\n\nApplies soft hinge function to elements of another matrix.\n\nPerforms the operation `M[i,j] = log(1 + exp(src[i,j]))`.\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("group_pnorm_"), (PyCFunction)wrapGroupPnorm_as_group_pnorm_, METH_VARARGS | METH_KEYWORDS, C("group_pnorm_(src:DoubleMatrixBase, power:float)\n\nComputes group p-norm of elements in another matrix.\n\nPerforms the operation `self[i,j] = norm(src[i,j*gs:(j+1)*gs], power)`\nwhere `gs = src.num_cols / self.num_cols`\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n  power (float): The p value for p-norm. It must be non-negative.\n\nRaises:\n  RuntimeError: If `src.num_rows != self.num_rows`\n                or `src.num_rows % self.num_rows != 0`.")},
  {C("group_pnorm_deriv_"), (PyCFunction)wrapGroupPnormDeriv_as_group_pnorm_deriv_, METH_VARARGS | METH_KEYWORDS, C("group_pnorm_deriv_(input:DoubleMatrixBase, output:DoubleMatrixBase, power:float)\n\nComputes derivatives for the group p-norm operation.\n\nArgs:\n  input (DoubleMatrix): The input to group p-norm operation (src in\n    :meth:`group_pnorm_`).\n  output (DoubleMatrix): The output of group p-norm operation.\n  power (float): The p value for p-norm. It must be non-negative.")},
  {C("group_max_"), (PyCFunction)wrapGroupMax_as_group_max_, METH_VARARGS | METH_KEYWORDS, C("group_max_(src:DoubleMatrixBase)\n\nComputes group max of elements in another matrix.\n\nPerforms the operation `self[i,j] = max(src[i,j*gs:(j+1)*gs])`\nwhere `gs = src.num_cols / self.num_cols`.\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n\nRaises:\n  RuntimeError: If `src.num_rows != self.num_rows`\n                or `src.num_rows % self.num_rows != 0`.")},
  {C("group_max_deriv_"), (PyCFunction)wrapGroupMaxDeriv_as_group_max_deriv_, METH_VARARGS | METH_KEYWORDS, C("group_max_deriv_(input:DoubleMatrixBase, output:DoubleMatrixBase)\n\nComputes derivatives for the group max operation.\n\nArgs:\n  input (DoubleMatrix): The input to group max operation (src in\n    :meth:`group_max_`).\n  output (DoubleMatrix): The output of group max operation.")},
  {C("tanh_"), (PyCFunction)wrapTanh_as_tanh_, METH_VARARGS | METH_KEYWORDS, C("tanh_(src:DoubleMatrixBase)\n\nApplies tanh function to elements of another matrix.\n\nArgs:\n  src (DoubleMatrix): The source matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("diff_sigmoid_"), (PyCFunction)wrapDiffSigmoid_as_diff_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("diff_sigmoid_(value:DoubleMatrixBase, diff:DoubleMatrixBase)\n\nBackpropagates derivatives through the sigmoid function.\n\nPerforms the operation\n`M[i,j] = diff[i,j] * value[i,j] * (1 - value[i,j])`.\n\nArgs:\n  value (DoubleMatrix): The activations.\n  diff (DoubleMatrix): The derivatives.")},
  {C("diff_tanh_"), (PyCFunction)wrapDiffTanh_as_diff_tanh_, METH_VARARGS | METH_KEYWORDS, C("diff_tanh_(value:DoubleMatrixBase, diff:DoubleMatrixBase)\n\nBackpropagates derivatives through the tanh function.\n\nPerforms the operation `M[i,j] = diff[i,j] * (1 - value[i,j]^2)`.\n\nArgs:\n  value (DoubleMatrix): The activations.\n  diff (DoubleMatrix): The derivatives.")},
  {C("sym_pos_semi_def_eig"), (PyCFunction)wrapSymPosSemiDefEig_as_sym_pos_semi_def_eig, METH_VARARGS | METH_KEYWORDS, C("sym_pos_semi_def_eig(s:DoubleVectorBase, P:DoubleMatrixBase, check_thresh:float=default)\n\nComputes eigendecomposition of a positive semi-definite matrix.\n\nUses SVD to compute the eigendecomposition of a symmetric positive\nsemi-definite matrix: :math:`M = P\\ diag(s) \\ P^T`, where :math:`P`\nis an orthogonal matrix, i.e. :math:`P^{-1} = P^T`.\n\nArgs:\n  s (DoubleVector): The eigenvalue vector.\n  P (DoubleMatrix): The eigenvector matrix.\n  check_thresh (float): The threshold used for checking if input is\n    positive semi-definite. Defaults to ``0.001``.\n\nNote:\n  Set check_thresh to 2 to ensure the positive semi-definite check\n  won't ever complain, however it will zero out negative dimensions\n  in the matrix.\n\nRaises:\n  RuntimeError: If input is not positive semi-definite.")},
  {C("add_"), (PyCFunction)wrapAdd_as_add_, METH_VARARGS | METH_KEYWORDS, C("add_(alpha:float)\n\nAdds a scalar to each element of the matrix.\n\nArgs:\n  alpha(float): The scalar to add.")},
  {C("add_to_diag_"), (PyCFunction)wrapAddToDiag_as_add_to_diag_, METH_VARARGS | METH_KEYWORDS, C("add_to_diag_(alpha:float)\n\nAdds a scalar to the diagonal elements of the matrix.\n\nArgs:\n  alpha (float): The scalar to add.")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, a:DoubleVectorBase, b:DoubleVectorBase)\n\nAdds outer product of input vectors to this matrix.\n\nPerforms the operation :math:`M = M + \\alpha\\ a \\ b^T`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  a (DoubleVector): The first input vector.\n  b (DoubleVector): The second input vector.")},
  {C("add_vec_to_rows_"), (PyCFunction)wrapAddVecToRows_as_add_vec_to_rows_, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_rows_(alpha:float, v:DoubleVectorBase)\n\nAdds input vector to each row of this matrix.\n\nPerforms the operation :math:`M_{ij} = M_{ij} + \\alpha\\ v_{j}`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_vec_to_cols_"), (PyCFunction)wrapAddVecToCols_as_add_vec_to_cols_, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_cols_(alpha:float, v:DoubleVectorBase)\n\nAdds input vector to each column of this matrix.\n\nPerforms the operation :math:`M_{ij} = M_{ij} + \\alpha\\ v_{i}`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_"), (PyCFunction)wrapAddMat_as__add_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType=default)\n\nAdds given matrix to this one.\n\nPerforms the operation :math:`S += \\alpha\\ M`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  M (DoubleMatrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sym_add_mat2_"), (PyCFunction)wrapSymAddMat2_as_sym_add_mat2_, METH_VARARGS | METH_KEYWORDS, C("sym_add_mat2_(alpha:float, M:DoubleMatrixBase, transA:MatrixTransposeType, beta:float)\n\nAdds the square of given matrix to this one.\n\nPerforms the operation on symmetric matrices\n:math:`S = \\alpha\\ M\\ M^T + \\beta\\ S`.\n\nNote:\n  It only updates the lower triangle of self. It will leave the\n  matrix asymmetric. If you need it symmetric as a regular matrix,\n  call :meth:`copy_lower_to_upper_` after this operation.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`M\\ M^T`.\n  M (DoubleMatrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_diag_vec_mat_"), (PyCFunction)wrapAddDiagVecMat_as_add_diag_vec_mat_, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_mat_(alpha:float, v:DoubleVectorBase, M:DoubleMatrixBase, transM:MatrixTransposeType, beta:float=default)\n\nAdds given matrix to this one after scaling its rows.\n\nPerform the operation :math:`S = \\alpha\\ diag(v)\\ M + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`diag(v) M`.\n  v (DoubleVector): The scaling vector.\n  M (DoubleMatrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  beta (float): The scalar multiplier for the destination matrix.\n    Defaults to ``1.0``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_diag_vec_"), (PyCFunction)wrapAddMatDiagVec_as_add_mat_diag_vec_, METH_VARARGS | METH_KEYWORDS, C("add_mat_diag_vec_(alpha:float, M:DoubleMatrixBase, transM:MatrixTransposeType, v:DoubleVectorBase, beta:float=default)\n\nAdds given matrix to this one after scaling its columns.\n\nPerform the operation :math:`S = \\alpha\\ M\\ diag(v) + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`M\\ diag(v)`.\n  M (DoubleMatrix): The input matrix.\n  transM (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n  v (DoubleVector): The scaling vector.\n  beta (float): The scalar multiplier for the destination matrix.\n    Defaults to ``1.0``.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_mat_elements_"), (PyCFunction)wrapAddMatMatElements_as_add_mat_mat_elements_, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_elements_(alpha:float, A:DoubleMatrixBase, B:DoubleMatrixBase, beta:float)\n\nAdds the element-wise multiplication of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\odot B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A \\odot B`.\n  A (DoubleMatrix): The first input matrix.\n  B (DoubleMatrix): The second input matrix.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_mat_"), (PyCFunction)wrapAddMatMat_as__add_mat_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (DoubleMatrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("set_mat_mat_div_mat_"), (PyCFunction)wrapSetMatMatDivMat_as_set_mat_mat_div_mat_, METH_VARARGS | METH_KEYWORDS, C("set_mat_mat_div_mat_(A:DoubleMatrixBase, B:DoubleMatrixBase, C:DoubleMatrixBase)\n\nComputes an elementwise multiplication followed by division.\n\nPerforms the operation :math:`S = A \\odot B \\oslash C` where\n:math:`\\odot` and :math:`\\oslash` are elementwise multiplication and\ndivision. If :math:`C[i,j] == 0` then :math:`S[i,j]` remains intact.\n\nArgs:\n  A (DoubleMatrix): The first input matrix.\n  B (DoubleMatrix): The second input matrix.\n  C (DoubleMatrix): The third input matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_mat_smat_"), (PyCFunction)wrapAddMatSmat_as__add_mat_smat_, METH_VARARGS | METH_KEYWORDS, C("_add_mat_smat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (DoubleMatrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nNote:\n  This opearation is like :meth:`add_mat_mat_` but optimized for\n  sparse **B**.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_smat_mat_"), (PyCFunction)wrapAddSmatMat_as__add_smat_mat_, METH_VARARGS | METH_KEYWORDS, C("_add_smat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n\nAdds the product of given matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B`.\n  A (DoubleMatrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nNote:\n  This opearation is like :meth:`add_mat_mat_` but optimized for\n  sparse **A**.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_mat_mat_mat_"), (PyCFunction)wrapAddMatMatMat_as_add_mat_mat_mat_, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_mat_(alpha:float, A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType, beta:float)\n\nAdds the product of three matrices to this one.\n\nPerforms the operation :math:`S = \\alpha\\ A\\ B\\ C + \\beta\\ S`.\n\nArgs:\n  alpha (float): The scalar multiplier for :math:`A\\ B\\ C`.\n  A (DoubleMatrix): The first input matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second input matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (DoubleMatrix): The third input matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n  beta (float): The scalar multiplier for the destination matrix.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("copy_lower_to_upper_"), (PyCFunction)wrapCopyLowerToUpper_as_copy_lower_to_upper_, METH_NOARGS, C("copy_lower_to_upper_()\n\nCopies lower triangle to upper triangle.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("copy_upper_to_lower_"), (PyCFunction)wrapCopyUpperToLower_as_copy_upper_to_lower_, METH_NOARGS, C("copy_upper_to_lower_()\n\nCopies upper triangle to lower triangle.\n\nRaises:\n  RuntimeError: If matrix is not square.")},
  {C("orthogonalize_rows_"), (PyCFunction)wrapOrthogonalizeRows_as_orthogonalize_rows_, METH_NOARGS, C("orthogonalize_rows_()\n\nOrthogonalizes rows using the Gram-Schmidt process.\n\nUses random number generation to fill in rows with something non-zero,\nin cases where the original matrix was of deficient row rank.\n\nRaises:\n  RuntimeError: If  self.num_rows > self.num_cols`.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the matrix from the given C++ stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read matrix.\n    Defaults to ``False``.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the matrix to given C++ stream.\n\nArgs:\n    os (ostream): The output C++ straem.\n    binary (bool): Whether the stream is binary.")},
  {}
};

// DoubleMatrixBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleMatrixBase __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_matrix.DoubleMatrixBase",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Base class for double precision matrices.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::MatrixBase<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_MatrixBase_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::MatrixBase<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::MatrixBase<double>* c = static_cast<::kaldi::MatrixBase<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::MatrixBase<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleMatrixBase

namespace pyDoubleMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Matrix<double>> cpp;
};
static ::kaldi::Matrix<double>* ThisPtr(PyObject*);

// @classmethod from_size(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> DoubleMatrix
static PyObject* wrapMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("r"),
      C("c"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:from_size", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("from_size", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_size", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_size", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Matrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<double>>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<double>>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<double>>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:DoubleMatrix)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::Matrix<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::Matrix<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::Matrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// @classmethod from_matrix(M:DoubleMatrixBase, trans:MatrixTransposeType=default) -> DoubleMatrix
static PyObject* wrapMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("M"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Matrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<double>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Matrix<double>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::Matrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _remove_row_(index:int)
static PyObject* wrapRemoveRow_as__remove_row_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_row_", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_row_", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::Matrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->RemoveRow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// transpose_()
static PyObject* wrapTranspose_as_transpose_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::Matrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// resize_(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("r"),
      C("c"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:resize_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("resize_", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize_", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("resize_", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  ::kaldi::Matrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// Implicit cast this as ::kaldi::MatrixBase<double>*
static PyObject* as_kaldi_MatrixBase_double(PyObject* self) {
  ::kaldi::MatrixBase<double>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::MatrixBase<double>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> DoubleMatrix\n\nCreates a new matrix of given size.\n\nArgs:\n  r (int): The number or rows.\n  c (int): The number or columns.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or ``MatrixResizeType.COPY_DATA``,\n    they are set to zero. If ``MatrixResizeType.UNDEFINED``, they are\n    left uninitialized. Defaults to ``MatrixResizeType.SET_ZERO``.\n  stride_type(MatrixStrideType): Determines how the elements are laid\n    out in memory. If ``MatrixStrideType.STRIDE_EQUAL_NUM_COLS``, the\n    stride is equal to the number of columns. If\n    ``MatrixStrideType.DEFAULT_STRIDE``, the stride is equal to the\n    smallest multiple of 16 that is larger than the number of columns.\n    Defaults to ``MatrixStrideType.DEFAULT_STRIDE``.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:DoubleMatrix)\n\nSwaps the contents of matrices.\n\nShallow swap.\n\nArgs:\n  other (DoubleMatrix): The matrix to swap contents with.")},
  {C("from_matrix"), (PyCFunction)wrapMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(M:DoubleMatrixBase, trans:MatrixTransposeType=default) -> DoubleMatrix\n\nCreates a new matrix from a given matrix.\n\nArgs:\n  M(DoubleMatrix): The input matrix.\n  trans (MatrixTransposeType): Whether to use **M** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the matrix from the given C++ stream.\n\nResizes the matrix to match the size of the matrix read from stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read matrix.\n    Defaults to ``False``.")},
  {C("_remove_row_"), (PyCFunction)wrapRemoveRow_as__remove_row_, METH_VARARGS | METH_KEYWORDS, C("_remove_row_(index:int)\n\nRemoves the row at the given index.\n\nArgs:\n  index (int): The row index.\n\nRaises:\n  RuntimeError: If `index >= num_rows`.")},
  {C("transpose_"), (PyCFunction)wrapTranspose_as_transpose_, METH_NOARGS, C("transpose_()\n\nTransposes the matrix.")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(r:int, c:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)\n\nResizes the matrix.\n\nArgs:\n  r (int): The new number of rows.\n  c (int): The new number of columns.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or ``MatrixResizeType.COPY_DATA``,\n    they are set to zero. If ``MatrixResizeType.UNDEFINED``, they are\n    left uninitialized. Defaults to ``MatrixResizeType.SET_ZERO``.\n  stride_type(MatrixStrideType): Determines how the elements are laid\n    out in memory. If ``MatrixStrideType.STRIDE_EQUAL_NUM_COLS``, the\n    stride is equal to the number of columns. If\n    ``MatrixStrideType.DEFAULT_STRIDE``, the stride is equal to the\n    smallest multiple of 16 that is larger than the number of columns.\n    Defaults to ``MatrixStrideType.DEFAULT_STRIDE``.")},
  {C("as_kaldi_MatrixBase_double"), (PyCFunction)as_kaldi_MatrixBase_double, METH_NOARGS, C("Upcast to ::kaldi::MatrixBase<double>*")},
  {}
};

// DoubleMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_matrix.DoubleMatrix",        // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Double precision matrix.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Matrix<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Matrix<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Matrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Matrix<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::Matrix<double>* c = static_cast<::kaldi::Matrix<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Matrix<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleMatrix

// _trace_double_mat(A:DoubleMatrixBase) -> float
static PyObject* wrapTraceMat_as__trace_double_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_trace_double_mat", names, &a[0])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_mat_mat(A:DoubleMatrixBase, B:DoubleMatrixBase, trans:MatrixTransposeType=default) -> float
static PyObject* wrapTraceMatMat_as__trace_double_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_trace_double_mat_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_mat", names[1], "::kaldi::MatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::TraceMatMat(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::TraceMatMat(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_mat_mat_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType) -> float
static PyObject* wrapTraceMatMatMat_as__trace_double_mat_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:_trace_double_mat_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_mat_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_mat_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_mat_mat", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_double_mat_mat_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_double_mat_mat_mat", names[4], "::kaldi::MatrixBase<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_double_mat_mat_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatMatMat(*arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _trace_double_mat_mat_mat_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType, D:DoubleMatrixBase, transD:MatrixTransposeType) -> float
static PyObject* wrapTraceMatMatMatMat_as__trace_double_mat_mat_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[8];
  char* names[] = {
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("C"),
      C("transC"),
      C("D"),
      C("transD"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOOO:_trace_double_mat_mat_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6], &a[7])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_trace_double_mat_mat_mat_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_trace_double_mat_mat_mat_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  ::kaldi::MatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_trace_double_mat_mat_mat_mat", names[2], "::kaldi::MatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_trace_double_mat_mat_mat_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  ::kaldi::MatrixBase<double>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("_trace_double_mat_mat_mat_mat", names[4], "::kaldi::MatrixBase<double>", a[4]);
  ::kaldi::MatrixTransposeType arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("_trace_double_mat_mat_mat_mat", names[5], "::kaldi::MatrixTransposeType", a[5]);
  ::kaldi::MatrixBase<double>* arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("_trace_double_mat_mat_mat_mat", names[6], "::kaldi::MatrixBase<double>", a[6]);
  ::kaldi::MatrixTransposeType arg8;
  if (!Clif_PyObjAs(a[7], &arg8)) return ArgError("_trace_double_mat_mat_mat_mat", names[7], "::kaldi::MatrixTransposeType", a[7]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::TraceMatMatMatMat(*arg1, std::move(arg2), *arg3, std::move(arg4), *arg5, std::move(arg6), *arg7, std::move(arg8));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal_double_matrix(A:DoubleMatrixBase, B:DoubleMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_approx_equal_double_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal_double_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal_double_matrix", names[1], "::kaldi::MatrixBase<double>", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_approx_equal_double_matrix", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _assert_equal_double_matrix(A:DoubleMatrixBase, B:DoubleMatrixBase, tol:float=default)
static PyObject* wrapAssertEqual_as__assert_equal_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_assert_equal_double_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assert_equal_double_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assert_equal_double_matrix", names[1], "::kaldi::MatrixBase<double>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_assert_equal_double_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _sort_double_svd(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase=default, sort_on_absolute_value:bool=default)
static PyObject* wrapSortSvd_as__sort_double_svd(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("s"),
      C("U"),
      C("Vt"),
      C("sort_on_absolute_value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:_sort_double_svd", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_sort_double_svd", names[0], "::kaldi::VectorBase<double> *", a[0]);
  ::kaldi::MatrixBase<double> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_sort_double_svd", names[1], "::kaldi::MatrixBase<double> *", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("_sort_double_svd", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_sort_double_svd", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  }
  bool arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_sort_double_svd", names[3], "bool", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::SortSvd(arg1, arg2); break;
  case 3:
    ::kaldi::SortSvd(arg1, arg2, arg3); break;
  case 4:
    ::kaldi::SortSvd(arg1, arg2, arg3, std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _create_eigenvalue_double_matrix(real:DoubleVectorBase, imag:DoubleVectorBase, D:DoubleMatrixBase)
static PyObject* wrapCreateEigenvalueMatrix_as__create_eigenvalue_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("real"),
      C("imag"),
      C("D"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:_create_eigenvalue_double_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_create_eigenvalue_double_matrix", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_create_eigenvalue_double_matrix", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::MatrixBase<double> * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_create_eigenvalue_double_matrix", names[2], "::kaldi::MatrixBase<double> *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::CreateEigenvalueMatrix(*arg1, *arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _same_dim_double_matrix(M:DoubleMatrixBase, N:DoubleMatrixBase) -> bool
static PyObject* wrapSameDim_as__same_dim_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_same_dim_double_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_same_dim_double_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_same_dim_double_matrix", names[1], "::kaldi::MatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDim(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyHtkHeader {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::HtkHeader> cpp;
};
static ::kaldi::HtkHeader* ThisPtr(PyObject*);

static PyObject* get_mNSamples(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->mNSamples, {});
}

static int set_mNSamples(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the mNSamples attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->mNSamples)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for mNSamples:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_mSamplePeriod(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->mSamplePeriod, {});
}

static int set_mSamplePeriod(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the mSamplePeriod attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->mSamplePeriod)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for mSamplePeriod:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_mSampleSize(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->mSampleSize, {});
}

static int set_mSampleSize(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the mSampleSize attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->mSampleSize)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for mSampleSize:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_mSampleKind(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->mSampleKind, {});
}

static int set_mSampleKind(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the mSampleKind attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->mSampleKind)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for mSampleKind:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("mNSamples"), get_mNSamples, set_mNSamples, C("C++ ::int32 HtkHeader.mNSamples")},
  {C("mSamplePeriod"), get_mSamplePeriod, set_mSamplePeriod, C("C++ ::int32 HtkHeader.mSamplePeriod")},
  {C("mSampleSize"), get_mSampleSize, set_mSampleSize, C("C++ ::int16 HtkHeader.mSampleSize")},
  {C("mSampleKind"), get_mSampleKind, set_mSampleKind, C("C++ ::uint16 HtkHeader.mSampleKind")},
  {}
};

// HtkHeader __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// HtkHeader __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// HtkHeader __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_matrix.HtkHeader",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "HTK header for features.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "HtkHeader takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::HtkHeader>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::HtkHeader* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_HtkHeader"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::HtkHeader"));
      if (!PyErr_Occurred()) {
        ::kaldi::HtkHeader* c = static_cast<::kaldi::HtkHeader*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::HtkHeader*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyHtkHeader

// read_htk(is:istream, M:Matrix, header:HtkHeader) -> bool
static PyObject* wrapReadHtk_as_read_htk(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("is"),
      C("M"),
      C("header"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:read_htk", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_htk", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::kaldi::Matrix<float> * arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_htk", names[1], "::kaldi::Matrix<float> *", a[1]);
  ::kaldi::HtkHeader * arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_htk", names[2], "::kaldi::HtkHeader *", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ReadHtk(*arg1, arg2, arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_htk(os:ostream, M:MatrixBase, header:HtkHeader) -> bool
static PyObject* wrapWriteHtk_as_write_htk(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("os"),
      C("M"),
      C("header"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:write_htk", names, &a[0], &a[1], &a[2])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_htk", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_htk", names[1], "::kaldi::MatrixBase<float>", a[1]);
  ::kaldi::HtkHeader* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("write_htk", names[2], "::kaldi::HtkHeader", a[2]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::WriteHtk(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write_sphinx(os:ostream, M:MatrixBase) -> bool
static PyObject* wrapWriteSphinx_as_write_sphinx(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("M"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write_sphinx", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write_sphinx", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::kaldi::MatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write_sphinx", names[1], "::kaldi::MatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::WriteSphinx(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_trace_mat"), (PyCFunction)wrapTraceMat_as__trace_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat(A:MatrixBase) -> float\n\nComputes the trace of :math:`A`.\n\nArgs:\n  A (Matrix): The input matrix\n\nReturns:\n  The trace of :math:`A`.")},
  {C("_trace_mat_mat"), (PyCFunction)wrapTraceMatMat_as__trace_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_mat(A:MatrixBase, B:MatrixBase, trans:MatrixTransposeType=default) -> float\n\nComputes the trace of :math:`A\\ B`.\n\nArgs:\n  A (Matrix): The first matrix.\n  B (Matrix): The second matrix.\n  trans (MatrixTransposeType): Whether to use **B** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nReturns:\n  The trace of :math:`A\\ B`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_trace_mat_mat_mat"), (PyCFunction)wrapTraceMatMatMat_as__trace_mat_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_mat_mat(A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType) -> float\n\nComputes the trace of :math:`A\\ B\\ C`.\n\nArgs:\n  A (Matrix): The first matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (Matrix): The third matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n\nReturns:\n  The trace of :math:`A\\ B\\ C`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_trace_mat_mat_mat_mat"), (PyCFunction)wrapTraceMatMatMatMat_as__trace_mat_mat_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_mat_mat_mat_mat(A:MatrixBase, transA:MatrixTransposeType, B:MatrixBase, transB:MatrixTransposeType, C:MatrixBase, transC:MatrixTransposeType, D:MatrixBase, transD:MatrixTransposeType) -> float\n\nComputes the trace of :math:`A\\ B\\ C\\ D`.\n\nArgs:\n  A (Matrix): The first matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (Matrix): The second matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (Matrix): The third matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n  D (Matrix): The fourth matrix.\n  transC (MatrixTransposeType): Whether to use **D** or its transpose.\n\nReturns:\n  The trace of :math:`A\\ B\\ C\\ D`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_approx_equal_matrix"), (PyCFunction)wrapApproxEqual_as__approx_equal_matrix, METH_VARARGS | METH_KEYWORDS, C("_approx_equal_matrix(A:MatrixBase, B:MatrixBase, tol:float=default) -> bool\n\nCheck if matrices are approximately equal.\n\nComputes the Frobenius norm of the difference of A and B and\nreturns True if it is less than or equal than tol times the norm of A.\n\nArgs:\n  A (Matrix): The first input matrix.\n  B (Matrix): The second input matrix.\n  tol (float): The tolerance for equality check.\n\nReturns:\n  True if `||A-B||_F <= tol * ||A||_F`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_assert_equal_matrix"), (PyCFunction)wrapAssertEqual_as__assert_equal_matrix, METH_VARARGS | METH_KEYWORDS, C("_assert_equal_matrix(A:MatrixBase, B:MatrixBase, tol:float=default)\n\nAsserts matrices are approximately equal.\n\nArgs:\n  A (Matrix): The first input matrix.\n  B (Matrix): The second input matrix.\n  tol (float): The tolerance for equality check.\n\nRaises:\n  RuntimeError: If `||A-B||_F <= tol * ||A||_F`.")},
  {C("_sort_svd"), (PyCFunction)wrapSortSvd_as__sort_svd, METH_VARARGS | METH_KEYWORDS, C("_sort_svd(s:VectorBase, U:MatrixBase, Vt:MatrixBase=default, sort_on_absolute_value:bool=default)\n\nSorts singular-value decomposition in-place.\n\nThis function is as generic as possible, to be applicable to other\ntypes of problems. Requires s.dim == U.num_cols, and we sort s from\ngreatest to least absolute value (if sort_on_absolute_value is True)\nor greatest to least value (otherwise), moving the columns of U,\nand the rows of Vt, if provided, around in the same way.\n\nNote:\n  The ``absolute value'' part won't matter if this is an actual SVD,\n  since singular values are non-negative.\n\nArgs:\n  s (Vector): The singular values. SVD is U*diag(s)*Vt.\n  U (Matrix): The U part of SVD.\n  Vt (Matrix): The Vt part of SVD. Defaults to None.\n\nRaises:\n  RuntimeError: If s.dim != U.num_cols.")},
  {C("_create_eigenvalue_matrix"), (PyCFunction)wrapCreateEigenvalueMatrix_as__create_eigenvalue_matrix, METH_VARARGS | METH_KEYWORDS, C("_create_eigenvalue_matrix(real:VectorBase, imag:VectorBase, D:MatrixBase)\n\nCreates the eigenvalue matrix.\n\nEigenvalue matrix D is part of the decomposition used in eig. D will be\nblock-diagonal with blocks of size 1 (for real eigenvalues) or 2x2 for\ncomplex pairs. If a complex pair is lambda +- i*mu, D will have a\ncorresponding 2x2 block [lambda, mu; -mu, lambda]. This function will\nthrow if any complex eigenvalues are not in complex conjugate pairs (or\nthe members of such pairs are not consecutively numbered). The D you\nsupply must has correct dimensions.\n\nArgs:\n  real (Vector): The real part of the eigenvalues.\n  imag (Vector): The imaginary part of the eigenvalues.\n  D (Matrix): The eigenvalue matrix.\n\nRaises:\n  RuntimeError: If `real.dim != imag.dim` or if D is wrong size.")},
  {C("_same_dim_matrix"), (PyCFunction)wrapSameDim_as__same_dim_matrix, METH_VARARGS | METH_KEYWORDS, C("_same_dim_matrix(M:MatrixBase, N:MatrixBase) -> bool\n\nChecks if M and N have the same size.\n\nArgs:\n  M (Matrix): The first matrix\n  N (Matrix): The second matrix\n\nReturns:\n  True if `M.num_rows == N.num_rows` and `M.num_cols == N.num_cols`.")},
  {C("_trace_double_mat"), (PyCFunction)wrapTraceMat_as__trace_double_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat(A:DoubleMatrixBase) -> float\n\nComputes the trace of :math:`A`.\n\nArgs:\n  A (DoubleMatrix): The input matrix\n\nReturns:\n  The trace of :math:`A`.")},
  {C("_trace_double_mat_mat"), (PyCFunction)wrapTraceMatMat_as__trace_double_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_mat(A:DoubleMatrixBase, B:DoubleMatrixBase, trans:MatrixTransposeType=default) -> float\n\nComputes the trace of :math:`A\\ B`.\n\nArgs:\n  A (DoubleMatrix): The first matrix.\n  B (DouobleMatrix): The second matrix.\n  trans (MatrixTransposeType): Whether to use **B** or its transpose.\n    Defaults to ``MatrixTransposeType.NO_TRANS``.\n\nReturns:\n  The trace of :math:`A\\ B`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_trace_double_mat_mat_mat"), (PyCFunction)wrapTraceMatMatMat_as__trace_double_mat_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_mat_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType) -> float\n\nComputes the trace of :math:`A\\ B\\ C`.\n\nArgs:\n  A (DoubleMatrix): The first matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (DoubleMatrix): The third matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n\nReturns:\n  The trace of :math:`A\\ B\\ C`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_trace_double_mat_mat_mat_mat"), (PyCFunction)wrapTraceMatMatMatMat_as__trace_double_mat_mat_mat_mat, METH_VARARGS | METH_KEYWORDS, C("_trace_double_mat_mat_mat_mat(A:DoubleMatrixBase, transA:MatrixTransposeType, B:DoubleMatrixBase, transB:MatrixTransposeType, C:DoubleMatrixBase, transC:MatrixTransposeType, D:DoubleMatrixBase, transD:MatrixTransposeType) -> float\n\nComputes the trace of :math:`A\\ B\\ C\\ D`.\n\nArgs:\n  A (DoubleMatrix): The first matrix.\n  transA (MatrixTransposeType): Whether to use **A** or its transpose.\n  B (DoubleMatrix): The second matrix.\n  transB (MatrixTransposeType): Whether to use **B** or its transpose.\n  C (DoubleMatrix): The third matrix.\n  transC (MatrixTransposeType): Whether to use **C** or its transpose.\n  D (DoubleMatrix): The fourth matrix.\n  transC (MatrixTransposeType): Whether to use **D** or its transpose.\n\nReturns:\n  The trace of :math:`A\\ B\\ C\\ D`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_approx_equal_double_matrix"), (PyCFunction)wrapApproxEqual_as__approx_equal_double_matrix, METH_VARARGS | METH_KEYWORDS, C("_approx_equal_double_matrix(A:DoubleMatrixBase, B:DoubleMatrixBase, tol:float=default) -> bool\n\nCheck if matrices are approximately equal.\n\nComputes the Frobenius norm of the difference of A and B and\nreturns True if it is less than or equal than tol times the norm of A.\n\nArgs:\n  A (DoubleMatrix): The first input matrix.\n  B (DoubleMatrix): The second input matrix.\n  tol (float): The tolerance for equality check.\n\nReturns:\n  True if `||A-B||_F <= tol * ||A||_F`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_assert_equal_double_matrix"), (PyCFunction)wrapAssertEqual_as__assert_equal_double_matrix, METH_VARARGS | METH_KEYWORDS, C("_assert_equal_double_matrix(A:DoubleMatrixBase, B:DoubleMatrixBase, tol:float=default)\n\nAsserts matrices are approximately equal.\n\nArgs:\n  A (DoubleMatrix): The first input matrix.\n  B (DoubleMatrix): The second input matrix.\n  tol (float): The tolerance for equality check.\n\nRaises:\n  RuntimeError: If `||A-B||_F <= tol * ||A||_F`.")},
  {C("_sort_double_svd"), (PyCFunction)wrapSortSvd_as__sort_double_svd, METH_VARARGS | METH_KEYWORDS, C("_sort_double_svd(s:DoubleVectorBase, U:DoubleMatrixBase, Vt:DoubleMatrixBase=default, sort_on_absolute_value:bool=default)\n\nSorts singular-value decomposition in-place.\n\nThis function is as generic as possible, to be applicable to other\ntypes of problems. Requires s.dim == U.num_cols, and we sort s from\ngreatest to least absolute value (if sort_on_absolute_value is True)\nor greatest to least value (otherwise), moving the columns of U,\nand the rows of Vt, if provided, around in the same way.\n\nNote:\n  The ``absolute value'' part won't matter if this is an actual SVD,\n  since singular values are non-negative.\n\nArgs:\n  s (DoubleVector): The singular values. SVD is U*diag(s)*Vt.\n  U (DoubleMatrix): The U part of SVD.\n  Vt (DoubleMatrix): The Vt part of SVD. Defaults to None.\n\nRaises:\n  RuntimeError: If `s.dim != U.num_cols`.")},
  {C("_create_eigenvalue_double_matrix"), (PyCFunction)wrapCreateEigenvalueMatrix_as__create_eigenvalue_double_matrix, METH_VARARGS | METH_KEYWORDS, C("_create_eigenvalue_double_matrix(real:DoubleVectorBase, imag:DoubleVectorBase, D:DoubleMatrixBase)\n\nCreates the eigenvalue matrix.\n\nEigenvalue matrix D is part of the decomposition used in eig. D will be\nblock-diagonal with blocks of size 1 (for real eigenvalues) or 2x2 for\ncomplex pairs. If a complex pair is lambda +- i*mu, D will have a\ncorresponding 2x2 block [lambda, mu; -mu, lambda]. This function will\nthrow if any complex eigenvalues are not in complex conjugate pairs (or\nthe members of such pairs are not consecutively numbered). The D you\nsupply must has correct dimensions.\n\nArgs:\n  real (DoubleVector): The real part of the eigenvalues.\n  imag (DoubleVector): The imaginary part of the eigenvalues.\n  D (DoubleMatrix): The eigenvalue matrix.\n\nRaises:\n  RuntimeError: If `real.dim != imag.dim` or if D is wrong size.")},
  {C("_same_dim_double_matrix"), (PyCFunction)wrapSameDim_as__same_dim_double_matrix, METH_VARARGS | METH_KEYWORDS, C("_same_dim_double_matrix(M:DoubleMatrixBase, N:DoubleMatrixBase) -> bool\n\nChecks if M and N have the same size.\n\nArgs:\n  M (DoubleMatrixBase): The first matrix\n  N (DoubleMatrixBase): The second matrix\n\nReturns:\n  True if `M.num_rows == N.num_rows` and `M.num_cols == N.num_cols`.")},
  {C("read_htk"), (PyCFunction)wrapReadHtk_as_read_htk, METH_VARARGS | METH_KEYWORDS, C("read_htk(is:istream, M:Matrix, header:HtkHeader) -> bool\n\nReads features in HTK format.")},
  {C("write_htk"), (PyCFunction)wrapWriteHtk_as_write_htk, METH_VARARGS | METH_KEYWORDS, C("write_htk(os:ostream, M:MatrixBase, header:HtkHeader) -> bool\n\nWrites features in HTK format.")},
  {C("write_sphinx"), (PyCFunction)wrapWriteSphinx_as_write_sphinx, METH_VARARGS | METH_KEYWORDS, C("write_sphinx(os:ostream, M:MatrixBase) -> bool\n\nWrites features in Sphinx format.")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyMatrixBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyMatrixBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyMatrix::wrapper_Type.tp_base = &pyMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleMatrixBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleMatrixBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyDoubleMatrix::wrapper_Type.tp_base = &pyDoubleMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyDoubleMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyHtkHeader::wrapper_Type) < 0) return false;
  Py_INCREF(&pyHtkHeader::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_matrix",  // module name
  "CLIF-generated module for matrix/kaldi-matrix.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "MatrixBase", reinterpret_cast<PyObject*>(&pyMatrixBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Matrix", reinterpret_cast<PyObject*>(&pyMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleMatrixBase", reinterpret_cast<PyObject*>(&pyDoubleMatrixBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleMatrix", reinterpret_cast<PyObject*>(&pyDoubleMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "HtkHeader", reinterpret_cast<PyObject*>(&pyHtkHeader::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__matrix_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// DoubleMatrix to/from ::kaldi::Matrix<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Matrix<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Matrix<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Matrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Matrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Matrix<double>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Matrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Matrix<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Matrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Matrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Matrix<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Matrix<double>>(c);
  return py;
}

// DoubleMatrixBase to/from ::kaldi::MatrixBase<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::MatrixBase<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::MatrixBase<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::MatrixBase<double>>* c) {
  assert(c != nullptr);
  ::kaldi::MatrixBase<double>* cpp = __kaldi__matrix_clifwrap::pyDoubleMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrixBase::wrapper*>(py)->cpp, cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::MatrixBase<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::MatrixBase<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::MatrixBase<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyDoubleMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyDoubleMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::MatrixBase<double>>(c);
  return py;
}

// HtkHeader to/from ::kaldi::HtkHeader conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::HtkHeader** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::HtkHeader* cpp = __kaldi__matrix_clifwrap::pyHtkHeader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::HtkHeader>* c) {
  assert(c != nullptr);
  ::kaldi::HtkHeader* cpp = __kaldi__matrix_clifwrap::pyHtkHeader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::HtkHeader>* c) {
  assert(c != nullptr);
  ::kaldi::HtkHeader* cpp = __kaldi__matrix_clifwrap::pyHtkHeader::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert HtkHeader instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::HtkHeader* c) {
  assert(c != nullptr);
  ::kaldi::HtkHeader* cpp = __kaldi__matrix_clifwrap::pyHtkHeader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::HtkHeader>* c) {
  assert(c != nullptr);
  ::kaldi::HtkHeader* cpp = __kaldi__matrix_clifwrap::pyHtkHeader::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::HtkHeader* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyHtkHeader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::HtkHeader>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::HtkHeader> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyHtkHeader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::HtkHeader>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::HtkHeader> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyHtkHeader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::HtkHeader>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::HtkHeader& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyHtkHeader::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyHtkHeader::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::HtkHeader>(c);
  return py;
}

// Matrix to/from ::kaldi::Matrix<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Matrix<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Matrix<float>* cpp = __kaldi__matrix_clifwrap::pyMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Matrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<float>* cpp = __kaldi__matrix_clifwrap::pyMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Matrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<float>* cpp = __kaldi__matrix_clifwrap::pyMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Matrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Matrix<float>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<float>* cpp = __kaldi__matrix_clifwrap::pyMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Matrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Matrix<float>* cpp = __kaldi__matrix_clifwrap::pyMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Matrix<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Matrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Matrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Matrix<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Matrix<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Matrix<float>>(c);
  return py;
}

// MatrixBase to/from ::kaldi::MatrixBase<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::MatrixBase<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::MatrixBase<float>* cpp = __kaldi__matrix_clifwrap::pyMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::MatrixBase<float>>* c) {
  assert(c != nullptr);
  ::kaldi::MatrixBase<float>* cpp = __kaldi__matrix_clifwrap::pyMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrixBase::wrapper*>(py)->cpp, cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::MatrixBase<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::MatrixBase<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::MatrixBase<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__matrix_clifwrap::pyMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__matrix_clifwrap::pyMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::MatrixBase<float>>(c);
  return py;
}

}  // namespace kaldi
