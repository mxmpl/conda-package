//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/matrix-common.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix-common-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __matrix__common_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


// Create Python Enum object (cached in _MatrixTransposeType) for ::kaldi::MatrixTransposeType
static PyObject* wrapMatrixTransposeType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TRANS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixTransposeType>::type>(::kaldi::MatrixTransposeType::kTrans)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NO_TRANS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixTransposeType>::type>(::kaldi::MatrixTransposeType::kNoTrans)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("MatrixTransposeType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _MatrixTransposeType{};  // set by above func in Init()

// Create Python Enum object (cached in _MatrixResizeType) for ::kaldi::MatrixResizeType
static PyObject* wrapMatrixResizeType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SET_ZERO"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixResizeType>::type>(::kaldi::MatrixResizeType::kSetZero)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("UNDEFINED"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixResizeType>::type>(::kaldi::MatrixResizeType::kUndefined)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("COPY_DATA"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixResizeType>::type>(::kaldi::MatrixResizeType::kCopyData)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("MatrixResizeType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _MatrixResizeType{};  // set by above func in Init()

// Create Python Enum object (cached in _MatrixStrideType) for ::kaldi::MatrixStrideType
static PyObject* wrapMatrixStrideType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DEFAULT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixStrideType>::type>(::kaldi::MatrixStrideType::kDefaultStride)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NUM_COLS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::MatrixStrideType>::type>(::kaldi::MatrixStrideType::kStrideEqualNumCols)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("MatrixStrideType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _MatrixStrideType{};  // set by above func in Init()

// Create Python Enum object (cached in _SpCopyType) for ::kaldi::SpCopyType
static PyObject* wrapSpCopyType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(4);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TAKE_LOWER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::SpCopyType>::type>(::kaldi::SpCopyType::kTakeLower)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TAKE_UPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::SpCopyType>::type>(::kaldi::SpCopyType::kTakeUpper)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TAKE_MEAN"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::SpCopyType>::type>(::kaldi::SpCopyType::kTakeMean)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TAKE_MEAN_AND_CHECK"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::kaldi::SpCopyType>::type>(::kaldi::SpCopyType::kTakeMeanAndCheck)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  py = PyUnicode_FromString("SpCopyType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _SpCopyType{};  // set by above func in Init()


// Initialize module

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_matrix_common",  // module name
  "CLIF-generated module for matrix/matrix-common.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "MatrixTransposeType", (_MatrixTransposeType=wrapMatrixTransposeType())) < 0) goto err;
  if (PyModule_AddObject(module, "MatrixResizeType", (_MatrixResizeType=wrapMatrixResizeType())) < 0) goto err;
  if (PyModule_AddObject(module, "MatrixStrideType", (_MatrixStrideType=wrapMatrixStrideType())) < 0) goto err;
  if (PyModule_AddObject(module, "SpCopyType", (_SpCopyType=wrapSpCopyType())) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __matrix__common_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// MatrixResizeType:IntEnum to/from enum ::kaldi::MatrixResizeType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::MatrixResizeType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __matrix__common_clifwrap::_MatrixResizeType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum MatrixResizeType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::MatrixResizeType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::MatrixResizeType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::MatrixResizeType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__matrix__common_clifwrap::_MatrixResizeType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::MatrixResizeType>::type>(c)), nullptr);
}

// MatrixStrideType:IntEnum to/from enum ::kaldi::MatrixStrideType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::MatrixStrideType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __matrix__common_clifwrap::_MatrixStrideType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum MatrixStrideType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::MatrixStrideType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::MatrixStrideType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::MatrixStrideType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__matrix__common_clifwrap::_MatrixStrideType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::MatrixStrideType>::type>(c)), nullptr);
}

// MatrixTransposeType:IntEnum to/from enum ::kaldi::MatrixTransposeType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::MatrixTransposeType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __matrix__common_clifwrap::_MatrixTransposeType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum MatrixTransposeType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::MatrixTransposeType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::MatrixTransposeType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::MatrixTransposeType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__matrix__common_clifwrap::_MatrixTransposeType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::MatrixTransposeType>::type>(c)), nullptr);
}

// SpCopyType:IntEnum to/from enum ::kaldi::SpCopyType conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::SpCopyType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __matrix__common_clifwrap::_SpCopyType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum SpCopyType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::kaldi::SpCopyType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::kaldi::SpCopyType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::kaldi::SpCopyType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__matrix__common_clifwrap::_SpCopyType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::kaldi::SpCopyType>::type>(c)), nullptr);
}

}  // namespace kaldi
