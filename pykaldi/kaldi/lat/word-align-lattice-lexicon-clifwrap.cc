//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/lat/word-align-lattice-lexicon.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "itf/options-itf-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/vector-fst-clifwrap.h"
#include "hmm/transition-model-clifwrap.h"
#include "word-align-lattice-lexicon-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __word__align__lattice__lexicon_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// _read_lexicon_for_word_align(is:istream) -> (success:bool, lexicon:list<list<int>>)
static PyObject* wrapReadLexiconForWordAlign_as__read_lexicon_for_word_align(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("is"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_read_lexicon_for_word_align", names, &a[0])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_read_lexicon_for_word_align", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::vector< ::std::vector< ::int32> > ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::ReadLexiconForWordAlign(*arg1, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

namespace pyWordAlignLatticeLexiconInfo {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::WordAlignLatticeLexiconInfo> cpp;
};
static ::kaldi::WordAlignLatticeLexiconInfo* ThisPtr(PyObject*);

// __init__(lexicon:list<list<int>>)
static PyObject* wrapWordAlignLatticeLexiconInfo_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("lexicon"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  ::std::vector< ::std::vector< ::int32> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::std::vector< ::std::vector< ::int32> >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::WordAlignLatticeLexiconInfo>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// is_valid_entry(entry:list<int>) -> bool
static PyObject* wrapIsValidEntry_as_is_valid_entry(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("entry"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:is_valid_entry", names, &a[0])) return nullptr;
  ::std::vector< ::int32> arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_valid_entry", names[0], "::std::vector< ::int32>", a[0]);
  // Call actual C++ method.
  ::kaldi::WordAlignLatticeLexiconInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->IsValidEntry(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// equivalence_class_of(word:int) -> int
static PyObject* wrapEquivalenceClassOf_as_equivalence_class_of(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("word"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:equivalence_class_of", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("equivalence_class_of", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::WordAlignLatticeLexiconInfo* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->EquivalenceClassOf(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapWordAlignLatticeLexiconInfo_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(lexicon:list<list<int>>)\n  Calls C++ function\n  void ::kaldi::WordAlignLatticeLexiconInfo::WordAlignLatticeLexiconInfo(::std::vector< ::std::vector< ::int32> >)")},
  {C("is_valid_entry"), (PyCFunction)wrapIsValidEntry_as_is_valid_entry, METH_VARARGS | METH_KEYWORDS, C("is_valid_entry(entry:list<int>) -> bool\n\nChecks if entry is valid.\n\nThis function is used in testing code.\n\nReturns:\n  True if the entry intepreted as (output-word phone1 phone2 ...)\n  can appear in the lexicon.")},
  {C("equivalence_class_of"), (PyCFunction)wrapEquivalenceClassOf_as_equivalence_class_of, METH_VARARGS | METH_KEYWORDS, C("equivalence_class_of(word:int) -> int\n\nReturns the equivalence class for the word.\n\nThis function is used in testing code.\n\nWords are mapped into equivalence classes derived from the mappings in\nthe first two fields of each line in the lexicon. This function maps\nfrom each word-id to the lowest member of its equivalence class.")},
  {}
};

// WordAlignLatticeLexiconInfo __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// WordAlignLatticeLexiconInfo __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// WordAlignLatticeLexiconInfo __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_word_align_lattice_lexicon.WordAlignLatticeLexiconInfo", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "WordAlignLatticeLexiconInfo(lexicon)\n\nThis class extracts some information from the lexicon and stores it in a\nsuitable form for the word-alignment code to use.\n\nArgs:\n  lexicon (List[List[int]]): The lexicon.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapWordAlignLatticeLexiconInfo_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::WordAlignLatticeLexiconInfo* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_WordAlignLatticeLexiconInfo"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::WordAlignLatticeLexiconInfo"));
      if (!PyErr_Occurred()) {
        ::kaldi::WordAlignLatticeLexiconInfo* c = static_cast<::kaldi::WordAlignLatticeLexiconInfo*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::WordAlignLatticeLexiconInfo*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyWordAlignLatticeLexiconInfo

namespace pyWordAlignLatticeLexiconOpts {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::WordAlignLatticeLexiconOpts> cpp;
};
static ::kaldi::WordAlignLatticeLexiconOpts* ThisPtr(PyObject*);

static PyObject* get_partial_word_label(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->partial_word_label, {});
}

static int set_partial_word_label(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the partial_word_label attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->partial_word_label)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for partial_word_label:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_reorder(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->reorder, {});
}

static int set_reorder(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the reorder attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->reorder)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for reorder:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_test(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->test, {});
}

static int set_test(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the test attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->test)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for test:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_allow_duplicate_paths(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->allow_duplicate_paths, {});
}

static int set_allow_duplicate_paths(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the allow_duplicate_paths attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->allow_duplicate_paths)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for allow_duplicate_paths:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_expand(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_expand, {});
}

static int set_max_expand(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_expand attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_expand)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_expand:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::WordAlignLatticeLexiconOpts* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("partial_word_label"), get_partial_word_label, set_partial_word_label, C("Label for partial word arcs at the end of \"forced-out\" utterances.")},
  {C("reorder"), get_reorder, set_reorder, C("Whether lattice was created from a graph with reorder option set.")},
  {C("test"), get_test, set_test, C("Whether to activate the testing code to validate the algorithm.")},
  {C("allow_duplicate_paths"), get_allow_duplicate_paths, set_allow_duplicate_paths, C("Whether to allow duplicate paths in testing code.")},
  {C("max_expand"), get_max_expand, set_max_expand, C("Maximum allowed ratio of #states in aligned lattice vs input lattice.\n\nIf >0.0, the maximum ratio by which we allow the lattice-alignment code\nto increase the #states in a lattice (vs. the phone-aligned lattice)\nbefore we fail and  refuse to align the lattice. This is helpful in order\nto prevent 'pathological' lattices from causing the program to exhaust\nmemory. Actual max-states is 1000 + max-expand * orig-num-states.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n\nRegisters options with an object implementing the options interface.\n\nArgs:\n  opts (OptionsItf): An object implementing the options interface.\n    Typically a command-line option parser.")},
  {}
};

// WordAlignLatticeLexiconOpts __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// WordAlignLatticeLexiconOpts __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// WordAlignLatticeLexiconOpts __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_word_align_lattice_lexicon.WordAlignLatticeLexiconOpts", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Options for word alignment using a lexicon.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "WordAlignLatticeLexiconOpts takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::WordAlignLatticeLexiconOpts>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::WordAlignLatticeLexiconOpts* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_WordAlignLatticeLexiconOpts"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::WordAlignLatticeLexiconOpts"));
      if (!PyErr_Occurred()) {
        ::kaldi::WordAlignLatticeLexiconOpts* c = static_cast<::kaldi::WordAlignLatticeLexiconOpts*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::WordAlignLatticeLexiconOpts*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyWordAlignLatticeLexiconOpts

// _word_align_lattice_lexicon(lat:CompactLatticeVectorFst, tmodel:TransitionModel, lexicon_info:WordAlignLatticeLexiconInfo, opts:WordAlignLatticeLexiconOpts) -> (success:bool, lat_out:CompactLatticeVectorFst)
static PyObject* wrapWordAlignLatticeLexicon_as__word_align_lattice_lexicon(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("lat"),
      C("tmodel"),
      C("lexicon_info"),
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:_word_align_lattice_lexicon", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_word_align_lattice_lexicon", names[0], "::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >", a[0]);
  ::kaldi::TransitionModel* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_word_align_lattice_lexicon", names[1], "::kaldi::TransitionModel", a[1]);
  ::kaldi::WordAlignLatticeLexiconInfo* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_word_align_lattice_lexicon", names[2], "::kaldi::WordAlignLatticeLexiconInfo", a[2]);
  ::kaldi::WordAlignLatticeLexiconOpts* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("_word_align_lattice_lexicon", names[3], "::kaldi::WordAlignLatticeLexiconOpts", a[3]);
  ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > > ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::WordAlignLatticeLexicon(*arg1, *arg2, *arg3, *arg4, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_read_lexicon_for_word_align"), (PyCFunction)wrapReadLexiconForWordAlign_as__read_lexicon_for_word_align, METH_VARARGS | METH_KEYWORDS, C("_read_lexicon_for_word_align(is:istream) -> (success:bool, lexicon:list<list<int>>)\n  Calls C++ function\n  bool ::kaldi::ReadLexiconForWordAlign(::std::basic_istream<char, ::std::char_traits<char> >, ::std::vector< ::std::vector< ::int32> >*)")},
  {C("_word_align_lattice_lexicon"), (PyCFunction)wrapWordAlignLatticeLexicon_as__word_align_lattice_lexicon, METH_VARARGS | METH_KEYWORDS, C("_word_align_lattice_lexicon(lat:CompactLatticeVectorFst, tmodel:TransitionModel, lexicon_info:WordAlignLatticeLexiconInfo, opts:WordAlignLatticeLexiconOpts) -> (success:bool, lat_out:CompactLatticeVectorFst)\n  Calls C++ function\n  bool ::kaldi::WordAlignLatticeLexicon(::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >, ::kaldi::TransitionModel, ::kaldi::WordAlignLatticeLexiconInfo, ::kaldi::WordAlignLatticeLexiconOpts, ::fst::VectorFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::fst::VectorState< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >, ::std::allocator< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > > >*)")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyWordAlignLatticeLexiconInfo::wrapper_Type) < 0) return false;
  Py_INCREF(&pyWordAlignLatticeLexiconInfo::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyWordAlignLatticeLexiconOpts::wrapper_Type) < 0) return false;
  Py_INCREF(&pyWordAlignLatticeLexiconOpts::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_word_align_lattice_lexicon",  // module name
  "CLIF-generated module for lat/word-align-lattice-lexicon.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_vector_fst")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_transition_model")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "WordAlignLatticeLexiconInfo", reinterpret_cast<PyObject*>(&pyWordAlignLatticeLexiconInfo::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "WordAlignLatticeLexiconOpts", reinterpret_cast<PyObject*>(&pyWordAlignLatticeLexiconOpts::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __word__align__lattice__lexicon_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// WordAlignLatticeLexiconInfo to/from ::kaldi::WordAlignLatticeLexiconInfo conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::WordAlignLatticeLexiconInfo** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::WordAlignLatticeLexiconInfo* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::WordAlignLatticeLexiconInfo>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconInfo* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::WordAlignLatticeLexiconInfo>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconInfo* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert WordAlignLatticeLexiconInfo instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::WordAlignLatticeLexiconInfo* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconInfo* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::WordAlignLatticeLexiconInfo>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconInfo* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::WordAlignLatticeLexiconInfo* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconInfo>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::WordAlignLatticeLexiconInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconInfo>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::WordAlignLatticeLexiconInfo> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconInfo>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::WordAlignLatticeLexiconInfo& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconInfo::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::WordAlignLatticeLexiconInfo>(c);
  return py;
}

// WordAlignLatticeLexiconOpts to/from ::kaldi::WordAlignLatticeLexiconOpts conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::WordAlignLatticeLexiconOpts** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::WordAlignLatticeLexiconOpts* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::WordAlignLatticeLexiconOpts>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconOpts* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::WordAlignLatticeLexiconOpts>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconOpts* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert WordAlignLatticeLexiconOpts instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::WordAlignLatticeLexiconOpts* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconOpts* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::WordAlignLatticeLexiconOpts>* c) {
  assert(c != nullptr);
  ::kaldi::WordAlignLatticeLexiconOpts* cpp = __word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::WordAlignLatticeLexiconOpts* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconOpts>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::WordAlignLatticeLexiconOpts> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconOpts>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::WordAlignLatticeLexiconOpts> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::WordAlignLatticeLexiconOpts>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::WordAlignLatticeLexiconOpts& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper_Type, NULL, NULL);
  reinterpret_cast<__word__align__lattice__lexicon_clifwrap::pyWordAlignLatticeLexiconOpts::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::WordAlignLatticeLexiconOpts>(c);
  return py;
}

}  // namespace kaldi
