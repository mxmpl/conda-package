//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/lat/minimize-lattice.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/mutable-fst-clifwrap.h"
#include "minimize-lattice-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __minimize__lattice_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// minimize_compact_lattice(clat:CompactLatticeMutableFst, delta:float=default) -> bool
static PyObject* wrapMinimizeCompactLattice_as_minimize_compact_lattice(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("clat"),
      C("delta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:minimize_compact_lattice", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("minimize_compact_lattice", names[0], "::fst::MutableFst< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("minimize_compact_lattice", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::MinimizeCompactLattice(arg1); break;
  case 2:
    ret0 = ::fst::MinimizeCompactLattice(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("minimize_compact_lattice"), (PyCFunction)wrapMinimizeCompactLattice_as_minimize_compact_lattice, METH_VARARGS | METH_KEYWORDS, C("minimize_compact_lattice(clat:CompactLatticeMutableFst, delta:float=default) -> bool\n\nApplies a specialized minimization operation to compact lattices.\n\nIt is to be called after determinization and pushing. If the lattice is\nnot determinized and pushed this function will not combine as many states\nas it could, but it won't throw an exception. The output will be\ntopologically sorted.\n\nReturns:\n  True on success, False if topological sorting fails.\n\nSee Also:\n  :meth:`determinize_lattice_pruned`\n  :meth:`push_compact_lattice_strings`\n  :meth:`push_compact_lattice_weights`")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_minimize_lattice",  // module name
  "CLIF-generated module for lat/minimize-lattice.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_mutable_fst")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __minimize__lattice_clifwrap
