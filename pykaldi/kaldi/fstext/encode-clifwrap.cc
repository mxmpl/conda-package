//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/encode.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "fstext/getters-clifwrap.h"
#include "fstext/symbol-table-clifwrap.h"
#include "fstext/float-weight-clifwrap.h"
#include "fstext/lattice-weight-clifwrap.h"
#include "fstext/lexicographic-weight-clifwrap.h"
#include "fstext/arc-clifwrap.h"
#include "encode-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __encode_clifwrap {
using namespace clif;
using namespace fst;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyStdEncodeTable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("flags"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyTuple {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple> cpp;
};
static ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:TropicalWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("Input label.")},
  {C("olabel"), get_olabel, set_olabel, C("Output label.")},
  {C("weight"), get_weight, set_weight, C("Weight.")},
  {}
};

// Tuple __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Tuple __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Tuple __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.StdEncodeTable.Tuple",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "StdArc encoding tuple.",            // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Tuple takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable_ArcTpl_TropicalWeightTpl_float____Tuple"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* c = static_cast<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTuple

// encode(arc:StdArc) -> int
static PyObject* wrapEncode_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:encode", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Encode(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_label(arc:StdArc) -> int
static PyObject* wrapGetLabel_as_get_label(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_label", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_label", names[0], "::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetLabel(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// decode(key:int) -> Tuple
static PyObject* wrapDecode_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:decode", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Decode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size() -> int
static PyObject* wrapSize_as_size(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Size();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(strm:ostream, source:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(strm:istream, source:str) -> StdEncodeTable
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::internal::EncodeTable<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int)\n  Calls C++ function\n  void ::fst::internal::EncodeTable<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::EncodeTable(unsigned int)")},
  {C("encode"), (PyCFunction)wrapEncode_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(arc:StdArc) -> int\n\nEncodes the given arc (either labels or weights or both).")},
  {C("get_label"), (PyCFunction)wrapGetLabel_as_get_label, METH_VARARGS | METH_KEYWORDS, C("get_label(arc:StdArc) -> int\n\nLooks up the encoded label for the given arc.\n\nReturns -1 if arc is not found.")},
  {C("decode"), (PyCFunction)wrapDecode_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(key:int) -> Tuple\n\nDecodes an encoded arc label back to labels and cost.")},
  {C("size"), (PyCFunction)wrapSize_as_size, METH_NOARGS, C("size() -> int\n\nReturns the size of the table.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(strm:ostream, source:str) -> bool\n\nWrites table to output stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(strm:istream, source:str) -> StdEncodeTable\n\nReads encode table from input stream.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoding flags.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbols.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbols.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets input symbols.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets output symbols.")},
  {}
};

// StdEncodeTable __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdEncodeTable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdEncodeTable __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.StdEncodeTable",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Encode table for StdArc.\n\nStdEncodeTable(flags):\n  Creates a new encode table with the given flags.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdEncodeTable

namespace pyLogEncodeTable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> cpp;
};
static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int)
static PyObject* wrapLogWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("flags"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyTuple {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple> cpp;
};
static ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:LogWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("Input label.")},
  {C("olabel"), get_olabel, set_olabel, C("Output label.")},
  {C("weight"), get_weight, set_weight, C("Weight.")},
  {}
};

// Tuple __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Tuple __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Tuple __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LogEncodeTable.Tuple",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "LogArc encoding tuple.",            // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Tuple takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable_ArcTpl_LogWeightTpl_float____Tuple"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* c = static_cast<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTuple

// encode(arc:LogArc) -> int
static PyObject* wrapEncode_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:encode", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::ArcTpl< ::fst::LogWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Encode(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_label(arc:LogArc) -> int
static PyObject* wrapGetLabel_as_get_label(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_label", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_label", names[0], "::fst::ArcTpl< ::fst::LogWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetLabel(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// decode(key:int) -> Tuple
static PyObject* wrapDecode_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:decode", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Decode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size() -> int
static PyObject* wrapSize_as_size(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Size();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(strm:ostream, source:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(strm:istream, source:str) -> LogEncodeTable
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::internal::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float> > >::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLogWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int)\n  Calls C++ function\n  void ::fst::internal::EncodeTable<fst::ArcTpl<fst::LogWeightTpl<float> > >::EncodeTable(unsigned int)")},
  {C("encode"), (PyCFunction)wrapEncode_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(arc:LogArc) -> int\n\nEncodes the given arc (either labels or weights or both).")},
  {C("get_label"), (PyCFunction)wrapGetLabel_as_get_label, METH_VARARGS | METH_KEYWORDS, C("get_label(arc:LogArc) -> int\n\nLooks up the encoded label for the given arc.\n\nReturns -1 if arc is not found.")},
  {C("decode"), (PyCFunction)wrapDecode_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(key:int) -> Tuple\n\nDecodes an encoded arc label back to labels and cost.")},
  {C("size"), (PyCFunction)wrapSize_as_size, METH_NOARGS, C("size() -> int\n\nReturns the size of the table.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(strm:ostream, source:str) -> bool\n\nWrites table to output stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(strm:istream, source:str) -> LogEncodeTable\n\nReads encode table from input stream.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoding flags.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbols.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbols.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets input symbols.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets output symbols.")},
  {}
};

// LogEncodeTable __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LogEncodeTable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LogEncodeTable __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LogEncodeTable",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Encode table for LogArc.\n\nLogEncodeTable(flags):\n  Creates a new encode table with the given flags.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLogWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable__fst_ArcTpl__fst_LogWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = static_cast<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLogEncodeTable

namespace pyLatticeEncodeTable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> cpp;
};
static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int)
static PyObject* wrapLatticeWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("flags"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyTuple {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple> cpp;
};
static ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:LatticeWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("Input label.")},
  {C("olabel"), get_olabel, set_olabel, C("Output label.")},
  {C("weight"), get_weight, set_weight, C("Weight.")},
  {}
};

// Tuple __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Tuple __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Tuple __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LatticeEncodeTable.Tuple",  // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "LatticeArc encoding tuple.",        // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Tuple takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable_ArcTpl_LatticeWeightTpl_float____Tuple"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* c = static_cast<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTuple

// encode(arc:LatticeArc) -> int
static PyObject* wrapEncode_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:encode", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Encode(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_label(arc:LatticeArc) -> int
static PyObject* wrapGetLabel_as_get_label(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_label", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_label", names[0], "::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetLabel(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// decode(key:int) -> Tuple
static PyObject* wrapDecode_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:decode", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Decode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size() -> int
static PyObject* wrapSize_as_size(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Size();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(strm:ostream, source:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(strm:istream, source:str) -> LatticeEncodeTable
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::internal::EncodeTable<fst::ArcTpl<fst::LatticeWeightTpl<float> > >::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLatticeWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int)\n  Calls C++ function\n  void ::fst::internal::EncodeTable<fst::ArcTpl<fst::LatticeWeightTpl<float> > >::EncodeTable(unsigned int)")},
  {C("encode"), (PyCFunction)wrapEncode_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(arc:LatticeArc) -> int\n\nEncodes the given arc (either labels or weights or both).")},
  {C("get_label"), (PyCFunction)wrapGetLabel_as_get_label, METH_VARARGS | METH_KEYWORDS, C("get_label(arc:LatticeArc) -> int\n\nLooks up the encoded label for the given arc.\n\nReturns -1 if arc is not found.")},
  {C("decode"), (PyCFunction)wrapDecode_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(key:int) -> Tuple\n\nDecodes an encoded arc label back to labels and cost.")},
  {C("size"), (PyCFunction)wrapSize_as_size, METH_NOARGS, C("size() -> int\n\nReturns the size of the table.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(strm:ostream, source:str) -> bool\n\nWrites table to output stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(strm:istream, source:str) -> LatticeEncodeTable\n\nReads encode table from input stream.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoding flags.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbols.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbols.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets input symbols.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets output symbols.")},
  {}
};

// LatticeEncodeTable __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LatticeEncodeTable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LatticeEncodeTable __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LatticeEncodeTable",        // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Encode table for LatticeArc.\n\nLatticeEncodeTable(flags):\n  Creates a new encode table with the given flags.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLatticeWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable__fst_ArcTpl__fst_LatticeWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = static_cast<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLatticeEncodeTable

namespace pyCompactLatticeEncodeTable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> cpp;
};
static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* ThisPtr(PyObject*);

// __init__(flags:int)
static PyObject* wrapLatticeWeightTpl_float__int_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("flags"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyTuple {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple> cpp;
};
static ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:CompactLatticeWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("Input label.")},
  {C("olabel"), get_olabel, set_olabel, C("Output label.")},
  {C("weight"), get_weight, set_weight, C("Weight.")},
  {}
};

// Tuple __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Tuple __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Tuple __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.CompactLatticeEncodeTable.Tuple", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CompactLatticeArc encoding tuple.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Tuple takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable_ArcTpl_CompactLatticeWeightTpl_LatticeWeightTpl_float__int____Tuple"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* c = static_cast<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTuple

// encode(arc:CompactLatticeArc) -> int
static PyObject* wrapEncode_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:encode", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Encode(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_label(arc:CompactLatticeArc) -> int
static PyObject* wrapGetLabel_as_get_label(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_label", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_label", names[0], "::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetLabel(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// decode(key:int) -> Tuple
static PyObject* wrapDecode_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:decode", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Decode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size() -> int
static PyObject* wrapSize_as_size(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Size();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(strm:ostream, source:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(strm:istream, source:str) -> CompactLatticeEncodeTable
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::internal::EncodeTable<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int> > >::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLatticeWeightTpl_float__int_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int)\n  Calls C++ function\n  void ::fst::internal::EncodeTable<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int> > >::EncodeTable(unsigned int)")},
  {C("encode"), (PyCFunction)wrapEncode_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(arc:CompactLatticeArc) -> int\n\nEncodes the given arc (either labels or weights or both).")},
  {C("get_label"), (PyCFunction)wrapGetLabel_as_get_label, METH_VARARGS | METH_KEYWORDS, C("get_label(arc:CompactLatticeArc) -> int\n\nLooks up the encoded label for the given arc.\n\nReturns -1 if arc is not found.")},
  {C("decode"), (PyCFunction)wrapDecode_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(key:int) -> Tuple\n\nDecodes an encoded arc label back to labels and cost.")},
  {C("size"), (PyCFunction)wrapSize_as_size, METH_NOARGS, C("size() -> int\n\nReturns the size of the table.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(strm:ostream, source:str) -> bool\n\nWrites table to output stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(strm:istream, source:str) -> CompactLatticeEncodeTable\n\nReads encode table from input stream.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoding flags.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbols.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbols.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets input symbols.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets output symbols.")},
  {}
};

// CompactLatticeEncodeTable __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompactLatticeEncodeTable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompactLatticeEncodeTable __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.CompactLatticeEncodeTable", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Encode table for CompactLatticeArc.\n\nCompactLatticeEncodeTable(flags):\n  Creates a new encode table with the given flags.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLatticeWeightTpl_float__int_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable__fst_ArcTpl__fst_CompactLatticeWeightTpl__fst_LatticeWeightTpl_float__int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = static_cast<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompactLatticeEncodeTable

namespace pyKwsIndexEncodeTable {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> cpp;
};
static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* ThisPtr(PyObject*);

// __init__(flags:int)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("flags"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__init__", names, &a[0])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

namespace pyTuple {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple> cpp;
};
static ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* ThisPtr(PyObject*);

static PyObject* get_ilabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->ilabel, {});
}

static int set_ilabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the ilabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->ilabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for ilabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_olabel(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->olabel, {});
}

static int set_olabel(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the olabel attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->olabel)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for olabel:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_weight(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->weight), {});
}

static int set_weight(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the weight attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->weight)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for weight:KwsIndexWeight", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("ilabel"), get_ilabel, set_ilabel, C("Input label.")},
  {C("olabel"), get_olabel, set_olabel, C("Output label.")},
  {C("weight"), get_weight, set_weight, C("Weight.")},
  {}
};

// Tuple __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Tuple __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Tuple __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.KwsIndexEncodeTable.Tuple", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "KwsIndexArc encoding tuple.",       // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Tuple takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable_ArcTpl_LexicographicWeight_TropicalWeightTpl_float__LexicographicWeight_TropicalWeightTpl_float__TropicalWeightTpl_float______Tuple"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* c = static_cast<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyTuple

// encode(arc:KwsIndexArc) -> int
static PyObject* wrapEncode_as_encode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:encode", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("encode", names[0], "::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Encode(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_label(arc:KwsIndexArc) -> int
static PyObject* wrapGetLabel_as_get_label(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:get_label", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_label", names[0], "::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->GetLabel(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// decode(key:int) -> Tuple
static PyObject* wrapDecode_as_decode(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("key"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:decode", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("decode", names[0], "int", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Decode(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size() -> int
static PyObject* wrapSize_as_size(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Size();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(strm:ostream, source:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(strm:istream, source:str) -> KwsIndexEncodeTable
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("strm"),
      C("source"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  ::std::string arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::std::string", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::internal::EncodeTable<fst::ArcTpl<fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::TropicalWeightTpl<float> > > > >::Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int)\n  Calls C++ function\n  void ::fst::internal::EncodeTable<fst::ArcTpl<fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::TropicalWeightTpl<float> > > > >::EncodeTable(unsigned int)")},
  {C("encode"), (PyCFunction)wrapEncode_as_encode, METH_VARARGS | METH_KEYWORDS, C("encode(arc:KwsIndexArc) -> int\n\nEncodes the given arc (either labels or weights or both).")},
  {C("get_label"), (PyCFunction)wrapGetLabel_as_get_label, METH_VARARGS | METH_KEYWORDS, C("get_label(arc:KwsIndexArc) -> int\n\nLooks up the encoded label for the given arc.\n\nReturns -1 if arc is not found.")},
  {C("decode"), (PyCFunction)wrapDecode_as_decode, METH_VARARGS | METH_KEYWORDS, C("decode(key:int) -> Tuple\n\nDecodes an encoded arc label back to labels and cost.")},
  {C("size"), (PyCFunction)wrapSize_as_size, METH_NOARGS, C("size() -> int\n\nReturns the size of the table.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(strm:ostream, source:str) -> bool\n\nWrites table to output stream.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(strm:istream, source:str) -> KwsIndexEncodeTable\n\nReads encode table from input stream.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoding flags.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbols.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbols.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets input symbols.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets output symbols.")},
  {}
};

// KwsIndexEncodeTable __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// KwsIndexEncodeTable __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// KwsIndexEncodeTable __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.KwsIndexEncodeTable",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Encode table for KwsIndexArc.\n\nKwsIndexEncodeTable(flags):\n  Creates a new encode table with the given flags.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_internal_EncodeTable__fst_ArcTpl__fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >"));
      if (!PyErr_Occurred()) {
        ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = static_cast<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyKwsIndexEncodeTable

namespace pyStdEncodeMapper {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> cpp;
};
static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int, type:EncodeType)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("flags"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(mapper:StdEncodeMapper) -> StdEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other_with_type(mapper:StdEncodeMapper, type:EncodeType) -> StdEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other_with_type(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("mapper"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_other_with_type", names, &a[0], &a[1])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other_with_type", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other_with_type", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __call__(arc:StdArc) -> StdArc
static PyObject* wrap__call__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__call__", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__call__", names[0], "::fst::ArcTpl< ::fst::TropicalWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties(inprops:int) -> int
static PyObject* wrapProperties_as_properties(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("inprops"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:properties", names, &a[0])) return nullptr;
  unsigned long arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("properties", names[0], "unsigned long", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> EncodeType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EncodeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(filename:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:write", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(filename:str, type:EncodeType=default) -> StdEncodeMapper
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("filename"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:read", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::string", a[0]);
  ::fst::EncodeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::fst::EncodeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::Read(std::move(arg1)); break;
  case 2:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::TropicalWeightTpl<float> > >::Read(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int, type:EncodeType)\n\nThis class provides an object which can be used to encode or decode FST\narcs. This is most useful to convert an FST to an unweighted acceptor,\non which some FST operations are more efficient, and then decoding the\nFST afterwards.\n\nTo use an instance of this class to encode or decode a mutable FST,\npass it as the first argument to the FST instance methods `encode` and\n`decode`.  Alternatively, an instance of this class can be used as a\ncallable to encode/decode arcs.\n\nArgs:\n    flags (int): Encoder flags.\n    type (EncodeType): Encoder type.")},
  {C("from_other"), (PyCFunction)wrapEncodeMapper_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(mapper:StdEncodeMapper) -> StdEncodeMapper\n\nCreates a new encoder with the contents of another.")},
  {C("from_other_with_type"), (PyCFunction)wrapEncodeMapper_as_from_other_with_type, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other_with_type(mapper:StdEncodeMapper, type:EncodeType) -> StdEncodeMapper\n\nCreates a new encoder with the contents of another and given type.")},
  {C("__call__"), (PyCFunction)wrap__call__, METH_VARARGS | METH_KEYWORDS, C("__call__(arc:StdArc) -> StdArc\n\nUses the encoder to encode/decode an arc.\n\nArgs:\n    arc: input arc to be encoded/decoded\n\nRaises:\n  RuntimeError: Incompatible or invalid weight.")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_VARARGS | METH_KEYWORDS, C("properties(inprops:int) -> int\n\nProvides property bits.\n\nThis method provides user access to the properties attributes for the\nencoder. The resulting value is a long integer, but when it is cast to a\nboolean, it represents whether or not the FST has the `mask` property.\n\nArgs:\n  mask: The property mask to be compared to the encoder's properties.\n\nReturns:\n  A 64-bit bitmask representing the requested properties.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoder flags.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> EncodeType\n\nReturns encoder type.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(filename:str) -> bool\n\nWrites encoder to file.\n\nReturns:\n    True if write was successful, False otherwise.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(filename:str, type:EncodeType=default) -> StdEncodeMapper\n\nReads encoder from file.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbol table.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbol table.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets the input symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_output_symbols`.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets the output symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_input_symbols`.")},
  {}
};

// StdEncodeMapper __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// StdEncodeMapper __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// StdEncodeMapper __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.StdEncodeMapper",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  (ternaryfunc)wrap__call__,           // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Arc encoder for an FST over the tropical semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_EncodeMapper__fst_ArcTpl__fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c = static_cast<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyStdEncodeMapper

namespace pyLogEncodeMapper {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> cpp;
};
static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int, type:EncodeType)
static PyObject* wrapLogWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("flags"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(mapper:LogEncodeMapper) -> LogEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other_with_type(mapper:LogEncodeMapper, type:EncodeType) -> LogEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other_with_type(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("mapper"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_other_with_type", names, &a[0], &a[1])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other_with_type", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other_with_type", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __call__(arc:LogArc) -> LogArc
static PyObject* wrap__call__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__call__", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__call__", names[0], "::fst::ArcTpl< ::fst::LogWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ArcTpl< ::fst::LogWeightTpl<float> > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties(inprops:int) -> int
static PyObject* wrapProperties_as_properties(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("inprops"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:properties", names, &a[0])) return nullptr;
  unsigned long arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("properties", names[0], "unsigned long", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> EncodeType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EncodeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(filename:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:write", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(filename:str, type:EncodeType=default) -> LogEncodeMapper
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("filename"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:read", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::string", a[0]);
  ::fst::EncodeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::fst::EncodeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float> > >::Read(std::move(arg1)); break;
  case 2:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LogWeightTpl<float> > >::Read(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLogWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int, type:EncodeType)\n\nThis class provides an object which can be used to encode or decode FST\narcs. This is most useful to convert an FST to an unweighted acceptor,\non which some FST operations are more efficient, and then decoding the\nFST afterwards.\n\nTo use an instance of this class to encode or decode a mutable FST,\npass it as the first argument to the FST instance methods `encode` and\n`decode`.  Alternatively, an instance of this class can be used as a\ncallable to encode/decode arcs.\n\nArgs:\n    flags (int): Encoder flags.\n    type (EncodeType): Encoder type.")},
  {C("from_other"), (PyCFunction)wrapEncodeMapper_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(mapper:LogEncodeMapper) -> LogEncodeMapper\n\nCreates a new encoder with the contents of another.")},
  {C("from_other_with_type"), (PyCFunction)wrapEncodeMapper_as_from_other_with_type, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other_with_type(mapper:LogEncodeMapper, type:EncodeType) -> LogEncodeMapper\n\nCreates a new encoder with the contents of another and given type.")},
  {C("__call__"), (PyCFunction)wrap__call__, METH_VARARGS | METH_KEYWORDS, C("__call__(arc:LogArc) -> LogArc\n\nUses the encoder to encode/decode an arc.\n\nArgs:\n    arc: input arc to be encoded/decoded\n\nRaises:\n  RuntimeError: Incompatible or invalid weight.")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_VARARGS | METH_KEYWORDS, C("properties(inprops:int) -> int\n\nProvides property bits.\n\nThis method provides user access to the properties attributes for the\nencoder. The resulting value is a long integer, but when it is cast to a\nboolean, it represents whether or not the FST has the `mask` property.\n\nArgs:\n  mask: The property mask to be compared to the encoder's properties.\n\nReturns:\n  A 64-bit bitmask representing the requested properties.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoder flags.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> EncodeType\n\nReturns encoder type.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(filename:str) -> bool\n\nWrites encoder to file.\n\nReturns:\n    True if write was successful, False otherwise.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(filename:str, type:EncodeType=default) -> LogEncodeMapper\n\nReads encoder from file.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbol table.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbol table.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets the input symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_output_symbols`.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets the output symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_input_symbols`.")},
  {}
};

// LogEncodeMapper __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LogEncodeMapper __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LogEncodeMapper __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LogEncodeMapper",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  (ternaryfunc)wrap__call__,           // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Arc encoder for an FST over the log semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLogWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_EncodeMapper__fst_ArcTpl__fst_LogWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c = static_cast<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLogEncodeMapper

namespace pyLatticeEncodeMapper {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> cpp;
};
static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* ThisPtr(PyObject*);

// __init__(flags:int, type:EncodeType)
static PyObject* wrapLatticeWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("flags"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(mapper:LatticeEncodeMapper) -> LatticeEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other_with_type(mapper:LatticeEncodeMapper, type:EncodeType) -> LatticeEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other_with_type(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("mapper"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_other_with_type", names, &a[0], &a[1])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other_with_type", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other_with_type", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __call__(arc:LatticeArc) -> LatticeArc
static PyObject* wrap__call__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__call__", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__call__", names[0], "::fst::ArcTpl< ::fst::LatticeWeightTpl<float> >", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties(inprops:int) -> int
static PyObject* wrapProperties_as_properties(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("inprops"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:properties", names, &a[0])) return nullptr;
  unsigned long arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("properties", names[0], "unsigned long", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> EncodeType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EncodeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(filename:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:write", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(filename:str, type:EncodeType=default) -> LatticeEncodeMapper
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("filename"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:read", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::string", a[0]);
  ::fst::EncodeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::fst::EncodeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LatticeWeightTpl<float> > >::Read(std::move(arg1)); break;
  case 2:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LatticeWeightTpl<float> > >::Read(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLatticeWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int, type:EncodeType)\n\nThis class provides an object which can be used to encode or decode FST\narcs. This is most useful to convert an FST to an unweighted acceptor,\non which some FST operations are more efficient, and then decoding the\nFST afterwards.\n\nTo use an instance of this class to encode or decode a mutable FST,\npass it as the first argument to the FST instance methods `encode` and\n`decode`.  Alternatively, an instance of this class can be used as a\ncallable to encode/decode arcs.\n\nArgs:\n    flags (int): Encoder flags.\n    type (EncodeType): Encoder type.")},
  {C("from_other"), (PyCFunction)wrapEncodeMapper_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(mapper:LatticeEncodeMapper) -> LatticeEncodeMapper\n\nCreates a new encoder with the contents of another.")},
  {C("from_other_with_type"), (PyCFunction)wrapEncodeMapper_as_from_other_with_type, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other_with_type(mapper:LatticeEncodeMapper, type:EncodeType) -> LatticeEncodeMapper\n\nCreates a new encoder with the contents of another and given type.")},
  {C("__call__"), (PyCFunction)wrap__call__, METH_VARARGS | METH_KEYWORDS, C("__call__(arc:LatticeArc) -> LatticeArc\n\nUses the encoder to encode/decode an arc.\n\nArgs:\n    arc: input arc to be encoded/decoded\n\nRaises:\n  RuntimeError: Incompatible or invalid weight.")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_VARARGS | METH_KEYWORDS, C("properties(inprops:int) -> int\n\nProvides property bits.\n\nThis method provides user access to the properties attributes for the\nencoder. The resulting value is a long integer, but when it is cast to a\nboolean, it represents whether or not the FST has the `mask` property.\n\nArgs:\n  mask: The property mask to be compared to the encoder's properties.\n\nReturns:\n  A 64-bit bitmask representing the requested properties.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoder flags.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> EncodeType\n\nReturns encoder type.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(filename:str) -> bool\n\nWrites encoder to file.\n\nReturns:\n    True if write was successful, False otherwise.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(filename:str, type:EncodeType=default) -> LatticeEncodeMapper\n\nReads encoder from file.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbol table.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbol table.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets the input symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_output_symbols`.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets the output symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_input_symbols`.")},
  {}
};

// LatticeEncodeMapper __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LatticeEncodeMapper __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LatticeEncodeMapper __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.LatticeEncodeMapper",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  (ternaryfunc)wrap__call__,           // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Arc encoder for an FST over the lattice semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLatticeWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_EncodeMapper__fst_ArcTpl__fst_LatticeWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >"));
      if (!PyErr_Occurred()) {
        ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c = static_cast<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLatticeEncodeMapper

namespace pyCompactLatticeEncodeMapper {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> cpp;
};
static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* ThisPtr(PyObject*);

// __init__(flags:int, type:EncodeType)
static PyObject* wrapLatticeWeightTpl_float__int_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("flags"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(mapper:CompactLatticeEncodeMapper) -> CompactLatticeEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other_with_type(mapper:CompactLatticeEncodeMapper, type:EncodeType) -> CompactLatticeEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other_with_type(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("mapper"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_other_with_type", names, &a[0], &a[1])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other_with_type", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other_with_type", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __call__(arc:CompactLatticeArc) -> CompactLatticeArc
static PyObject* wrap__call__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__call__", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__call__", names[0], "::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> >", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties(inprops:int) -> int
static PyObject* wrapProperties_as_properties(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("inprops"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:properties", names, &a[0])) return nullptr;
  unsigned long arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("properties", names[0], "unsigned long", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> EncodeType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EncodeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(filename:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:write", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(filename:str, type:EncodeType=default) -> CompactLatticeEncodeMapper
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("filename"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:read", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::string", a[0]);
  ::fst::EncodeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::fst::EncodeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int> > >::Read(std::move(arg1)); break;
  case 2:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::CompactLatticeWeightTpl<fst::LatticeWeightTpl<float>, int> > >::Read(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLatticeWeightTpl_float__int_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int, type:EncodeType)\n\nThis class provides an object which can be used to encode or decode FST\narcs. This is most useful to convert an FST to an unweighted acceptor,\non which some FST operations are more efficient, and then decoding the\nFST afterwards.\n\nTo use an instance of this class to encode or decode a mutable FST,\npass it as the first argument to the FST instance methods `encode` and\n`decode`.  Alternatively, an instance of this class can be used as a\ncallable to encode/decode arcs.\n\nArgs:\n    flags (int): Encoder flags.\n    type (EncodeType): Encoder type.")},
  {C("from_other"), (PyCFunction)wrapEncodeMapper_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(mapper:CompactLatticeEncodeMapper) -> CompactLatticeEncodeMapper\n\nCreates a new encoder with the contents of another.")},
  {C("from_other_with_type"), (PyCFunction)wrapEncodeMapper_as_from_other_with_type, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other_with_type(mapper:CompactLatticeEncodeMapper, type:EncodeType) -> CompactLatticeEncodeMapper\n\nCreates a new encoder with the contents of another and given type.")},
  {C("__call__"), (PyCFunction)wrap__call__, METH_VARARGS | METH_KEYWORDS, C("__call__(arc:CompactLatticeArc) -> CompactLatticeArc\n\nUses the encoder to encode/decode an arc.\n\nArgs:\n    arc: input arc to be encoded/decoded\n\nRaises:\n  RuntimeError: Incompatible or invalid weight.")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_VARARGS | METH_KEYWORDS, C("properties(inprops:int) -> int\n\nProvides property bits.\n\nThis method provides user access to the properties attributes for the\nencoder. The resulting value is a long integer, but when it is cast to a\nboolean, it represents whether or not the FST has the `mask` property.\n\nArgs:\n  mask: The property mask to be compared to the encoder's properties.\n\nReturns:\n  A 64-bit bitmask representing the requested properties.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoder flags.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> EncodeType\n\nReturns encoder type.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(filename:str) -> bool\n\nWrites encoder to file.\n\nReturns:\n    True if write was successful, False otherwise.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(filename:str, type:EncodeType=default) -> CompactLatticeEncodeMapper\n\nReads encoder from file.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbol table.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbol table.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets the input symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_output_symbols`.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets the output symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_input_symbols`.")},
  {}
};

// CompactLatticeEncodeMapper __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CompactLatticeEncodeMapper __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CompactLatticeEncodeMapper __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.CompactLatticeEncodeMapper", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  (ternaryfunc)wrap__call__,           // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Arc encoder for an FST over the compact lattice semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLatticeWeightTpl_float__int_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_EncodeMapper__fst_ArcTpl__fst_CompactLatticeWeightTpl__fst_LatticeWeightTpl_float__int"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >"));
      if (!PyErr_Occurred()) {
        ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c = static_cast<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCompactLatticeEncodeMapper

namespace pyKwsIndexEncodeMapper {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> cpp;
};
static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* ThisPtr(PyObject*);

// __init__(flags:int, type:EncodeType)
static PyObject* wrapTropicalWeightTpl_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("flags"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  unsigned int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "unsigned int", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(mapper:KwsIndexEncodeMapper) -> KwsIndexEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mapper"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other_with_type(mapper:KwsIndexEncodeMapper, type:EncodeType) -> KwsIndexEncodeMapper
static PyObject* wrapEncodeMapper_as_from_other_with_type(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("mapper"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:from_other_with_type", names, &a[0], &a[1])) return nullptr;
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other_with_type", names[0], "::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >", a[0]);
  ::fst::EncodeType arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other_with_type", names[1], "::fst::EncodeType", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __call__(arc:KwsIndexArc) -> KwsIndexArc
static PyObject* wrap__call__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("arc"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:__call__", names, &a[0])) return nullptr;
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__call__", names[0], "::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > >", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// properties(inprops:int) -> int
static PyObject* wrapProperties_as_properties(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("inprops"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:properties", names, &a[0])) return nullptr;
  unsigned long arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("properties", names[0], "unsigned long", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned long ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Properties(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// flags() -> int
static PyObject* wrapFlags_as_flags(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Flags();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// type() -> EncodeType
static PyObject* wrapType_as_type(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EncodeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Type();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// write(filename:str) -> bool
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("filename"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:write", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::string", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Write(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod read(filename:str, type:EncodeType=default) -> KwsIndexEncodeMapper
static PyObject* wrapRead_as_read(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("filename"),
      C("type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:read", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::string", a[0]);
  ::fst::EncodeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "::fst::EncodeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::gtl::optional<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > *> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::TropicalWeightTpl<float> > > > >::Read(std::move(arg1)); break;
  case 2:
    ret0 = ::fst::EncodeMapper<fst::ArcTpl<fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::LexicographicWeight<fst::TropicalWeightTpl<float>, fst::TropicalWeightTpl<float> > > > >::Read(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0.value()), {});
}

// input_symbols() -> SymbolTable
static PyObject* wrapInputSymbols_as_input_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->InputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// output_symbols() -> SymbolTable
static PyObject* wrapOutputSymbols_as_output_symbols(PyObject* self) {
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  const ::fst::SymbolTable * ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->OutputSymbols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_input_symbols(syms:SymbolTable)
static PyObject* wrapSetInputSymbols_as_set_input_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_input_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_input_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetInputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_output_symbols(syms:SymbolTable)
static PyObject* wrapSetOutputSymbols_as_set_output_symbols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("syms"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_output_symbols", names, &a[0])) return nullptr;
  ::fst::SymbolTable * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_output_symbols", names[0], "::fst::SymbolTable *", a[0]);
  // Call actual C++ method.
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetOutputSymbols(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapTropicalWeightTpl_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(flags:int, type:EncodeType)\n\nThis class provides an object which can be used to encode or decode FST\narcs. This is most useful to convert an FST to an unweighted acceptor,\non which some FST operations are more efficient, and then decoding the\nFST afterwards.\n\nTo use an instance of this class to encode or decode a mutable FST,\npass it as the first argument to the FST instance methods `encode` and\n`decode`.  Alternatively, an instance of this class can be used as a\ncallable to encode/decode arcs.\n\nArgs:\n    flags (int): Encoder flags.\n    type (EncodeType): Encoder type.")},
  {C("from_other"), (PyCFunction)wrapEncodeMapper_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(mapper:KwsIndexEncodeMapper) -> KwsIndexEncodeMapper\n\nCreates a new encoder with the contents of another.")},
  {C("from_other_with_type"), (PyCFunction)wrapEncodeMapper_as_from_other_with_type, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other_with_type(mapper:KwsIndexEncodeMapper, type:EncodeType) -> KwsIndexEncodeMapper\n\nCreates a new encoder with the contents of another and given type.")},
  {C("__call__"), (PyCFunction)wrap__call__, METH_VARARGS | METH_KEYWORDS, C("__call__(arc:KwsIndexArc) -> KwsIndexArc\n\nUses the encoder to encode/decode an arc.\n\nArgs:\n    arc: input arc to be encoded/decoded\n\nRaises:\n  RuntimeError: Incompatible or invalid weight.")},
  {C("properties"), (PyCFunction)wrapProperties_as_properties, METH_VARARGS | METH_KEYWORDS, C("properties(inprops:int) -> int\n\nProvides property bits.\n\nThis method provides user access to the properties attributes for the\nencoder. The resulting value is a long integer, but when it is cast to a\nboolean, it represents whether or not the FST has the `mask` property.\n\nArgs:\n  mask: The property mask to be compared to the encoder's properties.\n\nReturns:\n  A 64-bit bitmask representing the requested properties.")},
  {C("flags"), (PyCFunction)wrapFlags_as_flags, METH_NOARGS, C("flags() -> int\n\nReturns encoder flags.")},
  {C("type"), (PyCFunction)wrapType_as_type, METH_NOARGS, C("type() -> EncodeType\n\nReturns encoder type.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(filename:str) -> bool\n\nWrites encoder to file.\n\nReturns:\n    True if write was successful, False otherwise.")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("read(filename:str, type:EncodeType=default) -> KwsIndexEncodeMapper\n\nReads encoder from file.")},
  {C("input_symbols"), (PyCFunction)wrapInputSymbols_as_input_symbols, METH_NOARGS, C("input_symbols() -> SymbolTable\n\nReturns input symbol table.")},
  {C("output_symbols"), (PyCFunction)wrapOutputSymbols_as_output_symbols, METH_NOARGS, C("output_symbols() -> SymbolTable\n\nReturns output symbol table.")},
  {C("set_input_symbols"), (PyCFunction)wrapSetInputSymbols_as_set_input_symbols, METH_VARARGS | METH_KEYWORDS, C("set_input_symbols(syms:SymbolTable)\n\nSets the input symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_output_symbols`.")},
  {C("set_output_symbols"), (PyCFunction)wrapSetOutputSymbols_as_set_output_symbols, METH_VARARGS | METH_KEYWORDS, C("set_output_symbols(syms:SymbolTable)\n\nSets the output symbol table.\n\nArgs:\n  syms: A SymbolTable.\n\nSee also: `set_input_symbols`.")},
  {}
};

// KwsIndexEncodeMapper __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// KwsIndexEncodeMapper __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// KwsIndexEncodeMapper __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_encode.KwsIndexEncodeMapper",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  (ternaryfunc)wrap__call__,           // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Arc encoder for an FST over the KWS index semiring.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapTropicalWeightTpl_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_fst_EncodeMapper__fst_ArcTpl__fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_LexicographicWeight__fst_TropicalWeightTpl_float___fst_TropicalWeightTpl_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >"));
      if (!PyErr_Occurred()) {
        ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c = static_cast<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyKwsIndexEncodeMapper


// Initialize module

bool Ready() {
  if (PyType_Ready(&pyStdEncodeTable::pyTuple::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdEncodeTable::pyTuple::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyStdEncodeTable::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdEncodeTable::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLogEncodeTable::pyTuple::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLogEncodeTable::pyTuple::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLogEncodeTable::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLogEncodeTable::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLatticeEncodeTable::pyTuple::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLatticeEncodeTable::pyTuple::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLatticeEncodeTable::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLatticeEncodeTable::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompactLatticeEncodeTable::pyTuple::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompactLatticeEncodeTable::pyTuple::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompactLatticeEncodeTable::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompactLatticeEncodeTable::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyKwsIndexEncodeTable::pyTuple::wrapper_Type) < 0) return false;
  Py_INCREF(&pyKwsIndexEncodeTable::pyTuple::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyKwsIndexEncodeTable::wrapper_Type) < 0) return false;
  Py_INCREF(&pyKwsIndexEncodeTable::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyStdEncodeMapper::wrapper_Type) < 0) return false;
  Py_INCREF(&pyStdEncodeMapper::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLogEncodeMapper::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLogEncodeMapper::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLatticeEncodeMapper::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLatticeEncodeMapper::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCompactLatticeEncodeMapper::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCompactLatticeEncodeMapper::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyKwsIndexEncodeMapper::wrapper_Type) < 0) return false;
  Py_INCREF(&pyKwsIndexEncodeMapper::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_encode",  // module name
  "CLIF-generated module for fst/encode.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_getters")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_symbol_table")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_float_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lattice_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_lexicographic_weight")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_arc")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyDict_SetItemString(pyStdEncodeTable::wrapper_Type.tp_dict, "Tuple", reinterpret_cast<PyObject*>(&pyStdEncodeTable::pyTuple::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyLogEncodeTable::wrapper_Type.tp_dict, "Tuple", reinterpret_cast<PyObject*>(&pyLogEncodeTable::pyTuple::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyLatticeEncodeTable::wrapper_Type.tp_dict, "Tuple", reinterpret_cast<PyObject*>(&pyLatticeEncodeTable::pyTuple::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyCompactLatticeEncodeTable::wrapper_Type.tp_dict, "Tuple", reinterpret_cast<PyObject*>(&pyCompactLatticeEncodeTable::pyTuple::wrapper_Type)) < 0) goto err;
  if (PyDict_SetItemString(pyKwsIndexEncodeTable::wrapper_Type.tp_dict, "Tuple", reinterpret_cast<PyObject*>(&pyKwsIndexEncodeTable::pyTuple::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "StdEncodeTable", reinterpret_cast<PyObject*>(&pyStdEncodeTable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LogEncodeTable", reinterpret_cast<PyObject*>(&pyLogEncodeTable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LatticeEncodeTable", reinterpret_cast<PyObject*>(&pyLatticeEncodeTable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompactLatticeEncodeTable", reinterpret_cast<PyObject*>(&pyCompactLatticeEncodeTable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "KwsIndexEncodeTable", reinterpret_cast<PyObject*>(&pyKwsIndexEncodeTable::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "ENCODE_LABELS", Clif_PyObjFrom(static_cast<::uint32>(::fst::kEncodeLabels), {})) < 0) goto err;
  if (PyModule_AddObject(module, "ENCODE_WEIGHTS", Clif_PyObjFrom(static_cast<::uint32>(::fst::kEncodeWeights), {})) < 0) goto err;
  if (PyModule_AddObject(module, "ENCODE_FLAGS", Clif_PyObjFrom(static_cast<::uint32>(::fst::kEncodeFlags), {})) < 0) goto err;
  if (PyModule_AddObject(module, "StdEncodeMapper", reinterpret_cast<PyObject*>(&pyStdEncodeMapper::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LogEncodeMapper", reinterpret_cast<PyObject*>(&pyLogEncodeMapper::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LatticeEncodeMapper", reinterpret_cast<PyObject*>(&pyLatticeEncodeMapper::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CompactLatticeEncodeMapper", reinterpret_cast<PyObject*>(&pyCompactLatticeEncodeMapper::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "KwsIndexEncodeMapper", reinterpret_cast<PyObject*>(&pyKwsIndexEncodeMapper::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __encode_clifwrap

namespace fst {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CompactLatticeEncodeMapper to/from ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompactLatticeEncodeMapper instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(std::move(c));
  return py;
}

// KwsIndexEncodeMapper to/from ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert KwsIndexEncodeMapper instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(std::move(c));
  return py;
}

// LatticeEncodeMapper to/from ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLatticeEncodeMapper::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLatticeEncodeMapper::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LatticeEncodeMapper instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(std::move(c));
  return py;
}

// LogEncodeMapper to/from ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLogEncodeMapper::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLogEncodeMapper::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LogEncodeMapper instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(std::move(c));
  return py;
}

// StdEncodeMapper to/from ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyStdEncodeMapper::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeMapper::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyStdEncodeMapper::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdEncodeMapper instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeMapper::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeMapper::wrapper*>(py)->cpp = ::clif::Instance<::fst::EncodeMapper< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

}  // namespace fst

namespace fst { namespace internal {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CompactLatticeEncodeTable to/from ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompactLatticeEncodeTable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::CompactLatticeWeightTpl< ::fst::LatticeWeightTpl<float>, int> > >>(std::move(c));
  return py;
}

// CompactLatticeEncodeTable.Tuple to/from ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CompactLatticeEncodeTable.Tuple instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* cpp = __encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyCompactLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<CompactLatticeWeightTpl<LatticeWeightTpl<float>, int> > >::Tuple>(c);
  return py;
}

// KwsIndexEncodeTable to/from ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert KwsIndexEncodeTable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::LexicographicWeight< ::fst::TropicalWeightTpl<float>, ::fst::TropicalWeightTpl<float> > > > >>(std::move(c));
  return py;
}

// KwsIndexEncodeTable.Tuple to/from ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert KwsIndexEncodeTable.Tuple instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* cpp = __encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyKwsIndexEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LexicographicWeight<TropicalWeightTpl<float>, LexicographicWeight<TropicalWeightTpl<float>, TropicalWeightTpl<float> > > > >::Tuple>(c);
  return py;
}

// LatticeEncodeTable to/from ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* cpp = __encode_clifwrap::pyLatticeEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LatticeEncodeTable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LatticeWeightTpl<float> > >>(std::move(c));
  return py;
}

// LatticeEncodeTable.Tuple to/from ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LatticeEncodeTable.Tuple instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLatticeEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLatticeEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LatticeWeightTpl<float> > >::Tuple>(c);
  return py;
}

// LogEncodeTable to/from ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* cpp = __encode_clifwrap::pyLogEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LogEncodeTable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::LogWeightTpl<float> > >>(std::move(c));
  return py;
}

// LogEncodeTable.Tuple to/from ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLogEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLogEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLogEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LogEncodeTable.Tuple instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLogEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyLogEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyLogEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<LogWeightTpl<float> > >::Tuple>(c);
  return py;
}

// StdEncodeTable to/from ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > > conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* cpp = __encode_clifwrap::pyStdEncodeTable::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdEncodeTable instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable< ::fst::ArcTpl< ::fst::TropicalWeightTpl<float> > >>(std::move(c));
  return py;
}

// StdEncodeTable.Tuple to/from ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple conversion

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyStdEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyStdEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyStdEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert StdEncodeTable.Tuple instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyStdEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>* c) {
  assert(c != nullptr);
  ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* cpp = __encode_clifwrap::pyStdEncodeTable::pyTuple::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::Instance<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper_Type, NULL, NULL);
  reinterpret_cast<__encode_clifwrap::pyStdEncodeTable::pyTuple::wrapper*>(py)->cpp = ::clif::MakeShared<::fst::internal::EncodeTable<ArcTpl<TropicalWeightTpl<float> > >::Tuple>(c);
  return py;
}

} }  // namespace fst::internal
