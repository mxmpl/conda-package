//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/weight.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "weight-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __weight_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


// Create Python Enum object (cached in _DivideType) for ::fst::DivideType
static PyObject* wrapDivideType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DIVIDE_ANY"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DivideType>::type>(::fst::DivideType::DIVIDE_ANY)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DIVIDE_RIGHT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DivideType>::type>(::fst::DivideType::DIVIDE_RIGHT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DIVIDE_LEFT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DivideType>::type>(::fst::DivideType::DIVIDE_LEFT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("DivideType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _DivideType{};  // set by above func in Init()


// Initialize module

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_weight",  // module name
  "CLIF-generated module for fst/weight.h", // module doc
  -1,  // module keeps state in global variables
  nullptr
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "DELTA", Clif_PyObjFrom(static_cast<float>(::fst::kDelta), {})) < 0) goto err;
  if (PyModule_AddObject(module, "LEFT_SEMIRING", Clif_PyObjFrom(static_cast<::uint64>(::fst::kLeftSemiring), {})) < 0) goto err;
  if (PyModule_AddObject(module, "RIGHT_SEMIRING", Clif_PyObjFrom(static_cast<::uint64>(::fst::kRightSemiring), {})) < 0) goto err;
  if (PyModule_AddObject(module, "SEMIRING", Clif_PyObjFrom(static_cast<::uint64>(::fst::kSemiring), {})) < 0) goto err;
  if (PyModule_AddObject(module, "COMMUTATIVE", Clif_PyObjFrom(static_cast<::uint64>(::fst::kCommutative), {})) < 0) goto err;
  if (PyModule_AddObject(module, "IDEMPOTENT", Clif_PyObjFrom(static_cast<::uint64>(::fst::kIdempotent), {})) < 0) goto err;
  if (PyModule_AddObject(module, "PATH", Clif_PyObjFrom(static_cast<::uint64>(::fst::kPath), {})) < 0) goto err;
  if (PyModule_AddObject(module, "NUM_RANDOM_WEIGHTS", Clif_PyObjFrom(static_cast<::size_t>(::fst::kNumRandomWeights), {})) < 0) goto err;
  if (PyModule_AddObject(module, "DivideType", (_DivideType=wrapDivideType())) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __weight_clifwrap

namespace fst {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// DivideType:IntEnum to/from enum ::fst::DivideType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::DivideType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __weight_clifwrap::_DivideType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum DivideType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::DivideType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::DivideType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::DivideType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__weight_clifwrap::_DivideType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::DivideType>::type>(c)), nullptr);
}

}  // namespace fst
