//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/fstext/getters.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "getters-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __getters_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes

static PyObject *_Enum{}, *_IntEnum{};  // set below in Init()


// Create Python Enum object (cached in _ClosureType) for ::fst::ClosureType
static PyObject* wrapClosureType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("CLOSURE_PLUS"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ClosureType>::type>(::fst::ClosureType::CLOSURE_PLUS)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("CLOSURE_STAR"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ClosureType>::type>(::fst::ClosureType::CLOSURE_STAR)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("ClosureType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ClosureType{};  // set by above func in Init()

// Create Python Enum object (cached in _ComposeFilter) for ::fst::ComposeFilter
static PyObject* wrapComposeFilter() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(6);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::MATCH_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("AUTO_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::AUTO_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ALT_SEQUENCE_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::ALT_SEQUENCE_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SEQUENCE_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::SEQUENCE_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("NULL_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::NULL_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TRIVIAL_FILTER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(::fst::ComposeFilter::TRIVIAL_FILTER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  py = PyUnicode_FromString("ComposeFilter");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ComposeFilter{};  // set by above func in Init()

// Create Python Enum object (cached in _DeterminizeType) for ::fst::DeterminizeType
static PyObject* wrapDeterminizeType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DETERMINIZE_DISAMBIGUATE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DeterminizeType>::type>(::fst::DeterminizeType::DETERMINIZE_DISAMBIGUATE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DETERMINIZE_NONFUNCTIONAL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DeterminizeType>::type>(::fst::DeterminizeType::DETERMINIZE_NONFUNCTIONAL)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DETERMINIZE_FUNCTIONAL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::DeterminizeType>::type>(::fst::DeterminizeType::DETERMINIZE_FUNCTIONAL)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("DeterminizeType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _DeterminizeType{};  // set by above func in Init()

// Create Python Enum object (cached in _EncodeType) for ::fst::EncodeType
static PyObject* wrapEncodeType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("DECODE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::EncodeType>::type>(::fst::EncodeType::DECODE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ENCODE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::EncodeType>::type>(::fst::EncodeType::ENCODE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("EncodeType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _EncodeType{};  // set by above func in Init()

// Create Python Enum object (cached in _EpsNormalizeType) for ::fst::EpsNormalizeType
static PyObject* wrapEpsNormalizeType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("EPS_NORM_OUTPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::EpsNormalizeType>::type>(::fst::EpsNormalizeType::EPS_NORM_OUTPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("EPS_NORM_INPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::EpsNormalizeType>::type>(::fst::EpsNormalizeType::EPS_NORM_INPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("EpsNormalizeType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _EpsNormalizeType{};  // set by above func in Init()

// Create Python Enum object (cached in _MatchType) for ::fst::MatchType
static PyObject* wrapMatchType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(5);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_OUTPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::MatchType>::type>(::fst::MatchType::MATCH_OUTPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_BOTH"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::MatchType>::type>(::fst::MatchType::MATCH_BOTH)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_UNKNOWN"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::MatchType>::type>(::fst::MatchType::MATCH_UNKNOWN)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_INPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::MatchType>::type>(::fst::MatchType::MATCH_INPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("MATCH_NONE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::MatchType>::type>(::fst::MatchType::MATCH_NONE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  py = PyUnicode_FromString("MatchType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _MatchType{};  // set by above func in Init()

// Create Python Enum object (cached in _ProjectType) for ::fst::ProjectType
static PyObject* wrapProjectType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("PROJECT_OUTPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ProjectType>::type>(::fst::ProjectType::PROJECT_OUTPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("PROJECT_INPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ProjectType>::type>(::fst::ProjectType::PROJECT_INPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("ProjectType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ProjectType{};  // set by above func in Init()

// Create Python Enum object (cached in _QueueType) for ::fst::QueueType
static PyObject* wrapQueueType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(9);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("OTHER_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::OTHER_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("AUTO_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::AUTO_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SCC_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::SCC_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TOP_ORDER_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::TOP_ORDER_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TRIVIAL_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::TRIVIAL_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("STATE_ORDER_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::STATE_ORDER_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("LIFO_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::LIFO_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 6, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("FIFO_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::FIFO_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 7, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SHORTEST_FIRST_QUEUE"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::QueueType>::type>(::fst::QueueType::SHORTEST_FIRST_QUEUE)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 8, py);
  py = PyUnicode_FromString("QueueType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _QueueType{};  // set by above func in Init()

// Create Python Enum object (cached in _ReplaceLabelType) for ::fst::ReplaceLabelType
static PyObject* wrapReplaceLabelType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(4);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REPLACE_LABEL_OUTPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReplaceLabelType>::type>(::fst::ReplaceLabelType::REPLACE_LABEL_OUTPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REPLACE_LABEL_BOTH"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReplaceLabelType>::type>(::fst::ReplaceLabelType::REPLACE_LABEL_BOTH)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REPLACE_LABEL_INPUT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReplaceLabelType>::type>(::fst::ReplaceLabelType::REPLACE_LABEL_INPUT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REPLACE_LABEL_NEITHER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReplaceLabelType>::type>(::fst::ReplaceLabelType::REPLACE_LABEL_NEITHER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  py = PyUnicode_FromString("ReplaceLabelType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ReplaceLabelType{};  // set by above func in Init()

// Create Python Enum object (cached in _ReweightType) for ::fst::ReweightType
static PyObject* wrapReweightType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REWEIGHT_TO_FINAL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReweightType>::type>(::fst::ReweightType::REWEIGHT_TO_FINAL)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("REWEIGHT_TO_INITIAL"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::ReweightType>::type>(::fst::ReweightType::REWEIGHT_TO_INITIAL)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("ReweightType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ReweightType{};  // set by above func in Init()

// Create Python Enum object (cached in _ArcSortType) for ::fst::script::ArcSortType
static PyObject* wrapArcSortType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(2);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("OLABEL_SORT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::ArcSortType>::type>(::fst::script::ArcSortType::OLABEL_SORT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ILABEL_SORT"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::ArcSortType>::type>(::fst::script::ArcSortType::ILABEL_SORT)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  py = PyUnicode_FromString("ArcSortType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _ArcSortType{};  // set by above func in Init()

// Create Python Enum object (cached in _MapType) for ::fst::script::MapType
static PyObject* wrapMapType() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(14);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TO_STD_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::TO_STD_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TO_LOG64_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::TO_LOG64_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TO_LOG_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::TO_LOG_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("TIMES_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::TIMES_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 3, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("INPUT_EPSILON_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::INPUT_EPSILON_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 4, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ARC_UNIQUE_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::ARC_UNIQUE_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 5, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("IDENTITY_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::IDENTITY_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 6, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("ARC_SUM_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::ARC_SUM_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 7, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("QUANTIZE_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::QUANTIZE_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 8, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("INVERT_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::INVERT_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 9, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("SUPERFINAL_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::SUPERFINAL_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 10, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("OUTPUT_EPSILON_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::OUTPUT_EPSILON_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 11, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("PLUS_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::PLUS_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 12, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("RMWEIGHT_MAPPER"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::MapType>::type>(::fst::script::MapType::RMWEIGHT_MAPPER)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 13, py);
  py = PyUnicode_FromString("MapType");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _MapType{};  // set by above func in Init()

// Create Python Enum object (cached in _RandArcSelection) for ::fst::script::RandArcSelection
static PyObject* wrapRandArcSelection() {
  PyObject *py, *py_enum_class{}, *names = PyTuple_New(3);
  if (names == nullptr) return nullptr;
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("FAST_LOG_PROB_ARC_SELECTOR"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::RandArcSelection>::type>(::fst::script::RandArcSelection::FAST_LOG_PROB_ARC_SELECTOR)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 0, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("LOG_PROB_ARC_SELECTOR"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::RandArcSelection>::type>(::fst::script::RandArcSelection::LOG_PROB_ARC_SELECTOR)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 1, py);
  if ((py = Py_BuildValue("(NN)", PyUnicode_FromString("UNIFORM_ARC_SELECTOR"), PyInt_FromLong(
        static_cast<typename std::underlying_type<::fst::script::RandArcSelection>::type>(::fst::script::RandArcSelection::UNIFORM_ARC_SELECTOR)))
      ) == nullptr) goto err;
  PyTuple_SET_ITEM(names, 2, py);
  py = PyUnicode_FromString("RandArcSelection");
  py_enum_class = PyObject_CallFunctionObjArgs(_IntEnum, py, names, nullptr);
  Py_DECREF(py);
err:
  Py_DECREF(names);
  return py_enum_class;
}
static PyObject* _RandArcSelection{};  // set by above func in Init()

// GetArcSortType(str:str) -> (success:bool, sort_type:ArcSortType)
static PyObject* wrapGetArcSortType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetArcSortType", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetArcSortType", names[0], "::std::string", a[0]);
  ::fst::script::ArcSortType ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetArcSortType(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetClosureType(closure_plus:bool) -> ClosureType
static PyObject* wrapGetClosureType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("closure_plus"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetClosureType", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetClosureType", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ClosureType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetClosureType(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// GetComposeFilter(str:str) -> (success:bool, compose_filter:ComposeFilter)
static PyObject* wrapGetComposeFilter(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetComposeFilter", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetComposeFilter", names[0], "::std::string", a[0]);
  ::fst::ComposeFilter ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetComposeFilter(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetDeterminizeType(str:str) -> (success:bool, det_type:DeterminizeType)
static PyObject* wrapGetDeterminizeType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetDeterminizeType", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetDeterminizeType", names[0], "::std::string", a[0]);
  ::fst::DeterminizeType ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetDeterminizeType(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetEncodeFlags(encode_labels:bool, encode_weights:bool) -> int
static PyObject* wrapGetEncodeFlags(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("encode_labels"),
      C("encode_weights"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:GetEncodeFlags", names, &a[0], &a[1])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetEncodeFlags", names[0], "bool", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("GetEncodeFlags", names[1], "bool", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetEncodeFlags(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// GetEpsNormalizeType(eps_norm_output:bool) -> EpsNormalizeType
static PyObject* wrapGetEpsNormalizeType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("eps_norm_output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetEpsNormalizeType", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetEpsNormalizeType", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::EpsNormalizeType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetEpsNormalizeType(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// GetMapType(str:str) -> (success:bool, sort_type:MapType)
static PyObject* wrapGetMapType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetMapType", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetMapType", names[0], "::std::string", a[0]);
  ::fst::script::MapType ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetMapType(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetProjectType(project_output:bool) -> ProjectType
static PyObject* wrapGetProjectType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("project_output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetProjectType", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetProjectType", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ProjectType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetProjectType(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// GetPushFlags(push_weights:bool, push_labels:bool, remove_total_weight:bool, remove_common_affix:bool) -> int
static PyObject* wrapGetPushFlags(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("push_weights"),
      C("push_labels"),
      C("remove_total_weight"),
      C("remove_common_affix"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:GetPushFlags", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetPushFlags", names[0], "bool", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("GetPushFlags", names[1], "bool", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("GetPushFlags", names[2], "bool", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("GetPushFlags", names[3], "bool", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  unsigned int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetPushFlags(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// GetQueueType(str:str) -> (success:bool, queue_type:QueueType)
static PyObject* wrapGetQueueType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetQueueType", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetQueueType", names[0], "::std::string", a[0]);
  ::fst::QueueType ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetQueueType(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetRandArcSelection(str:str) -> (success:bool, ras:RandArcSelection)
static PyObject* wrapGetRandArcSelection(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("str"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetRandArcSelection", names, &a[0])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetRandArcSelection", names[0], "::std::string", a[0]);
  ::fst::script::RandArcSelection ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetRandArcSelection(std::move(arg1), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetReplaceLabelType(str:str, epsilon_on_replace:bool) -> (success:bool, rlt:ReplaceLabelType)
static PyObject* wrapGetReplaceLabelType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("str"),
      C("epsilon_on_replace"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:GetReplaceLabelType", names, &a[0], &a[1])) return nullptr;
  ::std::string arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetReplaceLabelType", names[0], "::std::string", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("GetReplaceLabelType", names[1], "bool", a[1]);
  ::fst::ReplaceLabelType ret1{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetReplaceLabelType(std::move(arg1), std::move(arg2), &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  PyObject* pyproc = ImportFQName("kaldi.util._value_error_on_false");
  if (pyproc == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  p = PyObject_CallObject(pyproc, result_tuple);
  Py_DECREF(pyproc);
  Py_CLEAR(result_tuple);
  result_tuple = p;
  return result_tuple;
}

// GetReweightType(to_final:bool) -> ReweightType
static PyObject* wrapGetReweightType(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("to_final"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:GetReweightType", names, &a[0])) return nullptr;
  bool arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("GetReweightType", names[0], "bool", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::fst::ReweightType ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::fst::script::GetReweightType(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("GetArcSortType"), (PyCFunction)wrapGetArcSortType, METH_VARARGS | METH_KEYWORDS, C("GetArcSortType(str:str) -> (success:bool, sort_type:ArcSortType)\n  Calls C++ function\n  bool ::fst::script::GetArcSortType(::std::string, ::fst::script::ArcSortType*)")},
  {C("GetClosureType"), (PyCFunction)wrapGetClosureType, METH_VARARGS | METH_KEYWORDS, C("GetClosureType(closure_plus:bool) -> ClosureType\n  Calls C++ function\n  ::fst::ClosureType ::fst::script::GetClosureType(bool)")},
  {C("GetComposeFilter"), (PyCFunction)wrapGetComposeFilter, METH_VARARGS | METH_KEYWORDS, C("GetComposeFilter(str:str) -> (success:bool, compose_filter:ComposeFilter)\n  Calls C++ function\n  bool ::fst::script::GetComposeFilter(::std::string, ::fst::ComposeFilter*)")},
  {C("GetDeterminizeType"), (PyCFunction)wrapGetDeterminizeType, METH_VARARGS | METH_KEYWORDS, C("GetDeterminizeType(str:str) -> (success:bool, det_type:DeterminizeType)\n  Calls C++ function\n  bool ::fst::script::GetDeterminizeType(::std::string, ::fst::DeterminizeType*)")},
  {C("GetEncodeFlags"), (PyCFunction)wrapGetEncodeFlags, METH_VARARGS | METH_KEYWORDS, C("GetEncodeFlags(encode_labels:bool, encode_weights:bool) -> int\n  Calls C++ function\n  unsigned int ::fst::script::GetEncodeFlags(bool, bool)")},
  {C("GetEpsNormalizeType"), (PyCFunction)wrapGetEpsNormalizeType, METH_VARARGS | METH_KEYWORDS, C("GetEpsNormalizeType(eps_norm_output:bool) -> EpsNormalizeType\n  Calls C++ function\n  ::fst::EpsNormalizeType ::fst::script::GetEpsNormalizeType(bool)")},
  {C("GetMapType"), (PyCFunction)wrapGetMapType, METH_VARARGS | METH_KEYWORDS, C("GetMapType(str:str) -> (success:bool, sort_type:MapType)\n  Calls C++ function\n  bool ::fst::script::GetMapType(::std::string, ::fst::script::MapType*)")},
  {C("GetProjectType"), (PyCFunction)wrapGetProjectType, METH_VARARGS | METH_KEYWORDS, C("GetProjectType(project_output:bool) -> ProjectType\n  Calls C++ function\n  ::fst::ProjectType ::fst::script::GetProjectType(bool)")},
  {C("GetPushFlags"), (PyCFunction)wrapGetPushFlags, METH_VARARGS | METH_KEYWORDS, C("GetPushFlags(push_weights:bool, push_labels:bool, remove_total_weight:bool, remove_common_affix:bool) -> int\n  Calls C++ function\n  unsigned int ::fst::script::GetPushFlags(bool, bool, bool, bool)")},
  {C("GetQueueType"), (PyCFunction)wrapGetQueueType, METH_VARARGS | METH_KEYWORDS, C("GetQueueType(str:str) -> (success:bool, queue_type:QueueType)\n  Calls C++ function\n  bool ::fst::script::GetQueueType(::std::string, ::fst::QueueType*)")},
  {C("GetRandArcSelection"), (PyCFunction)wrapGetRandArcSelection, METH_VARARGS | METH_KEYWORDS, C("GetRandArcSelection(str:str) -> (success:bool, ras:RandArcSelection)\n  Calls C++ function\n  bool ::fst::script::GetRandArcSelection(::std::string, ::fst::script::RandArcSelection*)")},
  {C("GetReplaceLabelType"), (PyCFunction)wrapGetReplaceLabelType, METH_VARARGS | METH_KEYWORDS, C("GetReplaceLabelType(str:str, epsilon_on_replace:bool) -> (success:bool, rlt:ReplaceLabelType)\n  Calls C++ function\n  bool ::fst::script::GetReplaceLabelType(::std::string, bool, ::fst::ReplaceLabelType*)")},
  {C("GetReweightType"), (PyCFunction)wrapGetReweightType, METH_VARARGS | METH_KEYWORDS, C("GetReweightType(to_final:bool) -> ReweightType\n  Calls C++ function\n  ::fst::ReweightType ::fst::script::GetReweightType(bool)")},
  {}
};

bool Ready() {
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_getters",  // module name
  "CLIF-generated module for fst/script/getters.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  PyEval_InitThreads();
  {PyObject* em = PyImport_ImportModule("enum");
   if (em == nullptr) goto err;
   _Enum = PyObject_GetAttrString(em, "Enum");
   _IntEnum = PyObject_GetAttrString(em, "IntEnum");
   Py_DECREF(em);}
  if (!_Enum || !_IntEnum) {
    Py_XDECREF(_Enum);
    Py_XDECREF(_IntEnum);
    goto err;
  }
  if (PyModule_AddObject(module, "ClosureType", (_ClosureType=wrapClosureType())) < 0) goto err;
  if (PyModule_AddObject(module, "ComposeFilter", (_ComposeFilter=wrapComposeFilter())) < 0) goto err;
  if (PyModule_AddObject(module, "DeterminizeType", (_DeterminizeType=wrapDeterminizeType())) < 0) goto err;
  if (PyModule_AddObject(module, "EncodeType", (_EncodeType=wrapEncodeType())) < 0) goto err;
  if (PyModule_AddObject(module, "EpsNormalizeType", (_EpsNormalizeType=wrapEpsNormalizeType())) < 0) goto err;
  if (PyModule_AddObject(module, "MatchType", (_MatchType=wrapMatchType())) < 0) goto err;
  if (PyModule_AddObject(module, "ProjectType", (_ProjectType=wrapProjectType())) < 0) goto err;
  if (PyModule_AddObject(module, "QueueType", (_QueueType=wrapQueueType())) < 0) goto err;
  if (PyModule_AddObject(module, "ReplaceLabelType", (_ReplaceLabelType=wrapReplaceLabelType())) < 0) goto err;
  if (PyModule_AddObject(module, "ReweightType", (_ReweightType=wrapReweightType())) < 0) goto err;
  if (PyModule_AddObject(module, "ArcSortType", (_ArcSortType=wrapArcSortType())) < 0) goto err;
  if (PyModule_AddObject(module, "MapType", (_MapType=wrapMapType())) < 0) goto err;
  if (PyModule_AddObject(module, "RandArcSelection", (_RandArcSelection=wrapRandArcSelection())) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __getters_clifwrap

namespace fst {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// ClosureType:IntEnum to/from enum ::fst::ClosureType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ClosureType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ClosureType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ClosureType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::ClosureType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::ClosureType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::ClosureType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ClosureType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::ClosureType>::type>(c)), nullptr);
}

// ComposeFilter:IntEnum to/from enum ::fst::ComposeFilter conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ComposeFilter* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ComposeFilter)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ComposeFilter, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::ComposeFilter>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::ComposeFilter>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::ComposeFilter& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ComposeFilter, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::ComposeFilter>::type>(c)), nullptr);
}

// DeterminizeType:IntEnum to/from enum ::fst::DeterminizeType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::DeterminizeType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_DeterminizeType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum DeterminizeType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::DeterminizeType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::DeterminizeType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::DeterminizeType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_DeterminizeType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::DeterminizeType>::type>(c)), nullptr);
}

// EncodeType:IntEnum to/from enum ::fst::EncodeType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EncodeType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_EncodeType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum EncodeType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::EncodeType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::EncodeType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::EncodeType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_EncodeType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::EncodeType>::type>(c)), nullptr);
}

// EpsNormalizeType:IntEnum to/from enum ::fst::EpsNormalizeType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::EpsNormalizeType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_EpsNormalizeType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum EpsNormalizeType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::EpsNormalizeType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::EpsNormalizeType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::EpsNormalizeType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_EpsNormalizeType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::EpsNormalizeType>::type>(c)), nullptr);
}

// MatchType:IntEnum to/from enum ::fst::MatchType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::MatchType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_MatchType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum MatchType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::MatchType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::MatchType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::MatchType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_MatchType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::MatchType>::type>(c)), nullptr);
}

// ProjectType:IntEnum to/from enum ::fst::ProjectType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ProjectType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ProjectType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ProjectType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::ProjectType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::ProjectType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::ProjectType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ProjectType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::ProjectType>::type>(c)), nullptr);
}

// QueueType:IntEnum to/from enum ::fst::QueueType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::QueueType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_QueueType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum QueueType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::QueueType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::QueueType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::QueueType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_QueueType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::QueueType>::type>(c)), nullptr);
}

// ReplaceLabelType:IntEnum to/from enum ::fst::ReplaceLabelType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ReplaceLabelType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ReplaceLabelType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ReplaceLabelType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::ReplaceLabelType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::ReplaceLabelType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::ReplaceLabelType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ReplaceLabelType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::ReplaceLabelType>::type>(c)), nullptr);
}

// ReweightType:IntEnum to/from enum ::fst::ReweightType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::ReweightType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ReweightType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ReweightType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::ReweightType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::ReweightType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::ReweightType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ReweightType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::ReweightType>::type>(c)), nullptr);
}

}  // namespace fst

namespace fst { namespace script {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// ArcSortType:IntEnum to/from enum ::fst::script::ArcSortType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::script::ArcSortType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_ArcSortType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum ArcSortType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::script::ArcSortType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::script::ArcSortType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::script::ArcSortType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_ArcSortType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::script::ArcSortType>::type>(c)), nullptr);
}

// MapType:IntEnum to/from enum ::fst::script::MapType conversion

bool Clif_PyObjAs(PyObject* py, ::fst::script::MapType* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_MapType)) {
    PyErr_Format(PyExc_TypeError, "expecting enum MapType, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::script::MapType>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::script::MapType>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::script::MapType& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_MapType, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::script::MapType>::type>(c)), nullptr);
}

// RandArcSelection:IntEnum to/from enum ::fst::script::RandArcSelection conversion

bool Clif_PyObjAs(PyObject* py, ::fst::script::RandArcSelection* c) {
  assert(c != nullptr);
  if (!PyObject_IsInstance(py, __getters_clifwrap::_RandArcSelection)) {
    PyErr_Format(PyExc_TypeError, "expecting enum RandArcSelection, got %s %s", ClassName(py), ClassType(py));
    return false;
  }
  typename std::underlying_type<::fst::script::RandArcSelection>::type v;
  PyObject* value = PyObject_GetAttrString(py, "value");
  if (value == nullptr || !Clif_PyObjAs(value, &v)) return false;
  Py_DECREF(value);
  *c = static_cast<::fst::script::RandArcSelection>(v);
  return true;
}

PyObject* Clif_PyObjFrom(const ::fst::script::RandArcSelection& c, py::PostConv) {
  return PyObject_CallFunctionObjArgs(__getters_clifwrap::_RandArcSelection, PyInt_FromLong(
      static_cast<typename std::underlying_type<::fst::script::RandArcSelection>::type>(c)), nullptr);
}

} }  // namespace fst::script
