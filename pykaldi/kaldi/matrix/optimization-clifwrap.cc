//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/optimization.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/sp-matrix-clifwrap.h"
#include "optimization-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __optimization_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyLinearCgdOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::LinearCgdOptions> cpp;
};
static ::kaldi::LinearCgdOptions* ThisPtr(PyObject*);

static PyObject* get_max_iters(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_iters, {});
}

static int set_max_iters(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_iters attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_iters)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_iters:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_error(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_error, {});
}

static int set_max_error(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_error attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_error)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_error:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_recompute_residual_factor(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->recompute_residual_factor, {});
}

static int set_recompute_residual_factor(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the recompute_residual_factor attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->recompute_residual_factor)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for recompute_residual_factor:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyGetSetDef Properties[] = {
  {C("max_iters"), get_max_iters, set_max_iters, C("C++ ::int32 LinearCgdOptions.max_iters")},
  {C("max_error"), get_max_error, set_max_error, C("C++ ::kaldi::BaseFloat LinearCgdOptions.max_error")},
  {C("recompute_residual_factor"), get_recompute_residual_factor, set_recompute_residual_factor, C("C++ ::kaldi::BaseFloat LinearCgdOptions.recompute_residual_factor")},
  {}
};

// LinearCgdOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LinearCgdOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LinearCgdOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_optimization.LinearCgdOptions",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Options for Linear CGD optimization\n\nArgs:\n    max_iters(int): The maximum number of iterations\n    max_error(float): Maximum 2 norm of the residual A*x-b\n    recompute_residual_factor(float):  Every time the residual 2-norm decreases\n    by this recompute_residual_factor since the last time it was computed from\n    scratch, recompute it from. This helps to keep the computed residual \n    accurate even in the presence of roundof", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  nullptr,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "LinearCgdOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::LinearCgdOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::LinearCgdOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_LinearCgdOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::LinearCgdOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::LinearCgdOptions* c = static_cast<::kaldi::LinearCgdOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::LinearCgdOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLinearCgdOptions

// linear_cgd(opts:LinearCgdOptions, A:SpMatrix, b:VectorBase, x:VectorBase) -> int
static PyObject* wrapLinearCgd_as_linear_cgd(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("opts"),
      C("A"),
      C("b"),
      C("x"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:linear_cgd", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::LinearCgdOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("linear_cgd", names[0], "::kaldi::LinearCgdOptions", a[0]);
  ::kaldi::SpMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("linear_cgd", names[1], "::kaldi::SpMatrix<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("linear_cgd", names[2], "::kaldi::VectorBase<float>", a[2]);
  ::kaldi::VectorBase<float> * arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("linear_cgd", names[3], "::kaldi::VectorBase<float> *", a[3]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::LinearCgd(*arg1, *arg2, *arg3, arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyLbfgsOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::LbfgsOptions> cpp;
};
static ::kaldi::LbfgsOptions* ThisPtr(PyObject*);

static PyObject* get_minimize(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->minimize, {});
}

static int set_minimize(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the minimize attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->minimize)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for minimize:bool", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_m(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->m, {});
}

static int set_m(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the m attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->m)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for m:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_first_step_learning_rate(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->first_step_learning_rate, {});
}

static int set_first_step_learning_rate(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the first_step_learning_rate attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->first_step_learning_rate)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for first_step_learning_rate:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_first_step_length(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->first_step_length, {});
}

static int set_first_step_length(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the first_step_length attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->first_step_length)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for first_step_length:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_first_step_impr(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->first_step_impr, {});
}

static int set_first_step_impr(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the first_step_impr attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->first_step_impr)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for first_step_impr:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_c1(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->c1, {});
}

static int set_c1(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the c1 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->c1)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for c1:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_c2(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->c2, {});
}

static int set_c2(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the c2 attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->c2)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for c2:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_d(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->d, {});
}

static int set_d(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the d attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->d)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for d:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_line_search_iters(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_line_search_iters, {});
}

static int set_max_line_search_iters(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_line_search_iters attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_line_search_iters)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_line_search_iters:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_avg_step_length(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->avg_step_length, {});
}

static int set_avg_step_length(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the avg_step_length attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->avg_step_length)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for avg_step_length:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// __init__(minimize:bool=default)
static PyObject* wrapLbfgsOptions_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("minimize"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:__init__", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!a[0]) arg1 = (bool)true;
    else if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::LbfgsOptions>(); break;
  case 1:
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::LbfgsOptions>(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("minimize"), get_minimize, set_minimize, C("C++ bool LbfgsOptions.minimize")},
  {C("m"), get_m, set_m, C("C++ int LbfgsOptions.m")},
  {C("first_step_learning_rate"), get_first_step_learning_rate, set_first_step_learning_rate, C("C++ float LbfgsOptions.first_step_learning_rate")},
  {C("first_step_length"), get_first_step_length, set_first_step_length, C("C++ float LbfgsOptions.first_step_length")},
  {C("first_step_impr"), get_first_step_impr, set_first_step_impr, C("C++ float LbfgsOptions.first_step_impr")},
  {C("c1"), get_c1, set_c1, C("C++ float LbfgsOptions.c1")},
  {C("c2"), get_c2, set_c2, C("C++ float LbfgsOptions.c2")},
  {C("d"), get_d, set_d, C("C++ float LbfgsOptions.d")},
  {C("max_line_search_iters"), get_max_line_search_iters, set_max_line_search_iters, C("C++ int LbfgsOptions.max_line_search_iters")},
  {C("avg_step_length"), get_avg_step_length, set_avg_step_length, C("C++ int LbfgsOptions.avg_step_length")},
  {}
};

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapLbfgsOptions_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(minimize:bool=default)\n\nClass initialization\n\nArgs:\n    minimize(bool): True for minimization, falso for maximization. Default is True.")},
  {}
};

// LbfgsOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// LbfgsOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// LbfgsOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_optimization.LbfgsOptions",        // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "This class holds the options for the L-BFGS algorithm.\n   I pushes responsibility for determining when to stop, onto the user.\n   There is no callback here. The optimization happens through calls of\n   OptimizeLbfgs class itself. This does not implement constrained L-BFGS, \n   but it will handle constrained problems correctly as long as the function\n   approaches +infinity (or -infinity for maximization problems) when it gets close\n   to the bound of the constraint. In these types of problems, you just let the \n   function value be +infinity for minimization problems,\n   or -infinity for maximization problems, outside these bounds).\n\nArgs:\n    minimize(bool): if true, we're minimizing, else maximizing\n    m(int): m is the number of stored vectors L-BFGS keeps\n    first_step_learning_rate(float): The very first step of L-BFGS is like gradient descent.\n                                     If you want to configure the size of that step,\n                                     you can do it using this variable\n    first_step_length(float): If this variable is >0.0, it overrides\n                              first_step_learning_rate; on the first step we choose an approximate\n                              Hessian that is the multiple of the identity that would generate this\n                              step-length, or 1.0 if the gradient is zero\n    first_step_impr(float): If this variable is >0.0, it overrides\n                            first_step_learning_rate; on the first step we choose an approximate\n                            Hessian that is the multiple of the identity that would generate this\n                            amount of objective function improvement (assuming the real objf\n                            was linear)\n    c1(float): A constant in Armijo rule = Wolfe condition i)\n    c2(float): A constant in Wolfe condition ii)\n    d(float): An amount > 1.0 (default 2.0) that we initially multiply or\n              divide the step length by, in the line search\n    max_line_search_iters(int): after this many iters we restart L-BFGS\n    avg_step_length(int); number of iters to avg step length over", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapLbfgsOptions_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::LbfgsOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_LbfgsOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::LbfgsOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::LbfgsOptions* c = static_cast<::kaldi::LbfgsOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::LbfgsOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyLbfgsOptions

namespace pyOptimizeLbfgs {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::OptimizeLbfgs<float>> cpp;
};
static ::kaldi::OptimizeLbfgs<float>* ThisPtr(PyObject*);

// __init__(x:VectorBase, opts:LbfgsOptions)
static PyObject* wrapOptimizeLbfgs_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("x"),
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:__init__", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::LbfgsOptions* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "::kaldi::LbfgsOptions", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::OptimizeLbfgs<float>>(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// recent_step_length() -> float
static PyObject* wrapRecentStepLength_as_recent_step_length(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::OptimizeLbfgs<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->RecentStepLength();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// do_step(function_value:float, gradient:VectorBase)
static PyObject* wrapDoStep_as_do_step(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("function_value"),
      C("gradient"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:do_step", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("do_step", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("do_step", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::OptimizeLbfgs<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DoStep(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// do_step_approx_hessian(function_value:float, gradient:VectorBase, diag_approx_2nd_deriv:VectorBase)
static PyObject* wrapDoStep_as_do_step_approx_hessian(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("function_value"),
      C("gradient"),
      C("diag_approx_2nd_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:do_step_approx_hessian", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("do_step_approx_hessian", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("do_step_approx_hessian", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("do_step_approx_hessian", names[2], "::kaldi::VectorBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::OptimizeLbfgs<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DoStep(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapOptimizeLbfgs_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(x:VectorBase, opts:LbfgsOptions)\n\nClass initilization\n\nArgs:\n    x(VectorBase): A vector\n    opts(LbfgsOptions): Options for L-BFGS")},
  {C("recent_step_length"), (PyCFunction)wrapRecentStepLength_as_recent_step_length, METH_NOARGS, C("recent_step_length() -> float\n\nReturns the average magnitude of the last n steps (but not more than the number we have stored).\nBefore we have taken any steps, returns +infinity. Note: if the most recent step length was 0, \nit returns 0, regardless of the other step lengths. This makes it suitable as a\nconvergence test (else we'd generate NaN's).")},
  {C("do_step"), (PyCFunction)wrapDoStep_as_do_step, METH_VARARGS | METH_KEYWORDS, C("do_step(function_value:float, gradient:VectorBase)\n\nThe user calls this function to provide the class with the\n   function and gradient info at the point GetProposedValue().\n   If this point is outside the constraints you can set \n   function_value to {+infinity,-infinity} for {minimization,maximization}\n   problems. In this case the gradient, and also the second derivative\n   (if you call the second overloaded version of this function) will be ignored.\n\nArgs:\n    function_value(float): The current function value\n    gradient(VectorBase): This will store the gradient")},
  {C("do_step_approx_hessian"), (PyCFunction)wrapDoStep_as_do_step_approx_hessian, METH_VARARGS | METH_KEYWORDS, C("do_step_approx_hessian(function_value:float, gradient:VectorBase, diag_approx_2nd_deriv:VectorBase)\n\nThe user can call this version of DoStep() if it is desired\n   to set some kind of approximate Hessian on this iteration.\n\nArgs:\n    function_value(float): The current function value\n    gradient(VectorBase): This will store the gradient\n    diag_approx_2nd_deriv(VectorBase): A vector whose values represent \n                                       the diagonal of the Hessian\n\nRaises:\n   Error if diag_approx_2nd_deriv is not strictly positive when minimizing\n   or strictly negative when maximizing.")},
  {}
};

// OptimizeLbfgs __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// OptimizeLbfgs __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// OptimizeLbfgs __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_optimization.OptimizeLbfgs",       // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "This class handles the L-BFGS optimization", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapOptimizeLbfgs_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::OptimizeLbfgs<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_OptimizeLbfgs_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::OptimizeLbfgs<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::OptimizeLbfgs<float>* c = static_cast<::kaldi::OptimizeLbfgs<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::OptimizeLbfgs<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyOptimizeLbfgs


// Initialize module

static PyMethodDef Methods[] = {
  {C("linear_cgd"), (PyCFunction)wrapLinearCgd_as_linear_cgd, METH_VARARGS | METH_KEYWORDS, C("linear_cgd(opts:LinearCgdOptions, A:SpMatrix, b:VectorBase, x:VectorBase) -> int\n\nThis function uses linear conjugate gradient descent to approximately solve\nthe system A*x=b. The value of x at entry corresponds to the initial guess\nof x. The algorithm continues until the number of iterations equals b.size,\nor until ||A*x - b||_2<= max_error, or until the number of\niterations equals max_iter, whichever happens sooner.  It is a requirement\nthat A be positive definite. It returns the number of iterations that were\nactually executed.\n\nArgs:\n    opts(LinearCgdOptions): \n    A(Sp.Matrix): A symmetric matrix. It must be positive definite\n    b(VectorBase): A vector \n\nReturns:\n    The number of iterations")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyLinearCgdOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLinearCgdOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyLbfgsOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyLbfgsOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyOptimizeLbfgs::wrapper_Type) < 0) return false;
  Py_INCREF(&pyOptimizeLbfgs::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_optimization",  // module name
  "CLIF-generated module for matrix/optimization.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_sp_matrix")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "LinearCgdOptions", reinterpret_cast<PyObject*>(&pyLinearCgdOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "LbfgsOptions", reinterpret_cast<PyObject*>(&pyLbfgsOptions::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "OptimizeLbfgs", reinterpret_cast<PyObject*>(&pyOptimizeLbfgs::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __optimization_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// LbfgsOptions to/from ::kaldi::LbfgsOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::LbfgsOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::LbfgsOptions* cpp = __optimization_clifwrap::pyLbfgsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::LbfgsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LbfgsOptions* cpp = __optimization_clifwrap::pyLbfgsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::LbfgsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LbfgsOptions* cpp = __optimization_clifwrap::pyLbfgsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LbfgsOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::LbfgsOptions* c) {
  assert(c != nullptr);
  ::kaldi::LbfgsOptions* cpp = __optimization_clifwrap::pyLbfgsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::LbfgsOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LbfgsOptions* cpp = __optimization_clifwrap::pyLbfgsOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::LbfgsOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLbfgsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LbfgsOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::LbfgsOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLbfgsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LbfgsOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::LbfgsOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLbfgsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LbfgsOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::LbfgsOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLbfgsOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLbfgsOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::LbfgsOptions>(c);
  return py;
}

// LinearCgdOptions to/from ::kaldi::LinearCgdOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::LinearCgdOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::LinearCgdOptions* cpp = __optimization_clifwrap::pyLinearCgdOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::LinearCgdOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LinearCgdOptions* cpp = __optimization_clifwrap::pyLinearCgdOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::LinearCgdOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LinearCgdOptions* cpp = __optimization_clifwrap::pyLinearCgdOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert LinearCgdOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::LinearCgdOptions* c) {
  assert(c != nullptr);
  ::kaldi::LinearCgdOptions* cpp = __optimization_clifwrap::pyLinearCgdOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::LinearCgdOptions>* c) {
  assert(c != nullptr);
  ::kaldi::LinearCgdOptions* cpp = __optimization_clifwrap::pyLinearCgdOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::LinearCgdOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLinearCgdOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LinearCgdOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::LinearCgdOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLinearCgdOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LinearCgdOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::LinearCgdOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLinearCgdOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::LinearCgdOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::LinearCgdOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyLinearCgdOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyLinearCgdOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::LinearCgdOptions>(c);
  return py;
}

// OptimizeLbfgs to/from ::kaldi::OptimizeLbfgs<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::OptimizeLbfgs<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::OptimizeLbfgs<float>* cpp = __optimization_clifwrap::pyOptimizeLbfgs::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::OptimizeLbfgs<float>>* c) {
  assert(c != nullptr);
  ::kaldi::OptimizeLbfgs<float>* cpp = __optimization_clifwrap::pyOptimizeLbfgs::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__optimization_clifwrap::pyOptimizeLbfgs::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::OptimizeLbfgs<float>>* c) {
  assert(c != nullptr);
  ::kaldi::OptimizeLbfgs<float>* cpp = __optimization_clifwrap::pyOptimizeLbfgs::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__optimization_clifwrap::pyOptimizeLbfgs::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert OptimizeLbfgs instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::OptimizeLbfgs<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyOptimizeLbfgs::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyOptimizeLbfgs::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OptimizeLbfgs<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::OptimizeLbfgs<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyOptimizeLbfgs::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyOptimizeLbfgs::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OptimizeLbfgs<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::OptimizeLbfgs<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__optimization_clifwrap::pyOptimizeLbfgs::wrapper_Type, NULL, NULL);
  reinterpret_cast<__optimization_clifwrap::pyOptimizeLbfgs::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::OptimizeLbfgs<float>>(std::move(c));
  return py;
}

}  // namespace kaldi
