//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/matrix/kaldi-vector.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/matrix-common-clifwrap.h"
#include "kaldi-vector-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __kaldi__vector_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyVectorBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::VectorBase<float>> cpp;
};
static ::kaldi::VectorBase<float>* ThisPtr(PyObject*);

// set_zero_()
static PyObject* wrapSetZero_as_set_zero_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_(f:float)
static PyObject* wrapSet_as_set_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("f"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_randn_()
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_rand_uniform_()
static PyObject* wrapSetRandUniform_as_set_rand_uniform_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// rand_categorical() -> int
static PyObject* wrapRandCategorical_as_rand_categorical(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->RandCategorical();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __len__() -> int
static PyObject* wrapDim_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Dim(), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _getitem(index:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_getitem", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _setitem_(index:int, value:float)
static PyObject* wrapSet_as__setitem_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("index"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_setitem_", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_setitem_", names[0], "int", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_setitem_", names[1], "float", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_vec_(v:VectorBase)
static PyObject* wrapCopyFromVec_as__copy_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_copy_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_vec_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_()
static PyObject* wrapApplyLog_as_apply_log_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_and_copy_(v:VectorBase)
static PyObject* wrapApplyLogAndCopy_as_apply_log_and_copy_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_log_and_copy_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_log_and_copy_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLogAndCopy(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_exp_()
static PyObject* wrapApplyExp_as_apply_exp_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_abs_()
static PyObject* wrapApplyAbs_as_apply_abs_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyAbs();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_(floor:float) -> int
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "float", a[0]);
  int ret0{};
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_floor_no_count_(floor:float)
static PyObject* wrapApplyFloor_as_apply_floor_no_count_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_no_count_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_no_count_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_ceiling_(ceiling:float) -> int
static PyObject* wrapApplyCeiling_as_apply_ceiling_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling_", names[0], "float", a[0]);
  int ret0{};
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_ceiling_no_count_(ceiling:float)
static PyObject* wrapApplyCeiling_as_apply_ceiling_no_count_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling_no_count_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling_no_count_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_floor_vector_(floor:VectorBase) -> int
static PyObject* wrapApplyFloor_as_apply_floor_vector_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_vector_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_vector_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyFloor(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_softmax_() -> float
static PyObject* wrapApplySoftMax_as_apply_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplySoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_log_softmax_() -> float
static PyObject* wrapApplyLogSoftMax_as_apply_log_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyLogSoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// tanh_(src:VectorBase)
static PyObject* wrapTanh_as_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sigmoid_(src:VectorBase)
static PyObject* wrapSigmoid_as_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_(power:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_abs_(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs_", names[0], "float", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs_", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// norm(p:float) -> float
static PyObject* wrapNorm_as_norm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("p"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:norm", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("norm", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Norm(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal(other:VectorBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal", names[0], "::kaldi::VectorBase<float>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// invert_elements_()
static PyObject* wrapInvertElements_as_invert_elements_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_vec_(alpha:float, v:VectorBase)
static PyObject* wrapAddVec_as__add_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_add_vec_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_vec2_(alpha:float, v:VectorBase)
static PyObject* wrapAddVec2_as__add_vec2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_add_vec2_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_vec2_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_vec2_", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// replace_value_(orig:float, changed:float)
static PyObject* wrapReplaceValue_as_replace_value_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("orig"),
      C("changed"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:replace_value_", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("replace_value_", names[0], "float", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("replace_value_", names[1], "float", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ReplaceValue(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _mul_elements_(v:VectorBase)
static PyObject* wrapMulElements_as__mul_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_mul_elements_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_elements_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _div_elements_(v:VectorBase)
static PyObject* wrapDivElements_as__div_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_div_elements_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_div_elements_", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_(value:float)
static PyObject* wrapAdd_as_add_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, v:VectorBase, r:VectorBase, beta:float)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("r"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_vec_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_vec_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_div_vec_(alpha:float, v:VectorBase, r:VectorBase, beta:float)
static PyObject* wrapAddVecDivVec_as_add_vec_div_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("r"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_div_vec_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_div_vec_", names[0], "float", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_div_vec_", names[1], "::kaldi::VectorBase<float>", a[1]);
  ::kaldi::VectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_div_vec_", names[2], "::kaldi::VectorBase<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_div_vec_", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecDivVec(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max_index() -> (value:float, index:int)
static PyObject* wrapMax_as_max_index(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min_index() -> (value:float, index:int)
static PyObject* wrapMin_as_min_index(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum_log() -> float
static PyObject* wrapSumLog_as_sum_log(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SumLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_sum_exp(prune:float=default) -> float
static PyObject* wrapLogSumExp_as_log_sum_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("prune"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:log_sum_exp", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_sum_exp", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LogSumExp(); break;
  case 1:
    ret0 = c->LogSumExp(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("dim"), get_dim, nullptr, C("Dimension (zero for empty vector).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("set_zero_"), (PyCFunction)wrapSetZero_as_set_zero_, METH_NOARGS, C("set_zero_()\n\nSets the elements to zero.")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if the elements are all zeros.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-06``.\n\nReturns:\n  True if `max(abs(self)) <= cutoff`.")},
  {C("set_"), (PyCFunction)wrapSet_as_set_, METH_VARARGS | METH_KEYWORDS, C("set_(f:float)\n\nSets the elements to the given value.\n\nArgs:\n  f (float): The value to set.")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_NOARGS, C("set_randn_()\n\nSets the elements to numbers from standard normal distribution.")},
  {C("set_rand_uniform_"), (PyCFunction)wrapSetRandUniform_as_set_rand_uniform_, METH_NOARGS, C("set_rand_uniform_()\n\nSets the elements to numbers uniformly distributed on (0,1).")},
  {C("rand_categorical"), (PyCFunction)wrapRandCategorical_as_rand_categorical, METH_NOARGS, C("rand_categorical() -> int\n\nChooses a random index into the vector.\n\nChooses an index with probability proportional to its element value.\nRequires `min(self) >= 0` and `sum(self) > 0`.\n\nReturns:\n  A random index value.\n\nRaises:\n  RuntimeError: If `min(self) < 0 || sum(self) <= 0`.")},
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n\nReturns the size (in bytes) of the data held by the vector.")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(index:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  index (int): The element index.\n\nReturns:\n  The element at the given index.")},
  {C("_setitem_"), (PyCFunction)wrapSet_as__setitem_, METH_VARARGS | METH_KEYWORDS, C("_setitem_(index:int, value:float)\n\nSets the element at the given index.\n\nArgs:\n  index (int): The element index.\n  value (float): The value to set.")},
  {C("_copy_from_vec_"), (PyCFunction)wrapCopyFromVec_as__copy_from_vec_, METH_VARARGS | METH_KEYWORDS, C("_copy_from_vec_(v:VectorBase)\n\nCopies the elements from another vector.\n\nArgs:\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("apply_log_"), (PyCFunction)wrapApplyLog_as_apply_log_, METH_NOARGS, C("apply_log_()\n\nApplies the natural log operation to each element.")},
  {C("apply_log_and_copy_"), (PyCFunction)wrapApplyLogAndCopy_as_apply_log_and_copy_, METH_VARARGS | METH_KEYWORDS, C("apply_log_and_copy_(v:VectorBase)\n\nApplies the natural log operation to the given vector and copies it.\n\nArgs:\n  v (Vector): The input vector.")},
  {C("apply_exp_"), (PyCFunction)wrapApplyExp_as_apply_exp_, METH_NOARGS, C("apply_exp_()\n\nApplies the exponential operation to each element.")},
  {C("apply_abs_"), (PyCFunction)wrapApplyAbs_as_apply_abs_, METH_NOARGS, C("apply_abs_()\n\nApplies the absolute value operation to each element.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float) -> int\n\nApplies the floor operation to each element.\n\nPerforms the operation `y[i] = max(y[i], floor)`.\n\nArgs:\n  floor (float): The floor value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_floor_no_count_"), (PyCFunction)wrapApplyFloor_as_apply_floor_no_count_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_no_count_(floor:float)\n\nApplies the floor operation to each element.\n\nPerforms the operation `y[i] = max(y[i], floor)`.\n\nArgs:\n  floor (float): The floor value.")},
  {C("apply_ceiling_"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling_, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling_(ceiling:float) -> int\n\nApplies the ceiling operation to each element.\n\nPerforms the operation `y[i] = min(y[i], ceiling)`.\n\nArgs:\n  ceiling (float): The ceiling value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_ceiling_no_count_"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling_no_count_, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling_no_count_(ceiling:float)\n\nApplies the ceiling operation to each element.\n\nPerforms the operation `y[i] = min(y[i], ceiling)`.\n\nArgs:\n  ceiling (float): The ceiling value.")},
  {C("apply_floor_vector_"), (PyCFunction)wrapApplyFloor_as_apply_floor_vector_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_vector_(floor:VectorBase) -> int\n\nApplies a separate floor operation to each element.\n\nPerforms the operation `y[i] = max(y[i], floor[i])`.\n\nArgs:\n  floor (Vector): The floor vector.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_softmax_"), (PyCFunction)wrapApplySoftMax_as_apply_softmax_, METH_NOARGS, C("apply_softmax_() -> float\n\nApplies the softmax operation to each element.\n\nPerforms the operation\n:math:`y_i = \\frac{\\exp(y_i)}{\\sum_j \\exp(y_j)}`.\n\nReturns:\n  :math:`\\log(\\sum_j \\exp(y_j))`.")},
  {C("apply_log_softmax_"), (PyCFunction)wrapApplyLogSoftMax_as_apply_log_softmax_, METH_NOARGS, C("apply_log_softmax_() -> float\n\nApplies the logsoftmax operation to each element.\n\nPerforms the operation\n:math:`y_i = y_i - \\log(\\sum_j \\exp(y_j))`.\n\nReturns:\n  :math:`\\log(\\sum_j \\exp(y_j))`.")},
  {C("tanh_"), (PyCFunction)wrapTanh_as_tanh_, METH_VARARGS | METH_KEYWORDS, C("tanh_(src:VectorBase)\n\nSets the elements to the tanh of the elements in another vector.\n\nArgs:\n  src(Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sigmoid_"), (PyCFunction)wrapSigmoid_as_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("sigmoid_(src:VectorBase)\n\nSets the elements to the sigmoid of the elements in another vector.\n\nArgs:\n  src(Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(power:float)\n\nTakes each element to the given power.\n\nArgs:\n  power (float): The exponent value.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_pow_abs_"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs_(power:float, include_sign:bool=default)\n\nTakes the absolute value of each element raised to the given power.\n\nIf the power is negative and the input is zero, the output is zero.\n\nArgs:\n  power (float): The power value.\n  include_sign (bool): Whether to include the sign of the input value.\n    Defaults to ``False``.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("norm"), (PyCFunction)wrapNorm_as_norm, METH_VARARGS | METH_KEYWORDS, C("norm(p:float) -> float\n\nComputes the p-norm of the vector.\n\nArgs:\n  p (float): The p value. It must be non-negative.\n\nReturns:\n  The p-norm.\n\nRaises:\n  RuntimeError: If `p < 0` or p-norm cannot be computed.")},
  {C("_approx_equal"), (PyCFunction)wrapApproxEqual_as__approx_equal, METH_VARARGS | METH_KEYWORDS, C("_approx_equal(other:VectorBase, tol:float=default) -> bool\n\nChecks if vectors are approximately equal.\n\nArgs:\n  other (Vector): The vector to check against.\n  tol (float): The tolerance. Defaults to ``0.01``.\n\nReturns:\n  True if `||self-other|| <= tol * ||self||`. False otherwise.\n\nRaises:\n  RuntimeError: In case of size mismatch or if `tol < 0`.")},
  {C("invert_elements_"), (PyCFunction)wrapInvertElements_as_invert_elements_, METH_NOARGS, C("invert_elements_()\n\nInverts the elements.\n\nRaises:\n  RuntimeError: If any of the elements is zero.")},
  {C("_add_vec_"), (PyCFunction)wrapAddVec_as__add_vec_, METH_VARARGS | METH_KEYWORDS, C("_add_vec_(alpha:float, v:VectorBase)\n\nAdds another vector.\n\nPerforms the operation :math:`y = y + \\alpha\\ v`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_vec2_"), (PyCFunction)wrapAddVec2_as__add_vec2_, METH_VARARGS | METH_KEYWORDS, C("_add_vec2_(alpha:float, v:VectorBase)\n\nAdds the squares of elements from another vector.\n\nPerforms the operation :math:`y = y + \\alpha\\ v\\odot v`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (Vector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("replace_value_"), (PyCFunction)wrapReplaceValue_as_replace_value_, METH_VARARGS | METH_KEYWORDS, C("replace_value_(orig:float, changed:float)\n\nReplaces the elements.\n\nPerforms the operation `y[y == orig] = changed`.\n\nArgs:\n  orig (float): The original value to replace.\n  changed (float): The value to replace with.")},
  {C("_mul_elements_"), (PyCFunction)wrapMulElements_as__mul_elements_, METH_VARARGS | METH_KEYWORDS, C("_mul_elements_(v:VectorBase)\n\nMultiplies element-wise with another vector.\n\nPerforms the operation `y = y \\odot v`.\n\nArgs:\n  v (Vector): The multiplier.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_div_elements_"), (PyCFunction)wrapDivElements_as__div_elements_, METH_VARARGS | METH_KEYWORDS, C("_div_elements_(v:VectorBase)\n\nDivides element-wise with another vector.\n\nPerforms the operation `y = y \\oslash v`.\n\nArgs:\n  v (Vector): The denominator.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_"), (PyCFunction)wrapAdd_as_add_, METH_VARARGS | METH_KEYWORDS, C("add_(value:float)\n\nAdds the given value to each element.\n\nArgs:\n  value (float): The value to add.")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, v:VectorBase, r:VectorBase, beta:float)\n\nComputes an element-wise vector-vector product.\n\nPerforms the operation :math:`y = \\alpha\\ v\\odot r + \\beta\\ y`.\n\nArgs:\n  alpha (float): The scalar multiplier for the product.\n  v (Vector): The first input vector.\n  r (Vector): The second input vector.\n  beta (float): The scalar multiplier for the destination vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_vec_div_vec_"), (PyCFunction)wrapAddVecDivVec_as_add_vec_div_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_div_vec_(alpha:float, v:VectorBase, r:VectorBase, beta:float)\n\nComputes an element-wise vector-vector division.\n\nPerforms the operation :math:`y = \\alpha\\ v\\oslash r + \\beta\\ y`.\n\nArgs:\n  alpha (float): The scalar multiplier for the division.\n  v (Vector): The first input vector.\n  r (Vector): The second input vector.\n  beta (float): The scalar multiplier for the destination vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScales the vector.\n\nArgs:\n  alpha (float): The scalar multiplier.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n\nReturns the maximum value in the vector.")},
  {C("max_index"), (PyCFunction)wrapMax_as_max_index, METH_NOARGS, C("max_index() -> (value:float, index:int)\n\nReturns the maximum value in the vector, and the associated index.")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n\nReturns the minimum value in the vector.")},
  {C("min_index"), (PyCFunction)wrapMin_as_min_index, METH_NOARGS, C("min_index() -> (value:float, index:int)\n\nReturns the minimum value in the vector, and the associated index.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elements.")},
  {C("sum_log"), (PyCFunction)wrapSumLog_as_sum_log, METH_NOARGS, C("sum_log() -> float\n\nReturns the sum of the logs of the elements.\n\nReturns NaN if any of the elements is negative.")},
  {C("log_sum_exp"), (PyCFunction)wrapLogSumExp_as_log_sum_exp, METH_VARARGS | METH_KEYWORDS, C("log_sum_exp(prune:float=default) -> float\n\nComputes :math:`f(x)=\\log(\\sum_i \\exp(x_i))` without exp overflow.\n\nIf `prune > 0.0`, ignores terms less than `max(x) - prune`.\n\nArgs:\n  prune (float): The pruning beam. Defaults to `-1.0`.\n\nReturns:\n  :math:`\\log(\\sum_i \\exp(x_i))`.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the vector from the given C++ stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read vector.\n    Defaults to ``False``.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the vector to given C++ stream.\n\nArgs:\n    os (ostream): The output C++ straem.\n    binary (bool): Whether the stream is binary.")},
  {}
};

// VectorBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// VectorBase __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_vector.VectorBase",          // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Base class for single precision vectors.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::VectorBase<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_VectorBase_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::VectorBase<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::VectorBase<float>* c = static_cast<::kaldi::VectorBase<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::VectorBase<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyVectorBase

namespace pyVector {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Vector<float>> cpp;
};
static ::kaldi::Vector<float>* ThisPtr(PyObject*);

// @classmethod from_size(size:int, resize_type:MatrixResizeType=default) -> Vector
static PyObject* wrapVector_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("size"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_size", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Vector<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<float>>(std::move(arg1)); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<float>>(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_vector(v:VectorBase) -> Vector
static PyObject* wrapVector_as_from_vector(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_vector", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_vector", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Vector<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<float>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:Vector)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::Vector<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::Vector<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::Vector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::Vector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// resize_(length:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("length"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:resize_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::Vector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->Resize(std::move(arg1)); break;
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _remove_element_(index:int)
static PyObject* wrapRemoveElement_as__remove_element_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_element_", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_element_", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::Vector<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->RemoveElement(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::VectorBase<float>*
static PyObject* as_kaldi_VectorBase_float(PyObject* self) {
  ::kaldi::VectorBase<float>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::VectorBase<float>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapVector_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(size:int, resize_type:MatrixResizeType=default) -> Vector\n\nCreates a new vector of given size.\n\nArgs:\n  size (int): The size of the new vector.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or\n    ``MatrixResizeType.COPY_DATA``, they are set to zero.\n    If ``MatrixResizeType.UNDEFINED``, they are left uninitialized.\n    Defaults to ``MatrixResizeType.SET_ZERO``.")},
  {C("from_vector"), (PyCFunction)wrapVector_as_from_vector, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_vector(v:VectorBase) -> Vector\n\nCreates a new vector from a given vector.\n\nArgs:\n  v (Vector): The input vector.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:Vector)\n\nSwaps the contents of vectors.\n\nShallow swap.\n\nArgs:\n  other (Vector): The vector to swap contents with.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the vector from the given C++ stream.\n\nResizes the vector to match the size of the matrix read from stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read vector.\n    Defaults to ``False``.")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(length:int, resize_type:MatrixResizeType=default)\n\nResizes the vector.\n\nArgs:\n  length(int): The new length.\n  resize_type (MatrixResizeType): How to initialize the elements.\n      If ``MatrixResizeType.SET_ZERO`` they are set to zero.\n      If ``MatrixResizeType.COPY_DATA``, existing elements are\n      retained, new ones are set to zero.\n      If ``MatrixResizeType.UNDEFINED``, they are left uninitialized.\n      Defaults to ``MatrixResizeType.SET_ZERO``.")},
  {C("_remove_element_"), (PyCFunction)wrapRemoveElement_as__remove_element_, METH_VARARGS | METH_KEYWORDS, C("_remove_element_(index:int)\n\nRemoves the element at the given index.\n\nShifts later elements down, reducing the vector size by one.\n\nArgs:\n  index(int): The element index.")},
  {C("as_kaldi_VectorBase_float"), (PyCFunction)as_kaldi_VectorBase_float, METH_NOARGS, C("Upcast to ::kaldi::VectorBase<float>*")},
  {}
};

// Vector __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// Vector __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// Vector __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_vector.Vector",              // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Single precision vector.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "Vector takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Vector<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Vector<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Vector_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Vector<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::Vector<float>* c = static_cast<::kaldi::Vector<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Vector<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyVector

// _approx_equal_vector(a:VectorBase, b:VectorBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("a"),
      C("b"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_approx_equal_vector", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal_vector", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal_vector", names[1], "::kaldi::VectorBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_approx_equal_vector", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _assert_equal_vector(a:VectorBase, b:VectorBase, tol:float=default)
static PyObject* wrapAssertEqual_as__assert_equal_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("a"),
      C("b"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_assert_equal_vector", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assert_equal_vector", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assert_equal_vector", names[1], "::kaldi::VectorBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_assert_equal_vector", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _vec_vec(v1:VectorBase, v2:VectorBase) -> float
static PyObject* wrapVecVec_as__vec_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v1"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_vec_vec", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_vec", names[0], "::kaldi::VectorBase<float>", a[0]);
  ::kaldi::VectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_vec", names[1], "::kaldi::VectorBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecVec(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyDoubleVectorBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::VectorBase<double>> cpp;
};
static ::kaldi::VectorBase<double>* ThisPtr(PyObject*);

// set_zero_()
static PyObject* wrapSetZero_as_set_zero_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// is_zero(cutoff:float=default) -> bool
static PyObject* wrapIsZero_as_is_zero(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("cutoff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_zero", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_zero", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsZero(); break;
  case 1:
    ret0 = c->IsZero(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_(f:float)
static PyObject* wrapSet_as_set_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("f"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_randn_()
static PyObject* wrapSetRandn_as_set_randn_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// set_randn_uniform_()
static PyObject* wrapSetRandUniform_as_set_randn_uniform_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// rand_categorical() -> int
static PyObject* wrapRandCategorical_as_rand_categorical(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->RandCategorical();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __len__() -> int
static PyObject* wrapDim_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

static PyObject* get_dim(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->Dim(), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _getitem(index:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_getitem", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _setitem_(index:int, value:float)
static PyObject* wrapSet_as__setitem_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("index"),
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_setitem_", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_setitem_", names[0], "int", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_setitem_", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _copy_from_vec_(v:DoubleVectorBase)
static PyObject* wrapCopyFromVec_as__copy_from_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_copy_from_vec_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_copy_from_vec_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_()
static PyObject* wrapApplyLog_as_apply_log_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_log_and_copy_(v:DoubleVectorBase)
static PyObject* wrapApplyLogAndCopy_as_apply_log_and_copy_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_log_and_copy_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_log_and_copy_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLogAndCopy(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_exp_()
static PyObject* wrapApplyExp_as_apply_exp_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_abs_()
static PyObject* wrapApplyAbs_as_apply_abs_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyAbs();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_floor_(floor:float) -> int
static PyObject* wrapApplyFloor_as_apply_floor_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_", names[0], "double", a[0]);
  int ret0{};
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_ceiling_(ceiling:float) -> int
static PyObject* wrapApplyCeiling_as_apply_ceiling_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling_", names[0], "double", a[0]);
  int ret0{};
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_floor_vector_(floor:DoubleVectorBase) -> int
static PyObject* wrapApplyFloor_as_apply_floor_vector_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor_vector_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor_vector_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyFloor(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_softmax_() -> float
static PyObject* wrapApplySoftMax_as_apply_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplySoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// apply_log_softmax_() -> float
static PyObject* wrapApplyLogSoftMax_as_apply_log_softmax_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->ApplyLogSoftMax();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// tanh_(src:DoubleVectorBase)
static PyObject* wrapTanh_as_tanh_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// sigmoid_(src:DoubleVectorBase)
static PyObject* wrapSigmoid_as_sigmoid_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_(power:float)
static PyObject* wrapApplyPow_as_apply_pow_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// apply_pow_abs_(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs_", names[0], "double", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs_", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// norm(p:float) -> float
static PyObject* wrapNorm_as_norm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("p"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:norm", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("norm", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Norm(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _approx_equal(other:DoubleVectorBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:_approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal", names[0], "::kaldi::VectorBase<double>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// invert_elements_()
static PyObject* wrapInvertElements_as_invert_elements_(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_vec_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVec_as__add_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_add_vec_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _add_vec2_(alpha:float, v:DoubleVectorBase)
static PyObject* wrapAddVec2_as__add_vec2_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_add_vec2_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_add_vec2_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_add_vec2_", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVec2(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// replace_value_(orig:float, changed:float)
static PyObject* wrapReplaceValue_as_replace_value_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("orig"),
      C("changed"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:replace_value_", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("replace_value_", names[0], "double", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("replace_value_", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ReplaceValue(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _mul_elements_(v:DoubleVectorBase)
static PyObject* wrapMulElements_as__mul_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_mul_elements_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_mul_elements_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _div_elements_(v:DoubleVectorBase)
static PyObject* wrapDivElements_as__div_elements_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_div_elements_", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_div_elements_", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_(value:float)
static PyObject* wrapAdd_as_add_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_vec_(alpha:float, v:DoubleVectorBase, r:DoubleVectorBase, beta:float)
static PyObject* wrapAddVecVec_as_add_vec_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("r"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_vec_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec_", names[2], "::kaldi::VectorBase<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_vec_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// add_vec_div_vec_(alpha:float, v:DoubleVectorBase, r:DoubleVectorBase, beta:float)
static PyObject* wrapAddVecDivVec_as_add_vec_div_vec_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("v"),
      C("r"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_vec_div_vec_", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_div_vec_", names[0], "double", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_div_vec_", names[1], "::kaldi::VectorBase<double>", a[1]);
  ::kaldi::VectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_div_vec_", names[2], "::kaldi::VectorBase<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_vec_div_vec_", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecDivVec(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// scale_(alpha:float)
static PyObject* wrapScale_as_scale_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("alpha"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale_", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale_", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max_index() -> (value:float, index:int)
static PyObject* wrapMax_as_max_index(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min_index() -> (value:float, index:int)
static PyObject* wrapMin_as_min_index(PyObject* self) {
  int ret1{};
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min(&ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum_log() -> float
static PyObject* wrapSumLog_as_sum_log(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SumLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// log_sum_exp(prune:float=default) -> float
static PyObject* wrapLogSumExp_as_log_sum_exp(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("prune"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:log_sum_exp", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("log_sum_exp", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->LogSumExp(); break;
  case 1:
    ret0 = c->LogSumExp(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::VectorBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("dim"), get_dim, nullptr, C("Dimension (zero for empty vector).")},
  {}
};

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapDim_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("set_zero_"), (PyCFunction)wrapSetZero_as_set_zero_, METH_NOARGS, C("set_zero_()\n\nSets the elements to zero.")},
  {C("is_zero"), (PyCFunction)wrapIsZero_as_is_zero, METH_VARARGS | METH_KEYWORDS, C("is_zero(cutoff:float=default) -> bool\n\nChecks if the elements are all zeros.\n\nArgs:\n  cutoff (float): The cutoff value. Defaults to ``1.0e-06``.\n\nReturns:\n  True if `max(abs(self)) <= cutoff`.")},
  {C("set_"), (PyCFunction)wrapSet_as_set_, METH_VARARGS | METH_KEYWORDS, C("set_(f:float)\n\nSets the elements to the given value.\n\nArgs:\n  f (float): The value to set.")},
  {C("set_randn_"), (PyCFunction)wrapSetRandn_as_set_randn_, METH_NOARGS, C("set_randn_()\n\nSets the elements to numbers from standard normal distribution.")},
  {C("set_randn_uniform_"), (PyCFunction)wrapSetRandUniform_as_set_randn_uniform_, METH_NOARGS, C("set_randn_uniform_()\n\nSets the elements to numbers uniformly distributed on (0,1).")},
  {C("rand_categorical"), (PyCFunction)wrapRandCategorical_as_rand_categorical, METH_NOARGS, C("rand_categorical() -> int\n\nChooses a random index into the vector.\n\nChooses an index with probability proportional to its element value.\nRequires `min(self) >= 0` and `sum(self) > 0`.\n\nReturns:\n  A random index value.\n\nRaises:\n  RuntimeError: If `min(self) < 0 || sum(self) <= 0`.")},
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n\nReturns the size (in bytes) of the data held by the vector.")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(index:int) -> float\n\nGets the element at the given index.\n\nArgs:\n  index (int): The element index.\n\nReturns:\n  The element at the given index.")},
  {C("_setitem_"), (PyCFunction)wrapSet_as__setitem_, METH_VARARGS | METH_KEYWORDS, C("_setitem_(index:int, value:float)\n\nSets the element at the given index.\n\nArgs:\n  index (int): The element index.\n  value (float): The value to set.")},
  {C("_copy_from_vec_"), (PyCFunction)wrapCopyFromVec_as__copy_from_vec_, METH_VARARGS | METH_KEYWORDS, C("_copy_from_vec_(v:DoubleVectorBase)\n\nCopies the elements from another vector.\n\nArgs:\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("apply_log_"), (PyCFunction)wrapApplyLog_as_apply_log_, METH_NOARGS, C("apply_log_()\n\nApplies the natural log operation to each element.")},
  {C("apply_log_and_copy_"), (PyCFunction)wrapApplyLogAndCopy_as_apply_log_and_copy_, METH_VARARGS | METH_KEYWORDS, C("apply_log_and_copy_(v:DoubleVectorBase)\n\nApplies the natural log operation to the given vector and copies it.\n\nArgs:\n  v (DoubleVector): The input vector.")},
  {C("apply_exp_"), (PyCFunction)wrapApplyExp_as_apply_exp_, METH_NOARGS, C("apply_exp_()\n\nApplies the exponential operation to each element.")},
  {C("apply_abs_"), (PyCFunction)wrapApplyAbs_as_apply_abs_, METH_NOARGS, C("apply_abs_()\n\nApplies the absolute value operation to each element.")},
  {C("apply_floor_"), (PyCFunction)wrapApplyFloor_as_apply_floor_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_(floor:float) -> int\n\nApplies the floor operation to each element.\n\nPerforms the operation `y[i] = max(y[i], floor)`.\n\nArgs:\n  floor (float): The floor value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_ceiling_"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling_, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling_(ceiling:float) -> int\n\nApplies the ceiling operation to each element.\n\nPerforms the operation `y[i] = min(y[i], ceiling)`.\n\nArgs:\n  ceiling (float): The ceiling value.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_floor_vector_"), (PyCFunction)wrapApplyFloor_as_apply_floor_vector_, METH_VARARGS | METH_KEYWORDS, C("apply_floor_vector_(floor:DoubleVectorBase) -> int\n\nApplies a separate floor operation to each element.\n\nPerforms the operation `y[i] = max(y[i], floor[i])`.\n\nArgs:\n  floor (DoubleVector): The floor vector.\n\nReturns:\n  The number of elements changed.")},
  {C("apply_softmax_"), (PyCFunction)wrapApplySoftMax_as_apply_softmax_, METH_NOARGS, C("apply_softmax_() -> float\n\nApplies the softmax operation to each element.\n\nPerforms the operation\n:math:`y_i = \\frac{\\exp(y_i)}{\\sum_j \\exp(y_j)}`.\n\nReturns:\n  :math:`\\log(\\sum_j \\exp(y_j))`.")},
  {C("apply_log_softmax_"), (PyCFunction)wrapApplyLogSoftMax_as_apply_log_softmax_, METH_NOARGS, C("apply_log_softmax_() -> float\n\nApplies the logsoftmax operation to each element.\n\nPerforms the operation\n:math:`y_i = y_i - \\log(\\sum_j \\exp(y_j))`.\n\nReturns:\n  :math:`\\log(\\sum_j \\exp(y_j))`.")},
  {C("tanh_"), (PyCFunction)wrapTanh_as_tanh_, METH_VARARGS | METH_KEYWORDS, C("tanh_(src:DoubleVectorBase)\n\nSets the elements to the tanh of the elements in another vector.\n\nArgs:\n  src(DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("sigmoid_"), (PyCFunction)wrapSigmoid_as_sigmoid_, METH_VARARGS | METH_KEYWORDS, C("sigmoid_(src:DoubleVectorBase)\n\nSets the elements to the sigmoid of the elements in another vector.\n\nArgs:\n  src(DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("apply_pow_"), (PyCFunction)wrapApplyPow_as_apply_pow_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_(power:float)\n\nTakes each element to the given power.\n\nArgs:\n  power (float): The exponent value.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("apply_pow_abs_"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs_, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs_(power:float, include_sign:bool=default)\n\nTakes the absolute value of each element raised to the given power.\n\nIf the power is negative and the input is zero, the output is zero.\n\nArgs:\n  power (float): The power value.\n  include_sign (bool): Whether to include the sign of the input value.\n    Defaults to ``False``.\n\nRaises:\n  RuntimeError: If an element cannot be raised to the given power.")},
  {C("norm"), (PyCFunction)wrapNorm_as_norm, METH_VARARGS | METH_KEYWORDS, C("norm(p:float) -> float\n\nComputes the p-norm of the vector.\n\nArgs:\n  p (float): The p value. It must be non-negative.\n\nReturns:\n  The p-norm.\n\nRaises:\n  RuntimeError: If `p < 0` or p-norm cannot be computed.")},
  {C("_approx_equal"), (PyCFunction)wrapApproxEqual_as__approx_equal, METH_VARARGS | METH_KEYWORDS, C("_approx_equal(other:DoubleVectorBase, tol:float=default) -> bool\n\nChecks if vectors are approximately equal.\n\nArgs:\n  other (DoubleVector): The vector to check against.\n  tol (float): The tolerance. Defaults to ``0.01``.\n\nReturns:\n  True if `||self-other|| <= tol * ||self||`. False otherwise.\n\nRaises:\n  RuntimeError: In case of size mismatch or if `tol < 0`.")},
  {C("invert_elements_"), (PyCFunction)wrapInvertElements_as_invert_elements_, METH_NOARGS, C("invert_elements_()\n\nInverts the elements.\n\nRaises:\n  RuntimeError: If any of the elements is zero.")},
  {C("_add_vec_"), (PyCFunction)wrapAddVec_as__add_vec_, METH_VARARGS | METH_KEYWORDS, C("_add_vec_(alpha:float, v:DoubleVectorBase)\n\nAdds another vector.\n\nPerforms the operation :math:`y = y + \\alpha\\ v`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_add_vec2_"), (PyCFunction)wrapAddVec2_as__add_vec2_, METH_VARARGS | METH_KEYWORDS, C("_add_vec2_(alpha:float, v:DoubleVectorBase)\n\nAdds the squares of elements from another vector.\n\nPerforms the operation :math:`y = y + \\alpha\\ v\\odot v`.\n\nArgs:\n  alpha (float): The scalar multiplier.\n  v (DoubleVector): The input vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("replace_value_"), (PyCFunction)wrapReplaceValue_as_replace_value_, METH_VARARGS | METH_KEYWORDS, C("replace_value_(orig:float, changed:float)\n\nReplaces the elements.\n\nPerforms the operation `y[y == orig] = changed`.\n\nArgs:\n  orig (float): The original value to replace.\n  changed (float): The value to replace with.")},
  {C("_mul_elements_"), (PyCFunction)wrapMulElements_as__mul_elements_, METH_VARARGS | METH_KEYWORDS, C("_mul_elements_(v:DoubleVectorBase)\n\nMultiplies element-wise with another vector.\n\nPerforms the operation `y = y \\odot v`.\n\nArgs:\n  v (DoubleVector): The multiplier.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_div_elements_"), (PyCFunction)wrapDivElements_as__div_elements_, METH_VARARGS | METH_KEYWORDS, C("_div_elements_(v:DoubleVectorBase)\n\nDivides element-wise with another vector.\n\nPerforms the operation `y = y \\oslash v`.\n\nArgs:\n  v (DoubleVector): The denominator.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_"), (PyCFunction)wrapAdd_as_add_, METH_VARARGS | METH_KEYWORDS, C("add_(value:float)\n\nAdds the given value to each element.\n\nArgs:\n  value (float): The value to add.")},
  {C("add_vec_vec_"), (PyCFunction)wrapAddVecVec_as_add_vec_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec_(alpha:float, v:DoubleVectorBase, r:DoubleVectorBase, beta:float)\n\nComputes an element-wise vector-vector product.\n\nPerforms the operation :math:`y = \\alpha\\ v\\odot r + \\beta\\ y`.\n\nArgs:\n  alpha (float): The scalar multiplier for the product.\n  v (DoubleVector): The first input vector.\n  r (DoubleVector): The second input vector.\n  beta (float): The scalar multiplier for the destination vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("add_vec_div_vec_"), (PyCFunction)wrapAddVecDivVec_as_add_vec_div_vec_, METH_VARARGS | METH_KEYWORDS, C("add_vec_div_vec_(alpha:float, v:DoubleVectorBase, r:DoubleVectorBase, beta:float)\n\nComputes an element-wise vector-vector division.\n\nPerforms the operation :math:`y = \\alpha\\ v\\oslash r + \\beta\\ y`.\n\nArgs:\n  alpha (float): The scalar multiplier for the division.\n  v (DoubleVector): The first input vector.\n  r (DoubleVector): The second input vector.\n  beta (float): The scalar multiplier for the destination vector.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("scale_"), (PyCFunction)wrapScale_as_scale_, METH_VARARGS | METH_KEYWORDS, C("scale_(alpha:float)\n\nScales the vector.\n\nArgs:\n  alpha (float): The scalar multiplier.")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n\nReturns the maximum value in the vector.")},
  {C("max_index"), (PyCFunction)wrapMax_as_max_index, METH_NOARGS, C("max_index() -> (value:float, index:int)\n\nReturns the maximum value in the vector, and the associated index.")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n\nReturns the minimum value in the vector.")},
  {C("min_index"), (PyCFunction)wrapMin_as_min_index, METH_NOARGS, C("min_index() -> (value:float, index:int)\n\nReturns the minimum value in the vector, and the associated index.")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n\nReturns the sum of the elements.")},
  {C("sum_log"), (PyCFunction)wrapSumLog_as_sum_log, METH_NOARGS, C("sum_log() -> float\n\nReturns the sum of the logs of the elements.\n\nReturns NaN if any of the elements is negative.")},
  {C("log_sum_exp"), (PyCFunction)wrapLogSumExp_as_log_sum_exp, METH_VARARGS | METH_KEYWORDS, C("log_sum_exp(prune:float=default) -> float\n\nComputes :math:`f(x)=\\log(\\sum_i \\exp(x_i))` without exp overflow.\n\nIf `prune > 0.0`, ignores terms less than `max(x) - prune`.\n\nArgs:\n  prune (float): The pruning beam. Defaults to `-1.0`.\n\nReturns:\n  :math:`\\log(\\sum_i \\exp(x_i))`.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the vector from the given C++ stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read vector.\n    Defaults to ``False``.")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n\nWrites the vector to given C++ stream.\n\nArgs:\n    os (ostream): The output C++ straem.\n    binary (bool): Whether the stream is binary.")},
  {}
};

// DoubleVectorBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleVectorBase __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_vector.DoubleVectorBase",    // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Base class for double precision vectors.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::VectorBase<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_VectorBase_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::VectorBase<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::VectorBase<double>* c = static_cast<::kaldi::VectorBase<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::VectorBase<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleVectorBase

namespace pyDoubleVector {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::Vector<double>> cpp;
};
static ::kaldi::Vector<double>* ThisPtr(PyObject*);

// @classmethod from_size(size:int, resize_type:MatrixResizeType=default) -> DoubleVector
static PyObject* wrapVector_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("size"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_size", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Vector<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<double>>(std::move(arg1)); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<double>>(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_vector(v:DoubleVectorBase) -> DoubleVector
static PyObject* wrapVector_as_from_vector(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_vector", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_vector", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::Vector<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::Vector<double>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// swap_(other:DoubleVector)
static PyObject* wrapSwap_as_swap_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_", names, &a[0])) return nullptr;
  ::kaldi::Vector<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_", names[0], "::kaldi::Vector<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::Vector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// read_(is:istream, binary:bool, add:bool=default)
static PyObject* wrapRead_as_read_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("is"),
      C("binary"),
      C("add"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:read_", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read_", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read_", names[1], "bool", a[1]);
  bool arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("read_", names[2], "bool", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::Vector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Read(*arg1, std::move(arg2)); break;
  case 3:
    c->Read(*arg1, std::move(arg2), std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// resize_(length:int, resize_type:MatrixResizeType=default)
static PyObject* wrapResize_as_resize_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("length"),
      C("resize_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:resize_", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize_", names[0], "int", a[0]);
  ::kaldi::MatrixResizeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize_", names[1], "::kaldi::MatrixResizeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::Vector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->Resize(std::move(arg1)); break;
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_INCREF(self);
  return self;
}

// _remove_element_(index:int)
static PyObject* wrapRemoveElement_as__remove_element_(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("index"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:_remove_element_", names, &a[0])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_remove_element_", names[0], "int", a[0]);
  // Call actual C++ method.
  ::kaldi::Vector<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->RemoveElement(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// Implicit cast this as ::kaldi::VectorBase<double>*
static PyObject* as_kaldi_VectorBase_double(PyObject* self) {
  ::kaldi::VectorBase<double>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::VectorBase<double>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapVector_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(size:int, resize_type:MatrixResizeType=default) -> DoubleVector\n\nCreates a new vector of given size.\n\nArgs:\n  size (int): The size of the new vector.\n  resize_type (MatrixResizeType): How to initialize the elements.\n    If ``MatrixResizeType.SET_ZERO`` or\n    ``MatrixResizeType.COPY_DATA``, they are set to zero.\n    If ``MatrixResizeType.UNDEFINED``, they are left uninitialized.\n    Defaults to ``MatrixResizeType.SET_ZERO``.")},
  {C("from_vector"), (PyCFunction)wrapVector_as_from_vector, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_vector(v:DoubleVectorBase) -> DoubleVector\n\nCreates a new vector from a given vector.\n\nArgs:\n  v (DoubleVector): The input vector.")},
  {C("swap_"), (PyCFunction)wrapSwap_as_swap_, METH_VARARGS | METH_KEYWORDS, C("swap_(other:DoubleVector)\n\nSwaps the contents of vectors.\n\nShallow swap.\n\nArgs:\n  other (DoubleVector): The vector to swap contents with.")},
  {C("read_"), (PyCFunction)wrapRead_as_read_, METH_VARARGS | METH_KEYWORDS, C("read_(is:istream, binary:bool, add:bool=default)\n\nReads the vector from the given C++ stream.\n\nResizes the vector to match the size of the matrix read from stream.\n\nArgs:\n  is (istream): The input C++ stream.\n  binary (bool): Whether the stream is binary.\n  add (bool): Whether to add existing contents to the read vector.\n    Defaults to ``False``.")},
  {C("resize_"), (PyCFunction)wrapResize_as_resize_, METH_VARARGS | METH_KEYWORDS, C("resize_(length:int, resize_type:MatrixResizeType=default)\n\nResizes the vector.\n\nArgs:\n  length(int): The new length.\n  resize_type (MatrixResizeType): How to initialize the elements.\n      If ``MatrixResizeType.SET_ZERO`` they are set to zero.\n      If ``MatrixResizeType.COPY_DATA``, existing elements are\n      retained, new ones are set to zero.\n      If ``MatrixResizeType.UNDEFINED``, they are left uninitialized.\n      Defaults to ``MatrixResizeType.SET_ZERO``.")},
  {C("_remove_element_"), (PyCFunction)wrapRemoveElement_as__remove_element_, METH_VARARGS | METH_KEYWORDS, C("_remove_element_(index:int)\n\nRemoves the element at the given index.\n\nShifts later elements down, reducing the vector size by one.\n\nArgs:\n  index(int): The element index.")},
  {C("as_kaldi_VectorBase_double"), (PyCFunction)as_kaldi_VectorBase_double, METH_NOARGS, C("Upcast to ::kaldi::VectorBase<double>*")},
  {}
};

// DoubleVector __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// DoubleVector __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// DoubleVector __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_kaldi_vector.DoubleVector",        // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Double precision vector.",          // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "DoubleVector takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::Vector<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::Vector<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_Vector_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::Vector<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::Vector<double>* c = static_cast<::kaldi::Vector<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::Vector<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyDoubleVector

// _approx_equal_double_vector(a:DoubleVectorBase, b:DoubleVectorBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as__approx_equal_double_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("a"),
      C("b"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_approx_equal_double_vector", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_approx_equal_double_vector", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_approx_equal_double_vector", names[1], "::kaldi::VectorBase<double>", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_approx_equal_double_vector", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// _assert_equal_double_vector(a:DoubleVectorBase, b:DoubleVectorBase, tol:float=default)
static PyObject* wrapAssertEqual_as__assert_equal_double_vector(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("a"),
      C("b"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:_assert_equal_double_vector", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_assert_equal_double_vector", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_assert_equal_double_vector", names[1], "::kaldi::VectorBase<double>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("_assert_equal_double_vector", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _vec_vec_double(v1:DoubleVectorBase, v2:DoubleVectorBase) -> float
static PyObject* wrapVecVec_as__vec_vec_double(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v1"),
      C("v2"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_vec_vec_double", names, &a[0], &a[1])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_vec_vec_double", names[0], "::kaldi::VectorBase<double>", a[0]);
  ::kaldi::VectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_vec_vec_double", names[1], "::kaldi::VectorBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::VecVec(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("_approx_equal_vector"), (PyCFunction)wrapApproxEqual_as__approx_equal_vector, METH_VARARGS | METH_KEYWORDS, C("_approx_equal_vector(a:VectorBase, b:VectorBase, tol:float=default) -> bool\n\nChecks if given vectors are approximately equal.\n\nArgs:\n  a (Vector): The first vector.\n  b (Vector): The second vector.\n  tol (float): The tolerance for the equality check. Defaults to ``0.01``.\n\nReturns:\n  True if\n  :math:`\\Vert a-b \\Vert \\leq \\mathrm{tol} \\times \\Vert a \\Vert`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_assert_equal_vector"), (PyCFunction)wrapAssertEqual_as__assert_equal_vector, METH_VARARGS | METH_KEYWORDS, C("_assert_equal_vector(a:VectorBase, b:VectorBase, tol:float=default)\n\nAsserts given vectors are approximately equal.\n\nArgs:\n  a (Vector): The first vector.\n  b (Vector): The second vector.\n  tol (float): The tolerance for the equality check. Defaults to ``0.01``.\n\nRaises:\n  RuntimeError: In case of size mismatch of if\n  :math:`\\Vert a-b \\Vert > \\mathrm{tol} \\times \\Vert a \\Vert`.")},
  {C("_vec_vec"), (PyCFunction)wrapVecVec_as__vec_vec, METH_VARARGS | METH_KEYWORDS, C("_vec_vec(v1:VectorBase, v2:VectorBase) -> float\n\nReturns the dot product of vectors.\n\nArgs:\n  v1 (Vector): The first vector.\n  v2 (Vector): The second vector.\n\nReturns:\n  The dot product of v1 and v2.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_approx_equal_double_vector"), (PyCFunction)wrapApproxEqual_as__approx_equal_double_vector, METH_VARARGS | METH_KEYWORDS, C("_approx_equal_double_vector(a:DoubleVectorBase, b:DoubleVectorBase, tol:float=default) -> bool\n\nChecks if given vectors are approximately equal.\n\nArgs:\n  a (DoubleVector): The first vector.\n  b (DoubleVector): The second vector.\n  tol (float): The tolerance for the equality check. Defaults to ``0.01``.\n\nReturns:\n  True if\n  :math:`\\Vert a-b \\Vert \\leq \\mathrm{tol} \\times \\Vert a \\Vert`.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {C("_assert_equal_double_vector"), (PyCFunction)wrapAssertEqual_as__assert_equal_double_vector, METH_VARARGS | METH_KEYWORDS, C("_assert_equal_double_vector(a:DoubleVectorBase, b:DoubleVectorBase, tol:float=default)\n\nAsserts given vectors are approximately equal.\n\nArgs:\n  a (DoubleVector): The first vector.\n  b (DoubleVector): The second vector.\n  tol (float): The tolerance for the equality check. Defaults to ``0.01``.\n\nRaises:\n  RuntimeError: In case of size mismatch of if\n  :math:`\\Vert a-b \\Vert > \\mathrm{tol} \\times \\Vert a \\Vert`.")},
  {C("_vec_vec_double"), (PyCFunction)wrapVecVec_as__vec_vec_double, METH_VARARGS | METH_KEYWORDS, C("_vec_vec_double(v1:DoubleVectorBase, v2:DoubleVectorBase) -> float\n\nReturns the dot product of vectors.\n\nArgs:\n  v1 (DoubleVector): The first vector.\n  v2 (DoubleVector): The second vector.\n\nReturns:\n  The dot product of v1 and v2.\n\nRaises:\n  RuntimeError: In case of size mismatch.")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyVectorBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyVectorBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyVector::wrapper_Type.tp_base = &pyVectorBase::wrapper_Type;
  if (PyType_Ready(&pyVector::wrapper_Type) < 0) return false;
  Py_INCREF(&pyVector::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyDoubleVectorBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleVectorBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyDoubleVector::wrapper_Type.tp_base = &pyDoubleVectorBase::wrapper_Type;
  if (PyType_Ready(&pyDoubleVector::wrapper_Type) < 0) return false;
  Py_INCREF(&pyDoubleVector::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_kaldi_vector",  // module name
  "CLIF-generated module for matrix/kaldi-vector.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "VectorBase", reinterpret_cast<PyObject*>(&pyVectorBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "Vector", reinterpret_cast<PyObject*>(&pyVector::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleVectorBase", reinterpret_cast<PyObject*>(&pyDoubleVectorBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "DoubleVector", reinterpret_cast<PyObject*>(&pyDoubleVector::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __kaldi__vector_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// DoubleVector to/from ::kaldi::Vector<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Vector<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Vector<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Vector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Vector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert DoubleVector instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Vector<double>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Vector<double>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Vector<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Vector<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Vector<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Vector<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVector::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Vector<double>>(c);
  return py;
}

// DoubleVectorBase to/from ::kaldi::VectorBase<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::VectorBase<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::VectorBase<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVectorBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::VectorBase<double>>* c) {
  assert(c != nullptr);
  ::kaldi::VectorBase<double>* cpp = __kaldi__vector_clifwrap::pyDoubleVectorBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVectorBase::wrapper*>(py)->cpp, cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::VectorBase<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVectorBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVectorBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::VectorBase<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::VectorBase<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyDoubleVectorBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyDoubleVectorBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::VectorBase<double>>(c);
  return py;
}

// Vector to/from ::kaldi::Vector<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::Vector<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::Vector<float>* cpp = __kaldi__vector_clifwrap::pyVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::Vector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<float>* cpp = __kaldi__vector_clifwrap::pyVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::Vector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<float>* cpp = __kaldi__vector_clifwrap::pyVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert Vector instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::Vector<float>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<float>* cpp = __kaldi__vector_clifwrap::pyVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::Vector<float>>* c) {
  assert(c != nullptr);
  ::kaldi::Vector<float>* cpp = __kaldi__vector_clifwrap::pyVector::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::Vector<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Vector<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Vector<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::Vector<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::Vector<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVector::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVector::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::Vector<float>>(c);
  return py;
}

// VectorBase to/from ::kaldi::VectorBase<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::VectorBase<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::VectorBase<float>* cpp = __kaldi__vector_clifwrap::pyVectorBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::VectorBase<float>>* c) {
  assert(c != nullptr);
  ::kaldi::VectorBase<float>* cpp = __kaldi__vector_clifwrap::pyVectorBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__kaldi__vector_clifwrap::pyVectorBase::wrapper*>(py)->cpp, cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::VectorBase<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVectorBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVectorBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::VectorBase<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::VectorBase<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__kaldi__vector_clifwrap::pyVectorBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__kaldi__vector_clifwrap::pyVectorBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::VectorBase<float>>(c);
  return py;
}

}  // namespace kaldi
