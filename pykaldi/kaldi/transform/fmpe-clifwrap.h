//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/transform/fmpe.clif

#include <memory>
#include "clif/python/optional.h"
#include "transform/fmpe.h"
#include "clif/python/postconv.h"

namespace kaldi {
using namespace ::clif;

// CLIF use `::kaldi::Fmpe` as Fmpe
bool Clif_PyObjAs(PyObject* input, ::kaldi::Fmpe** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::kaldi::Fmpe>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::kaldi::Fmpe>* output);
PyObject* Clif_PyObjFrom(::kaldi::Fmpe*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::Fmpe>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::Fmpe>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::kaldi::Fmpe*, py::PostConv) = delete;
PyObject* Clif_PyObjFrom(const ::kaldi::Fmpe&, py::PostConv) = delete;
// CLIF use `::kaldi::FmpeOptions` as FmpeOptions
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeOptions** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::kaldi::FmpeOptions>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::kaldi::FmpeOptions>* output);
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeOptions* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::kaldi::FmpeOptions>* output);
PyObject* Clif_PyObjFrom(::kaldi::FmpeOptions*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::FmpeOptions>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::FmpeOptions>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::kaldi::FmpeOptions&, py::PostConv);
// CLIF use `::kaldi::FmpeStats` as FmpeStats
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeStats** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::kaldi::FmpeStats>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::kaldi::FmpeStats>* output);
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeStats* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::kaldi::FmpeStats>* output);
PyObject* Clif_PyObjFrom(::kaldi::FmpeStats*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::FmpeStats>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::FmpeStats>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::kaldi::FmpeStats&, py::PostConv);
// CLIF use `::kaldi::FmpeUpdateOptions` as FmpeUpdateOptions
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeUpdateOptions** output);
bool Clif_PyObjAs(PyObject* input, std::shared_ptr<::kaldi::FmpeUpdateOptions>* output);
bool Clif_PyObjAs(PyObject* input, std::unique_ptr<::kaldi::FmpeUpdateOptions>* output);
bool Clif_PyObjAs(PyObject* input, ::kaldi::FmpeUpdateOptions* output);
bool Clif_PyObjAs(PyObject* input, ::gtl::optional<::kaldi::FmpeUpdateOptions>* output);
PyObject* Clif_PyObjFrom(::kaldi::FmpeUpdateOptions*, py::PostConv);
PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::FmpeUpdateOptions>, py::PostConv);
PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::FmpeUpdateOptions>, py::PostConv);
PyObject* Clif_PyObjFrom(const ::kaldi::FmpeUpdateOptions&, py::PostConv);

}  // namespace kaldi

// CLIF init_module if (PyObject* m = PyImport_ImportModule("_fmpe")) Py_DECREF(m);
// CLIF init_module else goto err;
