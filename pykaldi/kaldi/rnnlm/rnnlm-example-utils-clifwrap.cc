//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/rnnlm/rnnlm-example-utils.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "itf/options-itf-clifwrap.h"
#include "cudamatrix/cu-matrixdim-clifwrap.h"
#include "cudamatrix/cu-array-clifwrap.h"
#include "cudamatrix/cu-matrix-clifwrap.h"
#include "nnet3/nnet-computation-clifwrap.h"
#include "rnnlm/rnnlm-example-clifwrap.h"
#include "rnnlm-example-utils-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __rnnlm__example__utils_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


// renumber_rnnlm_example(minibatch:RnnlmExample) -> list<int>
static PyObject* wrapRenumberRnnlmExample_as_renumber_rnnlm_example(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("minibatch"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:renumber_rnnlm_example", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::RnnlmExample * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("renumber_rnnlm_example", names[0], "::kaldi::rnnlm::RnnlmExample *", a[0]);
  ::std::vector< ::int32> ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::rnnlm::RenumberRnnlmExample(arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// get_rnnlm_computation_request(minibatch:RnnlmExample, need_model_derivative:bool, need_input_derivative:bool, store_component_stats:bool) -> ComputationRequest
static PyObject* wrapGetRnnlmComputationRequest_as_get_rnnlm_computation_request(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("minibatch"),
      C("need_model_derivative"),
      C("need_input_derivative"),
      C("store_component_stats"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:get_rnnlm_computation_request", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::rnnlm::RnnlmExample* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_rnnlm_computation_request", names[0], "::kaldi::rnnlm::RnnlmExample", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_rnnlm_computation_request", names[1], "bool", a[1]);
  bool arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("get_rnnlm_computation_request", names[2], "bool", a[2]);
  bool arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("get_rnnlm_computation_request", names[3], "bool", a[3]);
  ::kaldi::nnet3::ComputationRequest ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::rnnlm::GetRnnlmComputationRequest(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyRnnlmExampleDerived {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::RnnlmExampleDerived> cpp;
};
static ::kaldi::rnnlm::RnnlmExampleDerived* ThisPtr(PyObject*);

static PyObject* get_cu_input_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->cu_input_words), {});
}

static int set_cu_input_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cu_input_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cu_input_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cu_input_words:CuArray", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cu_output_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->cu_output_words), {});
}

static int set_cu_output_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cu_output_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cu_output_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cu_output_words:CuArray", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_cu_sampled_words(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(::clif::MakeStdShared(reinterpret_cast<wrapper*>(self)->cpp, &cpp->cu_sampled_words), {});
}

static int set_cu_sampled_words(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the cu_sampled_words attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->cu_sampled_words)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for cu_sampled_words:CuArray", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// swap(other:RnnlmExampleDerived)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::rnnlm::RnnlmExampleDerived * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::rnnlm::RnnlmExampleDerived *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmExampleDerived* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("cu_input_words"), get_cu_input_words, set_cu_input_words, C("CUDA copy of minibatch.input_words.")},
  {C("cu_output_words"), get_cu_output_words, set_cu_output_words, C("CUDA copy of minibatch.output_words.\n\nIt's only used in the sampling case.")},
  {C("cu_sampled_words"), get_cu_sampled_words, set_cu_sampled_words, C("CUDA copy of minibatch.sampled_words.\n\nIt's only used in the sampling case (in the no-sampling case,\nminibatch.sampled_words would be empty anyway).")},
  {}
};

static PyMethodDef Methods[] = {
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(other:RnnlmExampleDerived)\n\nSwaps contents with another derived RNNLM example.\n\nArgs:\n  other (RnnlmExampleDerived): The other derived RNNLM example.")},
  {}
};

// RnnlmExampleDerived __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmExampleDerived __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmExampleDerived __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_rnnlm_example_utils.RnnlmExampleDerived", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Various quantities/expressions derived from an RNNLM example.\n\nThis class contains various quantities/expressions that are derived from\nthe quantities found in `RnnlmExample`, and which are needed when\ntraining on that example, particularly by the function\n:meth:`process_rnnlm_output`.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RnnlmExampleDerived takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmExampleDerived>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::RnnlmExampleDerived* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_RnnlmExampleDerived"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::RnnlmExampleDerived"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::RnnlmExampleDerived* c = static_cast<::kaldi::rnnlm::RnnlmExampleDerived*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::RnnlmExampleDerived*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmExampleDerived

// get_rnnlm_example_derived(minibatch:RnnlmExample, need_embedding_deriv:bool) -> RnnlmExampleDerived
static PyObject* wrapGetRnnlmExampleDerived_as_get_rnnlm_example_derived(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("minibatch"),
      C("need_embedding_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:get_rnnlm_example_derived", names, &a[0], &a[1])) return nullptr;
  ::kaldi::rnnlm::RnnlmExample* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("get_rnnlm_example_derived", names[0], "::kaldi::rnnlm::RnnlmExample", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("get_rnnlm_example_derived", names[1], "bool", a[1]);
  ::kaldi::rnnlm::RnnlmExampleDerived ret0{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::rnnlm::GetRnnlmExampleDerived(*arg1, std::move(arg2), &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyRnnlmObjectiveOptions {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::rnnlm::RnnlmObjectiveOptions> cpp;
};
static ::kaldi::rnnlm::RnnlmObjectiveOptions* ThisPtr(PyObject*);

static PyObject* get_den_term_limit(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->den_term_limit, {});
}

static int set_den_term_limit(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the den_term_limit attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->den_term_limit)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for den_term_limit:float", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

static PyObject* get_max_logprob_elements(PyObject* self, void* xdata) {
  auto cpp = ThisPtr(self); if (!cpp) return nullptr;
  return Clif_PyObjFrom(cpp->max_logprob_elements, {});
}

static int set_max_logprob_elements(PyObject* self, PyObject* value, void* xdata) {
  if (value == nullptr) {
    PyErr_SetString(PyExc_TypeError, "Cannot delete the max_logprob_elements attribute");
    return -1;
  }
  auto cpp = ThisPtr(self); if (!cpp) return -1;
  if (Clif_PyObjAs(value, &cpp->max_logprob_elements)) return 0;
  PyObject* s = PyObject_Repr(value);
  PyErr_Format(PyExc_ValueError, "%s is not valid for max_logprob_elements:int", s? PyUnicode_AsUTF8(s): "input");
  Py_XDECREF(s);
  return -1;
}

// register(opts:OptionsItf)
static PyObject* wrapRegister_as_register(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("opts"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:register", names, &a[0])) return nullptr;
  ::kaldi::OptionsItf * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("register", names[0], "::kaldi::OptionsItf *", a[0]);
  // Call actual C++ method.
  ::kaldi::rnnlm::RnnlmObjectiveOptions* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Register(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

static PyGetSetDef Properties[] = {
  {C("den_term_limit"), get_den_term_limit, set_den_term_limit, C("Modification to the with-sampling objective.\n\nThis prevents instability early in training, but in the end makes no\ndifference. We scale down the denominator part of the objective when\nthe average denominator part of the objective, for this minibatch, is\nmore negative than this value.  Set this to 0.0 to use unmodified\nobjective function")},
  {C("max_logprob_elements"), get_max_logprob_elements, set_max_logprob_elements, C("Maximum number of elements in the logprob matrix.\n\nMaximum number of elements when we allocate a matrix of size\n[minibatch-size, num-words] for computing logprobs of words. If the\nsize is exceeded, we will break the matrix along the minibatch axis\nand compute them separately.")},
  {}
};

static PyMethodDef Methods[] = {
  {C("register"), (PyCFunction)wrapRegister_as_register, METH_VARARGS | METH_KEYWORDS, C("register(opts:OptionsItf)\n\nRegisters options with an object implementing the options interface.\n\nArgs:\n  opts (OptionsItf): An object implementing the options interface.\n    Typically a command-line option parser.")},
  {}
};

// RnnlmObjectiveOptions __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// RnnlmObjectiveOptions __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// RnnlmObjectiveOptions __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_rnnlm_example_utils.RnnlmObjectiveOptions", // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "Options for RNNLM objective function.\n\nConfiguration class relating to the objective function used for RNNLM\ntraining, more specifically for use by the function\n:meth:`process_rnnlm_output`.", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  Properties,                          // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "RnnlmObjectiveOptions takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmObjectiveOptions>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::rnnlm::RnnlmObjectiveOptions* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_rnnlm_RnnlmObjectiveOptions"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::rnnlm::RnnlmObjectiveOptions"));
      if (!PyErr_Occurred()) {
        ::kaldi::rnnlm::RnnlmObjectiveOptions* c = static_cast<::kaldi::rnnlm::RnnlmObjectiveOptions*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::rnnlm::RnnlmObjectiveOptions*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyRnnlmObjectiveOptions

// process_rnnlm_output(objective_opts:RnnlmObjectiveOptions, minibatch:RnnlmExample, derived:RnnlmExampleDerived, word_embedding:CuMatrixBase, nnet_output:CuMatrixBase, word_embedding_deriv:CuMatrixBase, nnet_output_deriv:CuMatrixBase) -> (weight:float, objf_num:float, objf_den:float, objf_den_exact:float)
static PyObject* wrapProcessRnnlmOutput_as_process_rnnlm_output(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[7];
  char* names[] = {
      C("objective_opts"),
      C("minibatch"),
      C("derived"),
      C("word_embedding"),
      C("nnet_output"),
      C("word_embedding_deriv"),
      C("nnet_output_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOOO:process_rnnlm_output", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5], &a[6])) return nullptr;
  ::kaldi::rnnlm::RnnlmObjectiveOptions* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("process_rnnlm_output", names[0], "::kaldi::rnnlm::RnnlmObjectiveOptions", a[0]);
  ::kaldi::rnnlm::RnnlmExample* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("process_rnnlm_output", names[1], "::kaldi::rnnlm::RnnlmExample", a[1]);
  ::kaldi::rnnlm::RnnlmExampleDerived* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("process_rnnlm_output", names[2], "::kaldi::rnnlm::RnnlmExampleDerived", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("process_rnnlm_output", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::CuMatrixBase<float>* arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("process_rnnlm_output", names[4], "::kaldi::CuMatrixBase<float>", a[4]);
  ::kaldi::CuMatrixBase<float> * arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("process_rnnlm_output", names[5], "::kaldi::CuMatrixBase<float> *", a[5]);
  ::kaldi::CuMatrixBase<float> * arg7;
  if (!Clif_PyObjAs(a[6], &arg7)) return ArgError("process_rnnlm_output", names[6], "::kaldi::CuMatrixBase<float> *", a[6]);
  float ret0{};
  float ret1{};
  float ret2{};
  float ret3{};
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ::kaldi::rnnlm::ProcessRnnlmOutput(*arg1, *arg2, *arg3, *arg4, *arg5, arg6, arg7, &ret0, &ret1, &ret2, &ret3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(4);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  if ((p=Clif_PyObjFrom(std::move(ret2), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 2, p);
  if ((p=Clif_PyObjFrom(std::move(ret3), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 3, p);
  return result_tuple;
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("renumber_rnnlm_example"), (PyCFunction)wrapRenumberRnnlmExample_as_renumber_rnnlm_example, METH_VARARGS | METH_KEYWORDS, C("renumber_rnnlm_example(minibatch:RnnlmExample) -> list<int>\n\nRenumbers word-ids in a minibatch.\n\nThis function renumbers the word-ids referred to in a minibatch, creating\na numbering that covers exactly the words referred to in this minibatch.\nIt is only to be called when sampling is used, i.e. when\n`minibatch.samples` is not empty.\n\nArgs:\n  minibatch (RnnlmExample): The minibatch to be modified. At entry the\n    words-indexes in fields `input_words`, and `sampled_words` will be in\n    their canonical numbering. At exit the numbers present in those\n    arrays will be indexes into the `active_words` vector that this\n    function outputs. For instance, suppose `minibatch.input_words[9] ==\n    1034` at entry; at exit we might have `minibatch.input_words[9] ==\n    94`, with `active_words[94] == 1034`. This function requires that\n    `minibatch.sampled_words` is nonempty. If `minibatch.sampled_words`\n    is empty, it means that sampling has not been done, so the negative\n    part of the objf will use all the words. In this case the minibatch\n    implicitly uses all words, so there is no use in renumbering. At\n    exit, `minibatch.vocab_size` will have been set to the same value as\n    `len(active_words)`.\n\nReturns:\n  The list of active words, i.e. the words that were present in the\n  fields `input_words`, and `sampled_words` in `minibatch` on entry. At\n  exit, this list will be sorted and unique.\n\nNote:\n    It is not necessary for this function to renumber `output_words`\n    because in the sampling case they are indexes into blocks of\n    `sampled_words` (see documentation for `RnnlmExample`).")},
  {C("get_rnnlm_computation_request"), (PyCFunction)wrapGetRnnlmComputationRequest_as_get_rnnlm_computation_request, METH_VARARGS | METH_KEYWORDS, C("get_rnnlm_computation_request(minibatch:RnnlmExample, need_model_derivative:bool, need_input_derivative:bool, store_component_stats:bool) -> ComputationRequest\n\nCreates a computation request for the given RNNLM example.\n\nThis function takes an RnnlmExample (which should already have been\nframe-selected, if desired, and merged into a minibatch) and produces a\nComputationRequest. It assumes you don't want the derivatives w.r.t. the\ninputs; if you do, you can create/modify the ComputationRequest manually.\nAssumes that if `need_model_derivative` is true, you will be supplying\nderivatives w.r.t. all outputs.")},
  {C("get_rnnlm_example_derived"), (PyCFunction)wrapGetRnnlmExampleDerived_as_get_rnnlm_example_derived, METH_VARARGS | METH_KEYWORDS, C("get_rnnlm_example_derived(minibatch:RnnlmExample, need_embedding_deriv:bool) -> RnnlmExampleDerived\n\nConstructs a derived RNNLM example.\n\nSets up the structure containing derived parameters used in training\nand objective function computation.\n\nArgs:\n  minibatch (RnnlmExample): The input minibatch for which we are\n    computing the derived parameters.\n  need_embedding_deriv (bool): True if we are going to be computing\n    derivatives w.r.t. the word embedding (e.g., needed in a typical\n    training configuration); if this is True, it will compute\n    `input_words_tranpose`.\n\nReturns:\n  A derived RNNLM example structure for the input minibatch.")},
  {C("process_rnnlm_output"), (PyCFunction)wrapProcessRnnlmOutput_as_process_rnnlm_output, METH_VARARGS | METH_KEYWORDS, C("process_rnnlm_output(objective_opts:RnnlmObjectiveOptions, minibatch:RnnlmExample, derived:RnnlmExampleDerived, word_embedding:CuMatrixBase, nnet_output:CuMatrixBase, word_embedding_deriv:CuMatrixBase, nnet_output_deriv:CuMatrixBase) -> (weight:float, objf_num:float, objf_den:float, objf_den_exact:float)\n\nProcesses the output of RNNLM computation.\n\nThis function processes the output of the RNNLM computation for a single\nminibatch; it outputs the objective-function contributions from the\nnumerator and denominator terms, and [if requested] the derivatives\nof the objective function w.r.t. the data inputs.\n\nIn the explanation below, the index `i` encompasses both the time `t`\nand the member `n` within the minibatch.\nThe objective function referred to here is of the form\n  `objf = \\sum_i weight(i) * ( num_term(i) + den_term(i) )`\nwhere num_term(i) is the log-prob of the 'correct' word, which equals\nthe dot product of the neural-network output with the word embedding,\nwhich we can write as follows\n  `num_term(i) = l(i, minibatch.output_words(i))`\nwhere `l(i, w)` is the unnormalized log-prob of word `w` for position\n`i`, specifically\n  `l(i, w) = vec_vec(nnet_output.Row(i), word_embedding.Row(w))`.\nWithout importance sampling (if `len(minibatch.sampled_words) == 0`),\nwe get\n  `den_term(i) = 1.0 - (\\sum_w q(i,w))`\nThis is a lower bound on the 'natural' normalizer term which is of the\nform `-log(\\sum_w p(i,w))`, and its linearity in the p's allows\nimportance sampling). Here,\n  `p(i, w) = exp(l(i, w))`\n\n  `q(i, w) = exp(l(i, w)) if l(i, w < 0) else  1 + l(i, w)`\n[the reason we use `q(i, w)` instead of `p(i, w)` is that it gives a\ncloser bound to the natural normalizer term and helps avoid\ninstability in early phases of training.]\n\nWith importance sampling (if minibatch.sampled_words.size() > 0),\n`den_term` equals\n  `den_term(i) =  1.0 - (\\sum_w q(w,i) * sample_inv_prob(w,i))`\nwhere `sample_inv_prob(w, i)` is zero if word w was not sampled\nfor this `t`, and 1.0 / (the probability with which it was sampled)\nif it was sampled.\n\nArgs:\n  objective_opts (RnnlmObjectiveOptions): Options for RNNLM objective.\n  minibatch (RnnlmExample): The minibatch for which we are processing\n    the output.\n  derived (RnnlmExampleDerived): This struct contains certain quantities\n    which are precomputed from `minibatch`. It's to be generated by\n    calling :meth:`get_rnnlm_example_derived` prior to calling this\n    function.\n  word_embedding (CuMatrixBase): The word-embedding, dimension is\n    num-words by embedding-dimension. This does not have to be 'real'\n    word-indexes, it can be fake word-indexes renumbered to include only\n    the required words if sampling is done; c.f.\n    :meth:`renumber_rnnlm_example`.\n  nnet_output (CuMatrixBase): The neural net output. Num-rows is\n    `minibatch.chunk_length * minibatch.num_chunks`, where the stride for\n    the time `0 <= t < chunk_length` is larger, so there are a block of\n    rows for `t=0`, a block for `t=1`, and so on.  Num-columns is\n    embedding-dimension.\n  word_embedding_deriv (CuMatrixBase): If not None, the derivative of the\n    objective function w.r.t. `word_embedding` is *added* to this\n    location.\n  nnet_output_deriv (CuMatrixBase): If not None, the derivative of the\n    objective function w.r.t. `nnet_output` is *added* to this location.\n\nReturns:\n  * **weight** -- The total weight over this minibatch. It is equal to\n    `minibatch.output_weights.sum()`.\n  * **objf_num** -- The total numerator part of the objective function,\n    i.e. the sum over `i` of `weight(i) * num_term(i)`.\n  * **objf_den** -- The total denominator part of the objective function,\n    i.e. the sum over `i` of `weight(i) * den_term(i)`. You add this to\n    `objf_num` to get the total objective function.\n  * **objf_den_exact** -- If we're not doing sampling (i.e. if\n    `len(minibatch.sampled_words) == 0`), the 'exact' denominator part of\n    the objective function, i.e. the weighted sum of `exact_den_term(i) =\n    -log(\\sum_w p(i,w))`. If we are sampling, then there is no exact\n    denominator part, and this will be set to zero. This is provided for\n    diagnostic purposes. Derivatives will be computed w.r.t. the\n    objective consisting of `objf_num + objf_den`, i.e. ignoring the\n    'exact' one.")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyRnnlmExampleDerived::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmExampleDerived::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyRnnlmObjectiveOptions::wrapper_Type) < 0) return false;
  Py_INCREF(&pyRnnlmObjectiveOptions::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_rnnlm_example_utils",  // module name
  "CLIF-generated module for rnnlm/rnnlm-example-utils.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_options_itf")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrixdim")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_array")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_nnet_computation")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_rnnlm_example")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "RnnlmExampleDerived", reinterpret_cast<PyObject*>(&pyRnnlmExampleDerived::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "RnnlmObjectiveOptions", reinterpret_cast<PyObject*>(&pyRnnlmObjectiveOptions::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __rnnlm__example__utils_clifwrap

namespace kaldi { namespace rnnlm {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// RnnlmExampleDerived to/from ::kaldi::rnnlm::RnnlmExampleDerived conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmExampleDerived** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::RnnlmExampleDerived* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::RnnlmExampleDerived>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleDerived* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::RnnlmExampleDerived>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleDerived* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmExampleDerived instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmExampleDerived* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleDerived* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::RnnlmExampleDerived>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmExampleDerived* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::RnnlmExampleDerived* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleDerived>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::RnnlmExampleDerived> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleDerived>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::RnnlmExampleDerived> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmExampleDerived>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::RnnlmExampleDerived& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmExampleDerived::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmExampleDerived>(c);
  return py;
}

// RnnlmObjectiveOptions to/from ::kaldi::rnnlm::RnnlmObjectiveOptions conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmObjectiveOptions** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::rnnlm::RnnlmObjectiveOptions* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::rnnlm::RnnlmObjectiveOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmObjectiveOptions* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::rnnlm::RnnlmObjectiveOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmObjectiveOptions* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert RnnlmObjectiveOptions instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::rnnlm::RnnlmObjectiveOptions* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmObjectiveOptions* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::rnnlm::RnnlmObjectiveOptions>* c) {
  assert(c != nullptr);
  ::kaldi::rnnlm::RnnlmObjectiveOptions* cpp = __rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::rnnlm::RnnlmObjectiveOptions* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmObjectiveOptions>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::rnnlm::RnnlmObjectiveOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmObjectiveOptions>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::rnnlm::RnnlmObjectiveOptions> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::rnnlm::RnnlmObjectiveOptions>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::rnnlm::RnnlmObjectiveOptions& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper_Type, NULL, NULL);
  reinterpret_cast<__rnnlm__example__utils_clifwrap::pyRnnlmObjectiveOptions::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::rnnlm::RnnlmObjectiveOptions>(c);
  return py;
}

} }  // namespace kaldi::rnnlm
