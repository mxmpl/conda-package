//////////////////////////////////////////////////////////////////////
// This file was automatically generated by CLIF to run under Python 3
// Version 0.3
//////////////////////////////////////////////////////////////////////
// source: /pykaldi/kaldi/cudamatrix/cu-matrix.clif

#include <Python.h>
#include "clif/python/ptr_util.h"
#include "clif/python/optional.h"
#include "clif/python/types.h"
#include "base/iostream-clifwrap.h"
#include "matrix/matrix-common-clifwrap.h"
#include "matrix/kaldi-vector-clifwrap.h"
#include "matrix/kaldi-matrix-clifwrap.h"
#include "cudamatrix/cu-matrixdim-clifwrap.h"
#include "cudamatrix/cu-array-clifwrap.h"
#include "cudamatrix/cu-vector-clifwrap.h"
#include "cu-matrix-clifwrap.h"
#include "clif/python/stltypes.h"
#include "clif/python/slots.h"

namespace __cu__matrix_clifwrap {
using namespace clif;

#define _0 py::postconv::PASS
#define _1 UnicodeFromBytes
#define _2 UnicodeFromBytes


namespace pyCuMatrixBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuMatrixBase<float>> cpp;
};
static ::kaldi::CuMatrixBase<float>* ThisPtr(PyObject*);

// copy_cols(src:CuMatrixBase, indexes:CuArray)
static PyObject* wrapCopyCols_as_copy_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_cols", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_cols", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyCols(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_cols(src:CuMatrixBase, indexes:CuArray)
static PyObject* wrapAddCols_as_add_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_cols", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_cols", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_cols", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddCols(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows(src:CuMatrixBase, indexes:CuArray)
static PyObject* wrapCopyRows_as_copy_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_rows", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRows(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_rows(dst:CuFloatPtrArray)
static PyObject* wrapCopyToRows_as_copy_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("dst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_to_rows", names, &a[0])) return nullptr;
  ::kaldi::CuArray<float *>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_rows", names[0], "::kaldi::CuArray<float *>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyToRows(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_rows(alpha:float, src:CuMatrixBase, indexes:CuArray)
static PyObject* wrapAddRows_as_add_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_rows", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_rows", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_rows", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuArray<int>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_rows", names[2], "::kaldi::CuArray<int>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddRows(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows(src:CuMatrixBase, indexes:CuArray)
static PyObject* wrapMulRows_as_mul_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:mul_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("mul_rows", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRows(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_rows(alpha:float, dst:CuFloatPtrArray)
static PyObject* wrapAddToRows_as_add_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("dst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_to_rows", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_rows", names[0], "float", a[0]);
  ::kaldi::CuArray<float *>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_rows", names[1], "::kaldi::CuArray<float *>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToRows(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sum_column_ranges(src:CuMatrixBase, indexes:CuIntPairArray)
static PyObject* wrapSumColumnRanges_as_sum_column_ranges(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:sum_column_ranges", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sum_column_ranges", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray< ::Int32Pair>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sum_column_ranges", names[1], "::kaldi::CuArray< ::Int32Pair>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SumColumnRanges(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_row_ranges(src:CuMatrixBase, indexes:CuIntPairArray)
static PyObject* wrapAddRowRanges_as_add_row_ranges(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_row_ranges", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_row_ranges", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuArray< ::Int32Pair>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_row_ranges", names[1], "::kaldi::CuArray< ::Int32Pair>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddRowRanges(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_diag(value:float)
static PyObject* wrapAddToDiag_as_add_to_diag(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_to_diag", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_diag", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToDiag(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_rows() -> int
static PyObject* wrapNumRows_as_num_rows(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_cols() -> int
static PyObject* wrapNumCols_as_num_cols(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumCols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// stride() -> int
static PyObject* wrapStride_as_stride(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Stride();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// dim() -> MatrixDim
static PyObject* wrapDim_as_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::MatrixDim_ ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(tol:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "float", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// approx_equal(other:CuMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_from_mat(src:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as_copy_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("src"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_mat", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_cu_mat(src:CuMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as_copy_from_cu_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("src"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_cu_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_cu_mat", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_cu_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_mat(dst:MatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("dst"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_mat", names[0], "::kaldi::MatrixBase<float> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows_from_cu_vec(v:CuVectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_cu_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_cu_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows_from_vec(v:VectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_vec", names[0], "::kaldi::VectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_cols_from_cu_vec(v:CuVectorBase)
static PyObject* wrapCopyColsFromVec_as_copy_cols_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_cols_from_cu_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols_from_cu_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_col_from_cu_vec(v:CuVectorBase, col:int)
static PyObject* wrapCopyColFromVec_as_copy_col_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_col_from_cu_vec", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_col_from_cu_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_col_from_cu_vec", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sigmoid(src:CuMatrixBase)
static PyObject* wrapSigmoid_as_sigmoid(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// heaviside(src:CuMatrixBase)
static PyObject* wrapHeaviside_as_heaviside(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:heaviside", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("heaviside", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Heaviside(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// soft_hinge(src:CuMatrixBase)
static PyObject* wrapSoftHinge_as_soft_hinge(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:soft_hinge", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("soft_hinge", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SoftHinge(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_pnorm(src:CuMatrixBase, pow:float)
static PyObject* wrapGroupPnorm_as_group_pnorm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("pow"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_pnorm", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  float arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm", names[1], "float", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnorm(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_group_pnorm(in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, power:float)
static PyObject* wrapDiffGroupPnorm_as_diff_group_pnorm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:diff_group_pnorm", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_group_pnorm", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_group_pnorm", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("diff_group_pnorm", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("diff_group_pnorm", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffGroupPnorm(*arg1, *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_max(src:CuMatrixBase)
static PyObject* wrapGroupMax_as_group_max(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:group_max", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMax(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_max_deriv(input:CuMatrixBase, output:CuMatrixBase)
static PyObject* wrapGroupMaxDeriv_as_group_max_deriv(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input"),
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_max_deriv", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_deriv", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_max_deriv", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMaxDeriv(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// parametric_relu(src:CuMatrixBase, alpha:CuVectorBase, beta:CuVectorBase)
static PyObject* wrapParametricRelu_as_parametric_relu(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("src"),
      C("alpha"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:parametric_relu", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("parametric_relu", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("parametric_relu", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  ::kaldi::CuVectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("parametric_relu", names[2], "::kaldi::CuVectorBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ParametricRelu(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_parametric_relu(value:CuMatrixBase, diff:CuMatrixBase, alpha:CuVectorBase, beta:CuVectorBase)
static PyObject* wrapDiffParametricRelu_as_diff_parametric_relu(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("value"),
      C("diff"),
      C("alpha"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:diff_parametric_relu", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_parametric_relu", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_parametric_relu", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuVectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("diff_parametric_relu", names[2], "::kaldi::CuVectorBase<float>", a[2]);
  ::kaldi::CuVectorBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("diff_parametric_relu", names[3], "::kaldi::CuVectorBase<float>", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffParametricRelu(*arg1, *arg2, *arg3, *arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// tanh(src:CuMatrixBase)
static PyObject* wrapTanh_as_tanh(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_sigmoid(value:CuMatrixBase, diff:CuMatrixBase)
static PyObject* wrapDiffSigmoid_as_diff_sigmoid(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_sigmoid", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_sigmoid", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_sigmoid", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSigmoid(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_tanh(value:CuMatrixBase, diff:CuMatrixBase)
static PyObject* wrapDiffTanh_as_diff_tanh(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_tanh", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_tanh", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_tanh", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffTanh(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_softmax_per_row(value:CuMatrixBase, diff:CuMatrixBase)
static PyObject* wrapDiffSoftmaxPerRow_as_diff_softmax_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_softmax_per_row", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_softmax_per_row", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_softmax_per_row", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSoftmaxPerRow(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_log_softmax_per_row(out_value:CuMatrixBase, out_deriv:CuMatrixBase)
static PyObject* wrapDiffLogSoftmaxPerRow_as_diff_log_softmax_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("out_value"),
      C("out_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_log_softmax_per_row", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_log_softmax_per_row", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_log_softmax_per_row", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffLogSoftmaxPerRow(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_xent(tgt:CuArray) -> CuVector
static PyObject* wrapDiffXent_as_diff_xent(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("tgt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:diff_xent", names, &a[0])) return nullptr;
  ::kaldi::CuArray<int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_xent", names[0], "::kaldi::CuArray<int>", a[0]);
  ::kaldi::CuVector<float> ret0{};
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffXent(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// cholesky(inv_cholesky:CuMatrixBase=default)
static PyObject* wrapCholesky_as_cholesky(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("inv_cholesky"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:cholesky", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float> * arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("cholesky", names[0], "::kaldi::CuMatrixBase<float> *", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    c->Cholesky(); break;
  case 1:
    c->Cholesky(arg1); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sym_invert_pos_def()
static PyObject* wrapSymInvertPosDef_as_sym_invert_pos_def(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymInvertPosDef();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_pow(power:float)
static PyObject* wrapApplyPow_as_apply_pow(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_pow_abs(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs", names[0], "float", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_heaviside()
static PyObject* wrapApplyHeaviside_as_apply_heaviside(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyHeaviside();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_floor(floor_val:float)
static PyObject* wrapApplyFloor_as_apply_floor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor_val"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_ceiling(ceiling_val:float)
static PyObject* wrapApplyCeiling_as_apply_ceiling(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling_val"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_exp()
static PyObject* wrapApplyExp_as_apply_exp(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_soft_max_per_row(src:CuMatrixBase)
static PyObject* wrapApplySoftMaxPerRow_as_apply_soft_max_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_soft_max_per_row", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_soft_max_per_row", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplySoftMaxPerRow(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_log_soft_max_per_row(src:CuMatrixBase)
static PyObject* wrapApplyLogSoftMaxPerRow_as_apply_log_soft_max_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_log_soft_max_per_row", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_log_soft_max_per_row", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLogSoftMaxPerRow(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// find_row_max_id() -> CuArray
static PyObject* wrapFindRowMaxId_as_find_row_max_id(PyObject* self) {
  ::kaldi::CuArray<int> ret0{};
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FindRowMaxId(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_zero()
static PyObject* wrapSetZero_as_set_zero(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set(value:float)
static PyObject* wrapSet_as_set(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(value:float)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_zero_above_diag()
static PyObject* wrapSetZeroAboveDiag_as_set_zero_above_diag(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZeroAboveDiag();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(value:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "float", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_log()
static PyObject* wrapApplyLog_as_apply_log(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_elements(A:CuMatrixBase)
static PyObject* wrapMulElements_as_mul_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_elements", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_elements", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// div_elements(A:CuMatrixBase)
static PyObject* wrapDivElements_as_div_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_elements", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_elements", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// max_elementwise(A:CuMatrixBase)
static PyObject* wrapMax_as_max_elementwise(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:max_elementwise", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("max_elementwise", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Max(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// min_elementwise(A:CuMatrixBase)
static PyObject* wrapMin_as_min_elementwise(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:min_elementwise", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("min_elementwise", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Min(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_cols_vec(scale:CuVectorBase)
static PyObject* wrapMulColsVec_as_mul_cols_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_cols_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_cols_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulColsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows_vec(scale:CuVectorBase)
static PyObject* wrapMulRowsVec_as_mul_rows_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows_group_mat(src:CuMatrixBase)
static PyObject* wrapMulRowsGroupMat_as_mul_rows_group_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_group_mat", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_group_mat", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsGroupMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// div_rows_vec(div:CuVectorBase)
static PyObject* wrapDivRowsVec_as_div_rows_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("div"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_rows_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_rows_vec", names[0], "::kaldi::CuVectorBase<float>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// invert_elements()
static PyObject* wrapInvertElements_as_invert_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat(alpha:float, A:CuMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapAddMat_as_add_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("A"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMat(std::move(arg1), *arg2); break;
  case 3:
    c->AddMat(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_blocks(alpha:float, A:CuMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapAddMatBlocks_as_add_mat_blocks(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("A"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_mat_blocks", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_blocks", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_blocks", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_blocks", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMatBlocks(std::move(arg1), *arg2); break;
  case 3:
    c->AddMatBlocks(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_to_cols(alpha:float, col:CuVectorBase, beta:float=default)
static PyObject* wrapAddVecToCols_as_add_vec_to_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("col"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_vec_to_cols", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_cols", names[0], "float", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_cols", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_to_cols", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddVecToCols(std::move(arg1), *arg2); break;
  case 3:
    c->AddVecToCols(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_to_rows(alpha:float, row:CuVectorBase, beta:float=default)
static PyObject* wrapAddVecToRows_as_add_vec_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("row"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_vec_to_rows", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_rows", names[0], "float", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_rows", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_to_rows", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddVecToRows(std::move(arg1), *arg2); break;
  case 3:
    c->AddVecToRows(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_mat(alpha:float, A:CuMatrixBase, transA:MatrixTransposeType, B:CuMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMat_as_add_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:add_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::CuMatrixBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat", names[3], "::kaldi::CuMatrixBase<float>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_mat", names[4], "::kaldi::MatrixTransposeType", a[4]);
  float arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("add_mat_mat", names[5], "float", a[5]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_vec(alpha:float, x:CuVectorBase, y:CuVectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec", names, &a[0], &a[1], &a[2])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec", names[0], "float", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  ::kaldi::CuVectorBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec", names[2], "::kaldi::CuVectorBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_mat_mat_div_mat(A:CuMatrixBase, B:CuMatrixBase, C:CuMatrixBase)
static PyObject* wrapSetMatMatDivMat_as_set_mat_mat_div_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("A"),
      C("B"),
      C("C"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:set_mat_mat_div_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_mat_mat_div_mat", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_mat_mat_div_mat", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("set_mat_mat_div_mat", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetMatMatDivMat(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sym_add_mat2(alpha:float, M:CuMatrixBase, transA:MatrixTransposeType, beta:float)
static PyObject* wrapSymAddMat2_as_sym_add_mat2(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transA"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:sym_add_mat2", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_add_mat2", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_add_mat2", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_add_mat2", names[2], "::kaldi::MatrixTransposeType", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("sym_add_mat2", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymAddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_diag_vec_mat(alpha:float, v:CuVectorBase, M:CuMatrixBase, transM:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagVecMat_as_add_diag_vec_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("v"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_diag_vec_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_mat", names[0], "float", a[0]);
  ::kaldi::CuVectorBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_mat", names[1], "::kaldi::CuVectorBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_diag_vec_mat", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_diag_vec_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_diag_vec_mat", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4)); break;
  case 5:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_diag_vec(alpha:float, M:CuMatrixBase, transM:MatrixTransposeType, v:CuVectorBase, beta:float=default)
static PyObject* wrapAddMatDiagVec_as_add_mat_diag_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_diag_vec", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_diag_vec", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_diag_vec", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_diag_vec", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::CuVectorBase<float>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_diag_vec", names[3], "::kaldi::CuVectorBase<float>", a[3]);
  float arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_diag_vec", names[4], "float", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_mat_elements(alpha:float, A:CuMatrixBase, B:CuMatrixBase, beta:float)
static PyObject* wrapAddMatMatElements_as_add_mat_mat_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat_mat_elements", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_elements", names[0], "float", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_elements", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  ::kaldi::CuMatrixBase<float>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_elements", names[2], "::kaldi::CuMatrixBase<float>", a[2]);
  float arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_elements", names[3], "float", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatElements(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_lower_to_upper()
static PyObject* wrapCopyLowerToUpper_as_copy_lower_to_upper(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyLowerToUpper();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_upper_to_lower()
static PyObject* wrapCopyUpperToLower_as_copy_upper_to_lower(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyUpperToLower();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _getitem(r:int, c:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("c"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace(check_square:bool=default) -> float
static PyObject* wrapTrace_as_trace(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("check_square"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:trace", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("trace", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  float ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->Trace(); break;
  case 1:
    ret0 = c->Trace(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn()
static PyObject* wrapSetRandn_as_set_randn(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_rand_uniform()
static PyObject* wrapSetRandUniform_as_set_rand_uniform(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_elements(alpha:float, input:list<MatrixElement>)
static PyObject* wrapAddElements_as_add_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("input"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_elements", names, &a[0], &a[1])) return nullptr;
  float arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_elements", names[0], "float", a[0]);
  ::std::vector< ::MatrixElement<float> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_elements", names[1], "::std::vector< ::MatrixElement<float> >", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddElements(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("copy_cols"), (PyCFunction)wrapCopyCols_as_copy_cols, METH_VARARGS | METH_KEYWORDS, C("copy_cols(src:CuMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyCols(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray<int>)")},
  {C("add_cols"), (PyCFunction)wrapAddCols_as_add_cols, METH_VARARGS | METH_KEYWORDS, C("add_cols(src:CuMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddCols(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray<int>)")},
  {C("copy_rows"), (PyCFunction)wrapCopyRows_as_copy_rows, METH_VARARGS | METH_KEYWORDS, C("copy_rows(src:CuMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyRows(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray<int>)")},
  {C("copy_to_rows"), (PyCFunction)wrapCopyToRows_as_copy_to_rows, METH_VARARGS | METH_KEYWORDS, C("copy_to_rows(dst:CuFloatPtrArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyToRows(::kaldi::CuArray<float *>)")},
  {C("add_rows"), (PyCFunction)wrapAddRows_as_add_rows, METH_VARARGS | METH_KEYWORDS, C("add_rows(alpha:float, src:CuMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddRows(float, ::kaldi::CuMatrixBase<float>, ::kaldi::CuArray<int>)")},
  {C("mul_rows"), (PyCFunction)wrapMulRows_as_mul_rows, METH_VARARGS | METH_KEYWORDS, C("mul_rows(src:CuMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::MulRows(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray<int>)")},
  {C("add_to_rows"), (PyCFunction)wrapAddToRows_as_add_to_rows, METH_VARARGS | METH_KEYWORDS, C("add_to_rows(alpha:float, dst:CuFloatPtrArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddToRows(float, ::kaldi::CuArray<float *>)")},
  {C("sum_column_ranges"), (PyCFunction)wrapSumColumnRanges_as_sum_column_ranges, METH_VARARGS | METH_KEYWORDS, C("sum_column_ranges(src:CuMatrixBase, indexes:CuIntPairArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SumColumnRanges(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray< ::Int32Pair>)")},
  {C("add_row_ranges"), (PyCFunction)wrapAddRowRanges_as_add_row_ranges, METH_VARARGS | METH_KEYWORDS, C("add_row_ranges(src:CuMatrixBase, indexes:CuIntPairArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddRowRanges(::kaldi::CuMatrixBase<float>, ::kaldi::CuArray< ::Int32Pair>)")},
  {C("add_to_diag"), (PyCFunction)wrapAddToDiag_as_add_to_diag, METH_VARARGS | METH_KEYWORDS, C("add_to_diag(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddToDiag(float)")},
  {C("num_rows"), (PyCFunction)wrapNumRows_as_num_rows, METH_NOARGS, C("num_rows() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<float>::NumRows()")},
  {C("num_cols"), (PyCFunction)wrapNumCols_as_num_cols, METH_NOARGS, C("num_cols() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<float>::NumCols()")},
  {C("stride"), (PyCFunction)wrapStride_as_stride, METH_NOARGS, C("stride() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<float>::Stride()")},
  {C("dim"), (PyCFunction)wrapDim_as_dim, METH_NOARGS, C("dim() -> MatrixDim\n  Calls C++ function\n  ::MatrixDim_ ::kaldi::CuMatrixBase<float>::Dim()")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::FrobeniusNorm()")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::CuMatrixBase<float>::IsUnit(float)")},
  {C("approx_equal"), (PyCFunction)wrapApproxEqual_as_approx_equal, METH_VARARGS | METH_KEYWORDS, C("approx_equal(other:CuMatrixBase, tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::CuMatrixBase<float>::ApproxEqual(::kaldi::CuMatrixBase<float>, float)")},
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<float>::SizeInBytes()")},
  {C("copy_from_mat"), (PyCFunction)wrapCopyFromMat_as_copy_from_mat, METH_VARARGS | METH_KEYWORDS, C("copy_from_mat(src:MatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyFromMat(::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("copy_from_cu_mat"), (PyCFunction)wrapCopyFromMat_as_copy_from_cu_mat, METH_VARARGS | METH_KEYWORDS, C("copy_from_cu_mat(src:CuMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyFromMat(::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("copy_to_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_mat(dst:MatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyToMat(::kaldi::MatrixBase<float> *, ::kaldi::MatrixTransposeType)")},
  {C("copy_rows_from_cu_vec"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_cu_vec(v:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyRowsFromVec(::kaldi::CuVectorBase<float>)")},
  {C("copy_rows_from_vec"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_vec, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_vec(v:VectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyRowsFromVec(::kaldi::VectorBase<float>)")},
  {C("copy_cols_from_cu_vec"), (PyCFunction)wrapCopyColsFromVec_as_copy_cols_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_cols_from_cu_vec(v:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyColsFromVec(::kaldi::CuVectorBase<float>)")},
  {C("copy_col_from_cu_vec"), (PyCFunction)wrapCopyColFromVec_as_copy_col_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_col_from_cu_vec(v:CuVectorBase, col:int)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyColFromVec(::kaldi::CuVectorBase<float>, int)")},
  {C("sigmoid"), (PyCFunction)wrapSigmoid_as_sigmoid, METH_VARARGS | METH_KEYWORDS, C("sigmoid(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Sigmoid(::kaldi::CuMatrixBase<float>)")},
  {C("heaviside"), (PyCFunction)wrapHeaviside_as_heaviside, METH_VARARGS | METH_KEYWORDS, C("heaviside(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Heaviside(::kaldi::CuMatrixBase<float>)")},
  {C("soft_hinge"), (PyCFunction)wrapSoftHinge_as_soft_hinge, METH_VARARGS | METH_KEYWORDS, C("soft_hinge(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SoftHinge(::kaldi::CuMatrixBase<float>)")},
  {C("group_pnorm"), (PyCFunction)wrapGroupPnorm_as_group_pnorm, METH_VARARGS | METH_KEYWORDS, C("group_pnorm(src:CuMatrixBase, pow:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::GroupPnorm(::kaldi::CuMatrixBase<float>, float)")},
  {C("diff_group_pnorm"), (PyCFunction)wrapDiffGroupPnorm_as_diff_group_pnorm, METH_VARARGS | METH_KEYWORDS, C("diff_group_pnorm(in_value:CuMatrixBase, out_value:CuMatrixBase, out_deriv:CuMatrixBase, power:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffGroupPnorm(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, float)")},
  {C("group_max"), (PyCFunction)wrapGroupMax_as_group_max, METH_VARARGS | METH_KEYWORDS, C("group_max(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::GroupMax(::kaldi::CuMatrixBase<float>)")},
  {C("group_max_deriv"), (PyCFunction)wrapGroupMaxDeriv_as_group_max_deriv, METH_VARARGS | METH_KEYWORDS, C("group_max_deriv(input:CuMatrixBase, output:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::GroupMaxDeriv(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("parametric_relu"), (PyCFunction)wrapParametricRelu_as_parametric_relu, METH_VARARGS | METH_KEYWORDS, C("parametric_relu(src:CuMatrixBase, alpha:CuVectorBase, beta:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ParametricRelu(::kaldi::CuMatrixBase<float>, ::kaldi::CuVectorBase<float>, ::kaldi::CuVectorBase<float>)")},
  {C("diff_parametric_relu"), (PyCFunction)wrapDiffParametricRelu_as_diff_parametric_relu, METH_VARARGS | METH_KEYWORDS, C("diff_parametric_relu(value:CuMatrixBase, diff:CuMatrixBase, alpha:CuVectorBase, beta:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffParametricRelu(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuVectorBase<float>, ::kaldi::CuVectorBase<float>)")},
  {C("tanh"), (PyCFunction)wrapTanh_as_tanh, METH_VARARGS | METH_KEYWORDS, C("tanh(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Tanh(::kaldi::CuMatrixBase<float>)")},
  {C("diff_sigmoid"), (PyCFunction)wrapDiffSigmoid_as_diff_sigmoid, METH_VARARGS | METH_KEYWORDS, C("diff_sigmoid(value:CuMatrixBase, diff:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffSigmoid(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("diff_tanh"), (PyCFunction)wrapDiffTanh_as_diff_tanh, METH_VARARGS | METH_KEYWORDS, C("diff_tanh(value:CuMatrixBase, diff:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffTanh(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("diff_softmax_per_row"), (PyCFunction)wrapDiffSoftmaxPerRow_as_diff_softmax_per_row, METH_VARARGS | METH_KEYWORDS, C("diff_softmax_per_row(value:CuMatrixBase, diff:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffSoftmaxPerRow(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("diff_log_softmax_per_row"), (PyCFunction)wrapDiffLogSoftmaxPerRow_as_diff_log_softmax_per_row, METH_VARARGS | METH_KEYWORDS, C("diff_log_softmax_per_row(out_value:CuMatrixBase, out_deriv:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffLogSoftmaxPerRow(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("diff_xent"), (PyCFunction)wrapDiffXent_as_diff_xent, METH_VARARGS | METH_KEYWORDS, C("diff_xent(tgt:CuArray) -> CuVector\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DiffXent(::kaldi::CuArray<int>, ::kaldi::CuVector<float>*)")},
  {C("cholesky"), (PyCFunction)wrapCholesky_as_cholesky, METH_VARARGS | METH_KEYWORDS, C("cholesky(inv_cholesky:CuMatrixBase=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Cholesky(::kaldi::CuMatrixBase<float> *)")},
  {C("sym_invert_pos_def"), (PyCFunction)wrapSymInvertPosDef_as_sym_invert_pos_def, METH_NOARGS, C("sym_invert_pos_def()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SymInvertPosDef()")},
  {C("apply_pow"), (PyCFunction)wrapApplyPow_as_apply_pow, METH_VARARGS | METH_KEYWORDS, C("apply_pow(power:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyPow(float)")},
  {C("apply_pow_abs"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs(power:float, include_sign:bool=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyPowAbs(float, bool)")},
  {C("apply_heaviside"), (PyCFunction)wrapApplyHeaviside_as_apply_heaviside, METH_NOARGS, C("apply_heaviside()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyHeaviside()")},
  {C("apply_floor"), (PyCFunction)wrapApplyFloor_as_apply_floor, METH_VARARGS | METH_KEYWORDS, C("apply_floor(floor_val:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyFloor(float)")},
  {C("apply_ceiling"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling(ceiling_val:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyCeiling(float)")},
  {C("apply_exp"), (PyCFunction)wrapApplyExp_as_apply_exp, METH_NOARGS, C("apply_exp()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyExp()")},
  {C("apply_soft_max_per_row"), (PyCFunction)wrapApplySoftMaxPerRow_as_apply_soft_max_per_row, METH_VARARGS | METH_KEYWORDS, C("apply_soft_max_per_row(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplySoftMaxPerRow(::kaldi::CuMatrixBase<float>)")},
  {C("apply_log_soft_max_per_row"), (PyCFunction)wrapApplyLogSoftMaxPerRow_as_apply_log_soft_max_per_row, METH_VARARGS | METH_KEYWORDS, C("apply_log_soft_max_per_row(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyLogSoftMaxPerRow(::kaldi::CuMatrixBase<float>)")},
  {C("find_row_max_id"), (PyCFunction)wrapFindRowMaxId_as_find_row_max_id, METH_NOARGS, C("find_row_max_id() -> CuArray\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::FindRowMaxId(::kaldi::CuArray<int>*)")},
  {C("set_zero"), (PyCFunction)wrapSetZero_as_set_zero, METH_NOARGS, C("set_zero()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SetZero()")},
  {C("set"), (PyCFunction)wrapSet_as_set, METH_VARARGS | METH_KEYWORDS, C("set(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Set(float)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Add(float)")},
  {C("set_zero_above_diag"), (PyCFunction)wrapSetZeroAboveDiag_as_set_zero_above_diag, METH_NOARGS, C("set_zero_above_diag()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SetZeroAboveDiag()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Scale(float)")},
  {C("apply_log"), (PyCFunction)wrapApplyLog_as_apply_log, METH_NOARGS, C("apply_log()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::ApplyLog()")},
  {C("mul_elements"), (PyCFunction)wrapMulElements_as_mul_elements, METH_VARARGS | METH_KEYWORDS, C("mul_elements(A:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::MulElements(::kaldi::CuMatrixBase<float>)")},
  {C("div_elements"), (PyCFunction)wrapDivElements_as_div_elements, METH_VARARGS | METH_KEYWORDS, C("div_elements(A:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DivElements(::kaldi::CuMatrixBase<float>)")},
  {C("max_elementwise"), (PyCFunction)wrapMax_as_max_elementwise, METH_VARARGS | METH_KEYWORDS, C("max_elementwise(A:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Max(::kaldi::CuMatrixBase<float>)")},
  {C("min_elementwise"), (PyCFunction)wrapMin_as_min_elementwise, METH_VARARGS | METH_KEYWORDS, C("min_elementwise(A:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Min(::kaldi::CuMatrixBase<float>)")},
  {C("mul_cols_vec"), (PyCFunction)wrapMulColsVec_as_mul_cols_vec, METH_VARARGS | METH_KEYWORDS, C("mul_cols_vec(scale:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::MulColsVec(::kaldi::CuVectorBase<float>)")},
  {C("mul_rows_vec"), (PyCFunction)wrapMulRowsVec_as_mul_rows_vec, METH_VARARGS | METH_KEYWORDS, C("mul_rows_vec(scale:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::MulRowsVec(::kaldi::CuVectorBase<float>)")},
  {C("mul_rows_group_mat"), (PyCFunction)wrapMulRowsGroupMat_as_mul_rows_group_mat, METH_VARARGS | METH_KEYWORDS, C("mul_rows_group_mat(src:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::MulRowsGroupMat(::kaldi::CuMatrixBase<float>)")},
  {C("div_rows_vec"), (PyCFunction)wrapDivRowsVec_as_div_rows_vec, METH_VARARGS | METH_KEYWORDS, C("div_rows_vec(div:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::DivRowsVec(::kaldi::CuVectorBase<float>)")},
  {C("invert_elements"), (PyCFunction)wrapInvertElements_as_invert_elements, METH_NOARGS, C("invert_elements()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::InvertElements()")},
  {C("add_mat"), (PyCFunction)wrapAddMat_as_add_mat, METH_VARARGS | METH_KEYWORDS, C("add_mat(alpha:float, A:CuMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddMat(float, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("add_mat_blocks"), (PyCFunction)wrapAddMatBlocks_as_add_mat_blocks, METH_VARARGS | METH_KEYWORDS, C("add_mat_blocks(alpha:float, A:CuMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddMatBlocks(float, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("add_vec_to_cols"), (PyCFunction)wrapAddVecToCols_as_add_vec_to_cols, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_cols(alpha:float, col:CuVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddVecToCols(float, ::kaldi::CuVectorBase<float>, float)")},
  {C("add_vec_to_rows"), (PyCFunction)wrapAddVecToRows_as_add_vec_to_rows, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_rows(alpha:float, row:CuVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddVecToRows(float, ::kaldi::CuVectorBase<float>, float)")},
  {C("add_mat_mat"), (PyCFunction)wrapAddMatMat_as_add_mat_mat, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat(alpha:float, A:CuMatrixBase, transA:MatrixTransposeType, B:CuMatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddMatMat(float, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("add_vec_vec"), (PyCFunction)wrapAddVecVec_as_add_vec_vec, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec(alpha:float, x:CuVectorBase, y:CuVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddVecVec(float, ::kaldi::CuVectorBase<float>, ::kaldi::CuVectorBase<float>)")},
  {C("set_mat_mat_div_mat"), (PyCFunction)wrapSetMatMatDivMat_as_set_mat_mat_div_mat, METH_VARARGS | METH_KEYWORDS, C("set_mat_mat_div_mat(A:CuMatrixBase, B:CuMatrixBase, C:CuMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SetMatMatDivMat(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("sym_add_mat2"), (PyCFunction)wrapSymAddMat2_as_sym_add_mat2, METH_VARARGS | METH_KEYWORDS, C("sym_add_mat2(alpha:float, M:CuMatrixBase, transA:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SymAddMat2(float, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("add_diag_vec_mat"), (PyCFunction)wrapAddDiagVecMat_as_add_diag_vec_mat, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_mat(alpha:float, v:CuVectorBase, M:CuMatrixBase, transM:MatrixTransposeType, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddDiagVecMat(float, ::kaldi::CuVectorBase<float>, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType, float)")},
  {C("add_mat_diag_vec"), (PyCFunction)wrapAddMatDiagVec_as_add_mat_diag_vec, METH_VARARGS | METH_KEYWORDS, C("add_mat_diag_vec(alpha:float, M:CuMatrixBase, transM:MatrixTransposeType, v:CuVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddMatDiagVec(float, ::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType, ::kaldi::CuVectorBase<float>, float)")},
  {C("add_mat_mat_elements"), (PyCFunction)wrapAddMatMatElements_as_add_mat_mat_elements, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_elements(alpha:float, A:CuMatrixBase, B:CuMatrixBase, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddMatMatElements(float, ::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, float)")},
  {C("copy_lower_to_upper"), (PyCFunction)wrapCopyLowerToUpper_as_copy_lower_to_upper, METH_NOARGS, C("copy_lower_to_upper()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyLowerToUpper()")},
  {C("copy_upper_to_lower"), (PyCFunction)wrapCopyUpperToLower_as_copy_upper_to_lower, METH_NOARGS, C("copy_upper_to_lower()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::CopyUpperToLower()")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(r:int, c:int) -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::operator()(int, int)")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::Sum()")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::Max()")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::Min()")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_VARARGS | METH_KEYWORDS, C("trace(check_square:bool=default) -> float\n  Calls C++ function\n  float ::kaldi::CuMatrixBase<float>::Trace(bool)")},
  {C("set_randn"), (PyCFunction)wrapSetRandn_as_set_randn, METH_NOARGS, C("set_randn()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SetRandn()")},
  {C("set_rand_uniform"), (PyCFunction)wrapSetRandUniform_as_set_rand_uniform, METH_NOARGS, C("set_rand_uniform()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::SetRandUniform()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("add_elements"), (PyCFunction)wrapAddElements_as_add_elements, METH_VARARGS | METH_KEYWORDS, C("add_elements(alpha:float, input:list<MatrixElement>)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<float>::AddElements(float, ::std::vector< ::MatrixElement<float> >)")},
  {}
};

// CuMatrixBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuMatrixBase __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuMatrixBase",           // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuMatrixBase<float>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuMatrixBase<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuMatrixBase_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuMatrixBase<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuMatrixBase<float>* c = static_cast<::kaldi::CuMatrixBase<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuMatrixBase<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuMatrixBase

namespace pyCuMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuMatrix<float>> cpp;
};
static ::kaldi::CuMatrix<float>* ThisPtr(PyObject*);

// @classmethod from_size(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> CuMatrix
static PyObject* wrapCuMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:from_size", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("from_size", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_size", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_size", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(other:CuMatrixBase, trans:MatrixTransposeType=default) -> CuMatrix
static PyObject* wrapCuMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_other", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_matrix(other:MatrixBase, trans:MatrixTransposeType=default) -> CuMatrix
static PyObject* wrapCuMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<float>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<float>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// transpose()
static PyObject* wrapTranspose_as_transpose(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// resize(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)
static PyObject* wrapResize_as_resize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:resize", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("resize", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("resize", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap_with_matrix(mat:Matrix)
static PyObject* wrapSwap_as_swap_with_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_with_matrix", names, &a[0])) return nullptr;
  ::kaldi::Matrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_with_matrix", names[0], "::kaldi::Matrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap(mat:CuMatrix)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::CuMatrix<float> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::CuMatrix<float> *", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// comp_objf_and_deriv(elements:list<MatrixElement>, A:CuMatrix) -> (tot_objf:float, tot_weight:float)
static PyObject* wrapCompObjfAndDeriv_as_comp_objf_and_deriv(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("elements"),
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:comp_objf_and_deriv", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::MatrixElement<float> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("comp_objf_and_deriv", names[0], "::std::vector< ::MatrixElement<float> >", a[0]);
  ::kaldi::CuMatrix<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("comp_objf_and_deriv", names[1], "::kaldi::CuMatrix<float>", a[1]);
  float ret0{};
  float ret1{};
  // Call actual C++ method.
  ::kaldi::CuMatrix<float>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CompObjfAndDeriv(std::move(arg1), *arg2, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// Implicit cast this as ::kaldi::CuMatrixBase<float>*
static PyObject* as_kaldi_CuMatrixBase_float(PyObject* self) {
  ::kaldi::CuMatrixBase<float>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::CuMatrixBase<float>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapCuMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> CuMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<float>> ::kaldi::CuMatrix<float>::CuMatrix(int, int, ::kaldi::MatrixResizeType, ::kaldi::MatrixStrideType)")},
  {C("from_other"), (PyCFunction)wrapCuMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:CuMatrixBase, trans:MatrixTransposeType=default) -> CuMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<float>> ::kaldi::CuMatrix<float>::CuMatrix(::kaldi::CuMatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("from_matrix"), (PyCFunction)wrapCuMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(other:MatrixBase, trans:MatrixTransposeType=default) -> CuMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<float>> ::kaldi::CuMatrix<float>::CuMatrix(::kaldi::MatrixBase<float>, ::kaldi::MatrixTransposeType)")},
  {C("transpose"), (PyCFunction)wrapTranspose_as_transpose, METH_NOARGS, C("transpose()\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::Transpose()")},
  {C("resize"), (PyCFunction)wrapResize_as_resize, METH_VARARGS | METH_KEYWORDS, C("resize(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::Resize(int, int, ::kaldi::MatrixResizeType, ::kaldi::MatrixStrideType)")},
  {C("swap_with_matrix"), (PyCFunction)wrapSwap_as_swap_with_matrix, METH_VARARGS | METH_KEYWORDS, C("swap_with_matrix(mat:Matrix)\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::Swap(::kaldi::Matrix<float> *)")},
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(mat:CuMatrix)\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::Swap(::kaldi::CuMatrix<float> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("comp_objf_and_deriv"), (PyCFunction)wrapCompObjfAndDeriv_as_comp_objf_and_deriv, METH_VARARGS | METH_KEYWORDS, C("comp_objf_and_deriv(elements:list<MatrixElement>, A:CuMatrix) -> (tot_objf:float, tot_weight:float)\n  Calls C++ function\n  void ::kaldi::CuMatrix<float>::CompObjfAndDeriv(::std::vector< ::MatrixElement<float> >, ::kaldi::CuMatrix<float>, float*, float*)")},
  {C("as_kaldi_CuMatrixBase_float"), (PyCFunction)as_kaldi_CuMatrixBase_float, METH_NOARGS, C("Upcast to ::kaldi::CuMatrixBase<float>*")},
  {}
};

// CuMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CuMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuMatrix",               // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuMatrix<float>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CuMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::CuMatrix<float>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuMatrix<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuMatrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuMatrix<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuMatrix<float>* c = static_cast<::kaldi::CuMatrix<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuMatrix<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuMatrix

namespace pyCuSubMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuSubMatrix<float>> cpp;
};
static ::kaldi::CuSubMatrix<float>* ThisPtr(PyObject*);

// __init__(mat:CuMatrixBase, row_offset:int, num_rows:int, col_offset:int, num_cols:int)
static PyObject* wrapCuSubMatrix_float_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("mat"),
      C("row_offset"),
      C("num_rows"),
      C("col_offset"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:__init__", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("__init__", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("__init__", names[4], "int", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::CuSubMatrix<float>>(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:CuSubMatrix) -> CuSubMatrix
static PyObject* wrapCuSubMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::CuSubMatrix<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::CuSubMatrix<float>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuSubMatrix<float>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::CuSubMatrix<float>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::CuMatrixBase<float>*
static PyObject* as_kaldi_CuMatrixBase_float(PyObject* self) {
  ::kaldi::CuMatrixBase<float>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::CuMatrixBase<float>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapCuSubMatrix_float_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(mat:CuMatrixBase, row_offset:int, num_rows:int, col_offset:int, num_cols:int)\n  Calls C++ function\n  void ::kaldi::CuSubMatrix<float>::CuSubMatrix(::kaldi::CuMatrixBase<float>, int, int, int, int)")},
  {C("from_other"), (PyCFunction)wrapCuSubMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:CuSubMatrix) -> CuSubMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuSubMatrix<float>> ::kaldi::CuSubMatrix<float>::CuSubMatrix(::kaldi::CuSubMatrix<float>)")},
  {C("as_kaldi_CuMatrixBase_float"), (PyCFunction)as_kaldi_CuMatrixBase_float, METH_NOARGS, C("Upcast to ::kaldi::CuMatrixBase<float>*")},
  {}
};

// CuSubMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CuSubMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuSubMatrix __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuSubMatrix",            // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuSubMatrix<float>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapCuSubMatrix_float_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuSubMatrix<float>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuSubMatrix_float"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuSubMatrix<float>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuSubMatrix<float>* c = static_cast<::kaldi::CuSubMatrix<float>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuSubMatrix<float>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuSubMatrix

// approx_equal_cu_matrix(A:CuMatrixBase, B:CuMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal_cu_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:approx_equal_cu_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal_cu_matrix", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal_cu_matrix", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("approx_equal_cu_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// assert_equal_cu_matrix(A:CuMatrixBase, B:CuMatrixBase, tol:float=default)
static PyObject* wrapAssertEqual_as_assert_equal_cu_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:assert_equal_cu_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("assert_equal_cu_matrix", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("assert_equal_cu_matrix", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("assert_equal_cu_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// same_dim_cu_matrix(M:CuMatrixBase, N:CuMatrixBase) -> bool
static PyObject* wrapSameDim_as_same_dim_cu_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:same_dim_cu_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("same_dim_cu_matrix", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("same_dim_cu_matrix", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDim(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// same_dim_and_stride_cu_matrix(M:CuMatrixBase, N:CuMatrixBase) -> bool
static PyObject* wrapSameDimAndStride_as_same_dim_and_stride_cu_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:same_dim_and_stride_cu_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<float>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("same_dim_and_stride_cu_matrix", names[0], "::kaldi::CuMatrixBase<float>", a[0]);
  ::kaldi::CuMatrixBase<float>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("same_dim_and_stride_cu_matrix", names[1], "::kaldi::CuMatrixBase<float>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDimAndStride(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

namespace pyCuDoubleMatrixBase {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuMatrixBase<double>> cpp;
};
static ::kaldi::CuMatrixBase<double>* ThisPtr(PyObject*);

// copy_cols(src:CuDoubleMatrixBase, indexes:CuArray)
static PyObject* wrapCopyCols_as_copy_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_cols", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_cols", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyCols(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_cols(src:CuDoubleMatrixBase, indexes:CuArray)
static PyObject* wrapAddCols_as_add_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_cols", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_cols", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_cols", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddCols(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows(src:CuDoubleMatrixBase, indexes:CuArray)
static PyObject* wrapCopyRows_as_copy_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_rows", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRows(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_rows(dst:CuDoublePtrArray)
static PyObject* wrapCopyToRows_as_copy_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("dst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_to_rows", names, &a[0])) return nullptr;
  ::kaldi::CuArray<double *>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_rows", names[0], "::kaldi::CuArray<double *>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyToRows(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_rows(alpha:float, src:CuDoubleMatrixBase, indexes:CuArray)
static PyObject* wrapAddRows_as_add_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_rows", names, &a[0], &a[1], &a[2])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_rows", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_rows", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::CuArray<int>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_rows", names[2], "::kaldi::CuArray<int>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddRows(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows(src:CuDoubleMatrixBase, indexes:CuArray)
static PyObject* wrapMulRows_as_mul_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:mul_rows", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray<int>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("mul_rows", names[1], "::kaldi::CuArray<int>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRows(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_rows(alpha:float, dst:CuDoublePtrArray)
static PyObject* wrapAddToRows_as_add_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("dst"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_to_rows", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_rows", names[0], "double", a[0]);
  ::kaldi::CuArray<double *>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_to_rows", names[1], "::kaldi::CuArray<double *>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToRows(std::move(arg1), *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sum_column_ranges(src:CuDoubleMatrixBase, indexes:CuIntPairArray)
static PyObject* wrapSumColumnRanges_as_sum_column_ranges(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:sum_column_ranges", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sum_column_ranges", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray< ::Int32Pair>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sum_column_ranges", names[1], "::kaldi::CuArray< ::Int32Pair>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SumColumnRanges(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_row_ranges(src:CuDoubleMatrixBase, indexes:CuIntPairArray)
static PyObject* wrapAddRowRanges_as_add_row_ranges(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("indexes"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_row_ranges", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_row_ranges", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuArray< ::Int32Pair>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_row_ranges", names[1], "::kaldi::CuArray< ::Int32Pair>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddRowRanges(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_to_diag(value:float)
static PyObject* wrapAddToDiag_as_add_to_diag(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add_to_diag", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_to_diag", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddToDiag(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// num_rows() -> int
static PyObject* wrapNumRows_as_num_rows(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// __len__() -> int
static PyObject* wrapNumRows_as___len__(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumRows();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// num_cols() -> int
static PyObject* wrapNumCols_as_num_cols(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->NumCols();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// stride() -> int
static PyObject* wrapStride_as_stride(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Stride();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// dim() -> MatrixDim
static PyObject* wrapDim_as_dim(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  ::MatrixDim_ ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Dim();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// frobenius_norm() -> float
static PyObject* wrapFrobeniusNorm_as_frobenius_norm(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->FrobeniusNorm();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// is_unit(tol:float=default) -> bool
static PyObject* wrapIsUnit_as_is_unit(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:is_unit", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("is_unit", names[0], "double", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->IsUnit(); break;
  case 1:
    ret0 = c->IsUnit(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// approx_equal(other:CuDoubleMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:approx_equal", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  float arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal", names[1], "float", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = c->ApproxEqual(*arg1); break;
  case 2:
    ret0 = c->ApproxEqual(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// size_in_bytes() -> int
static PyObject* wrapSizeInBytes_as_size_in_bytes(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  int ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->SizeInBytes();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// copy_from_mat(src:DoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as_copy_from_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("src"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_mat", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_from_cu_mat(src:CuDoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyFromMat_as_copy_from_cu_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("src"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_from_cu_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_from_cu_mat", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_from_cu_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyFromMat(*arg1); break;
  case 2:
    c->CopyFromMat(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_to_mat(dst:DoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapCopyToMat_as_copy_to_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("dst"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:copy_to_mat", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_to_mat", names[0], "::kaldi::MatrixBase<double> *", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_to_mat", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->CopyToMat(arg1); break;
  case 2:
    c->CopyToMat(arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows_from_cu_vec(v:CuDoubleVectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_cu_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_cu_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_rows_from_vec(v:DoubleVectorBase)
static PyObject* wrapCopyRowsFromVec_as_copy_rows_from_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_rows_from_vec", names, &a[0])) return nullptr;
  ::kaldi::VectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_rows_from_vec", names[0], "::kaldi::VectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyRowsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_cols_from_cu_vec(v:CuDoubleVectorBase)
static PyObject* wrapCopyColsFromVec_as_copy_cols_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("v"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:copy_cols_from_cu_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_cols_from_cu_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColsFromVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_col_from_cu_vec(v:CuDoubleVectorBase, col:int)
static PyObject* wrapCopyColFromVec_as_copy_col_from_cu_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("v"),
      C("col"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:copy_col_from_cu_vec", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("copy_col_from_cu_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("copy_col_from_cu_vec", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyColFromVec(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sigmoid(src:CuDoubleMatrixBase)
static PyObject* wrapSigmoid_as_sigmoid(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:sigmoid", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sigmoid", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Sigmoid(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// heaviside(src:CuDoubleMatrixBase)
static PyObject* wrapHeaviside_as_heaviside(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:heaviside", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("heaviside", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Heaviside(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// soft_hinge(src:CuDoubleMatrixBase)
static PyObject* wrapSoftHinge_as_soft_hinge(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:soft_hinge", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("soft_hinge", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SoftHinge(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_pnorm(src:CuDoubleMatrixBase, pow:float)
static PyObject* wrapGroupPnorm_as_group_pnorm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("src"),
      C("pow"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_pnorm", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_pnorm", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  double arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_pnorm", names[1], "double", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupPnorm(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_group_pnorm(in_value:CuDoubleMatrixBase, out_value:CuDoubleMatrixBase, out_deriv:CuDoubleMatrixBase, power:float)
static PyObject* wrapDiffGroupPnorm_as_diff_group_pnorm(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("in_value"),
      C("out_value"),
      C("out_deriv"),
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:diff_group_pnorm", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_group_pnorm", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_group_pnorm", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::CuMatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("diff_group_pnorm", names[2], "::kaldi::CuMatrixBase<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("diff_group_pnorm", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffGroupPnorm(*arg1, *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_max(src:CuDoubleMatrixBase)
static PyObject* wrapGroupMax_as_group_max(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:group_max", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMax(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// group_max_deriv(input:CuDoubleMatrixBase, output:CuDoubleMatrixBase)
static PyObject* wrapGroupMaxDeriv_as_group_max_deriv(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("input"),
      C("output"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:group_max_deriv", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("group_max_deriv", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("group_max_deriv", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->GroupMaxDeriv(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// parametric_relu(src:CuDoubleMatrixBase, alpha:CuDoubleVectorBase, beta:CuDoubleVectorBase)
static PyObject* wrapParametricRelu_as_parametric_relu(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("src"),
      C("alpha"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:parametric_relu", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("parametric_relu", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuVectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("parametric_relu", names[1], "::kaldi::CuVectorBase<double>", a[1]);
  ::kaldi::CuVectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("parametric_relu", names[2], "::kaldi::CuVectorBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ParametricRelu(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_parametric_relu(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase, alpha:CuDoubleVectorBase, beta:CuDoubleVectorBase)
static PyObject* wrapDiffParametricRelu_as_diff_parametric_relu(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("value"),
      C("diff"),
      C("alpha"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:diff_parametric_relu", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_parametric_relu", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_parametric_relu", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::CuVectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("diff_parametric_relu", names[2], "::kaldi::CuVectorBase<double>", a[2]);
  ::kaldi::CuVectorBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("diff_parametric_relu", names[3], "::kaldi::CuVectorBase<double>", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffParametricRelu(*arg1, *arg2, *arg3, *arg4);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// tanh(src:CuDoubleMatrixBase)
static PyObject* wrapTanh_as_tanh(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:tanh", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("tanh", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Tanh(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_sigmoid(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)
static PyObject* wrapDiffSigmoid_as_diff_sigmoid(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_sigmoid", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_sigmoid", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_sigmoid", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSigmoid(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_tanh(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)
static PyObject* wrapDiffTanh_as_diff_tanh(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_tanh", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_tanh", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_tanh", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffTanh(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_softmax_per_row(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)
static PyObject* wrapDiffSoftmaxPerRow_as_diff_softmax_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("value"),
      C("diff"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_softmax_per_row", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_softmax_per_row", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_softmax_per_row", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffSoftmaxPerRow(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_log_softmax_per_row(out_value:CuDoubleMatrixBase, out_deriv:CuDoubleMatrixBase)
static PyObject* wrapDiffLogSoftmaxPerRow_as_diff_log_softmax_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("out_value"),
      C("out_deriv"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:diff_log_softmax_per_row", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_log_softmax_per_row", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("diff_log_softmax_per_row", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffLogSoftmaxPerRow(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// diff_xent(tgt:CuArray) -> CuDoubleVector
static PyObject* wrapDiffXent_as_diff_xent(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("tgt"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:diff_xent", names, &a[0])) return nullptr;
  ::kaldi::CuArray<int>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("diff_xent", names[0], "::kaldi::CuArray<int>", a[0]);
  ::kaldi::CuVector<double> ret0{};
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DiffXent(*arg1, &ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// cholesky(inv_cholesky:CuDoubleMatrixBase=default)
static PyObject* wrapCholesky_as_cholesky(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("inv_cholesky"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:cholesky", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double> * arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("cholesky", names[0], "::kaldi::CuMatrixBase<double> *", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    c->Cholesky(); break;
  case 1:
    c->Cholesky(arg1); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sym_invert_pos_def()
static PyObject* wrapSymInvertPosDef_as_sym_invert_pos_def(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymInvertPosDef();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_pow(power:float)
static PyObject* wrapApplyPow_as_apply_pow(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("power"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_pow", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyPow(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_pow_abs(power:float, include_sign:bool=default)
static PyObject* wrapApplyPowAbs_as_apply_pow_abs(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("power"),
      C("include_sign"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:apply_pow_abs", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_pow_abs", names[0], "double", a[0]);
  bool arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("apply_pow_abs", names[1], "bool", a[1]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    c->ApplyPowAbs(std::move(arg1)); break;
  case 2:
    c->ApplyPowAbs(std::move(arg1), std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_heaviside()
static PyObject* wrapApplyHeaviside_as_apply_heaviside(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyHeaviside();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_floor(floor_val:float)
static PyObject* wrapApplyFloor_as_apply_floor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("floor_val"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_floor", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_floor", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyFloor(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_ceiling(ceiling_val:float)
static PyObject* wrapApplyCeiling_as_apply_ceiling(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("ceiling_val"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_ceiling", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_ceiling", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyCeiling(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_exp()
static PyObject* wrapApplyExp_as_apply_exp(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyExp();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_soft_max_per_row(src:CuDoubleMatrixBase)
static PyObject* wrapApplySoftMaxPerRow_as_apply_soft_max_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_soft_max_per_row", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_soft_max_per_row", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplySoftMaxPerRow(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_log_soft_max_per_row(src:CuDoubleMatrixBase)
static PyObject* wrapApplyLogSoftMaxPerRow_as_apply_log_soft_max_per_row(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:apply_log_soft_max_per_row", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("apply_log_soft_max_per_row", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLogSoftMaxPerRow(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// find_row_max_id() -> CuArray
static PyObject* wrapFindRowMaxId_as_find_row_max_id(PyObject* self) {
  ::kaldi::CuArray<int> ret0{};
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->FindRowMaxId(&ret0);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_zero()
static PyObject* wrapSetZero_as_set_zero(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZero();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set(value:float)
static PyObject* wrapSet_as_set(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:set", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Set(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add(value:float)
static PyObject* wrapAdd_as_add(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:add", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Add(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_zero_above_diag()
static PyObject* wrapSetZeroAboveDiag_as_set_zero_above_diag(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetZeroAboveDiag();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// scale(value:float)
static PyObject* wrapScale_as_scale(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("value"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:scale", names, &a[0])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("scale", names[0], "double", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Scale(std::move(arg1));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// apply_log()
static PyObject* wrapApplyLog_as_apply_log(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->ApplyLog();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_elements(A:CuDoubleMatrixBase)
static PyObject* wrapMulElements_as_mul_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_elements", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_elements", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// div_elements(A:CuDoubleMatrixBase)
static PyObject* wrapDivElements_as_div_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_elements", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_elements", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivElements(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// max_elementwise(A:CuDoubleMatrixBase)
static PyObject* wrapMax_as_max_elementwise(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:max_elementwise", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("max_elementwise", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Max(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// min_elementwise(A:CuDoubleMatrixBase)
static PyObject* wrapMin_as_min_elementwise(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:min_elementwise", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("min_elementwise", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Min(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_cols_vec(scale:CuDoubleVectorBase)
static PyObject* wrapMulColsVec_as_mul_cols_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_cols_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_cols_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulColsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows_vec(scale:CuDoubleVectorBase)
static PyObject* wrapMulRowsVec_as_mul_rows_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("scale"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// mul_rows_group_mat(src:CuDoubleMatrixBase)
static PyObject* wrapMulRowsGroupMat_as_mul_rows_group_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("src"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:mul_rows_group_mat", names, &a[0])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("mul_rows_group_mat", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->MulRowsGroupMat(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// div_rows_vec(div:CuDoubleVectorBase)
static PyObject* wrapDivRowsVec_as_div_rows_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("div"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:div_rows_vec", names, &a[0])) return nullptr;
  ::kaldi::CuVectorBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("div_rows_vec", names[0], "::kaldi::CuVectorBase<double>", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->DivRowsVec(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// invert_elements()
static PyObject* wrapInvertElements_as_invert_elements(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->InvertElements();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat(alpha:float, A:CuDoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapAddMat_as_add_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("A"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMat(std::move(arg1), *arg2); break;
  case 3:
    c->AddMat(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_blocks(alpha:float, A:CuDoubleMatrixBase, trans:MatrixTransposeType=default)
static PyObject* wrapAddMatBlocks_as_add_mat_blocks(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("A"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_mat_blocks", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_blocks", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_blocks", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_blocks", names[2], "::kaldi::MatrixTransposeType", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddMatBlocks(std::move(arg1), *arg2); break;
  case 3:
    c->AddMatBlocks(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_to_cols(alpha:float, col:CuDoubleVectorBase, beta:float=default)
static PyObject* wrapAddVecToCols_as_add_vec_to_cols(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("col"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_vec_to_cols", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_cols", names[0], "double", a[0]);
  ::kaldi::CuVectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_cols", names[1], "::kaldi::CuVectorBase<double>", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_to_cols", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddVecToCols(std::move(arg1), *arg2); break;
  case 3:
    c->AddVecToCols(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_to_rows(alpha:float, row:CuDoubleVectorBase, beta:float=default)
static PyObject* wrapAddVecToRows_as_add_vec_to_rows(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("alpha"),
      C("row"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:add_vec_to_rows", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_to_rows", names[0], "double", a[0]);
  ::kaldi::CuVectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_to_rows", names[1], "::kaldi::CuVectorBase<double>", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_to_rows", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->AddVecToRows(std::move(arg1), *arg2); break;
  case 3:
    c->AddVecToRows(std::move(arg1), *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_mat(alpha:float, A:CuDoubleMatrixBase, transA:MatrixTransposeType, B:CuDoubleMatrixBase, transB:MatrixTransposeType, beta:float)
static PyObject* wrapAddMatMat_as_add_mat_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[6];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("transA"),
      C("B"),
      C("transB"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOOO:add_mat_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4], &a[5])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::CuMatrixBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat", names[3], "::kaldi::CuMatrixBase<double>", a[3]);
  ::kaldi::MatrixTransposeType arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_mat", names[4], "::kaldi::MatrixTransposeType", a[4]);
  double arg6;
  if (!Clif_PyObjAs(a[5], &arg6)) return ArgError("add_mat_mat", names[5], "double", a[5]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMat(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5), std::move(arg6));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_vec_vec(alpha:float, x:CuDoubleVectorBase, y:CuDoubleVectorBase)
static PyObject* wrapAddVecVec_as_add_vec_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("alpha"),
      C("x"),
      C("y"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:add_vec_vec", names, &a[0], &a[1], &a[2])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_vec_vec", names[0], "double", a[0]);
  ::kaldi::CuVectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_vec_vec", names[1], "::kaldi::CuVectorBase<double>", a[1]);
  ::kaldi::CuVectorBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_vec_vec", names[2], "::kaldi::CuVectorBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddVecVec(std::move(arg1), *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_mat_mat_div_mat(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, C:CuDoubleMatrixBase)
static PyObject* wrapSetMatMatDivMat_as_set_mat_mat_div_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3];
  char* names[] = {
      C("A"),
      C("B"),
      C("C"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOO:set_mat_mat_div_mat", names, &a[0], &a[1], &a[2])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("set_mat_mat_div_mat", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("set_mat_mat_div_mat", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::CuMatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("set_mat_mat_div_mat", names[2], "::kaldi::CuMatrixBase<double>", a[2]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetMatMatDivMat(*arg1, *arg2, *arg3);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// sym_add_mat2(alpha:float, M:CuDoubleMatrixBase, transA:MatrixTransposeType, beta:float)
static PyObject* wrapSymAddMat2_as_sym_add_mat2(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transA"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:sym_add_mat2", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("sym_add_mat2", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("sym_add_mat2", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("sym_add_mat2", names[2], "::kaldi::MatrixTransposeType", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("sym_add_mat2", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SymAddMat2(std::move(arg1), *arg2, std::move(arg3), std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_diag_vec_mat(alpha:float, v:CuDoubleVectorBase, M:CuDoubleMatrixBase, transM:MatrixTransposeType, beta:float=default)
static PyObject* wrapAddDiagVecMat_as_add_diag_vec_mat(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("v"),
      C("M"),
      C("transM"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_diag_vec_mat", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_diag_vec_mat", names[0], "double", a[0]);
  ::kaldi::CuVectorBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_diag_vec_mat", names[1], "::kaldi::CuVectorBase<double>", a[1]);
  ::kaldi::CuMatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_diag_vec_mat", names[2], "::kaldi::CuMatrixBase<double>", a[2]);
  ::kaldi::MatrixTransposeType arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_diag_vec_mat", names[3], "::kaldi::MatrixTransposeType", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_diag_vec_mat", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4)); break;
  case 5:
    c->AddDiagVecMat(std::move(arg1), *arg2, *arg3, std::move(arg4), std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_diag_vec(alpha:float, M:CuDoubleMatrixBase, transM:MatrixTransposeType, v:CuDoubleVectorBase, beta:float=default)
static PyObject* wrapAddMatDiagVec_as_add_mat_diag_vec(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5]{};
  char* names[] = {
      C("alpha"),
      C("M"),
      C("transM"),
      C("v"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO|O:add_mat_diag_vec", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 5; nargs > 4; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_diag_vec", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_diag_vec", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::MatrixTransposeType arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_diag_vec", names[2], "::kaldi::MatrixTransposeType", a[2]);
  ::kaldi::CuVectorBase<double>* arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_diag_vec", names[3], "::kaldi::CuVectorBase<double>", a[3]);
  double arg5;
  if (nargs > 4) {
    if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("add_mat_diag_vec", names[4], "double", a[4]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 4:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4); break;
  case 5:
    c->AddMatDiagVec(std::move(arg1), *arg2, std::move(arg3), *arg4, std::move(arg5)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_mat_mat_elements(alpha:float, A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, beta:float)
static PyObject* wrapAddMatMatElements_as_add_mat_mat_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4];
  char* names[] = {
      C("alpha"),
      C("A"),
      C("B"),
      C("beta"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOO:add_mat_mat_elements", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_mat_mat_elements", names[0], "double", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_mat_mat_elements", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  ::kaldi::CuMatrixBase<double>* arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("add_mat_mat_elements", names[2], "::kaldi::CuMatrixBase<double>", a[2]);
  double arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("add_mat_mat_elements", names[3], "double", a[3]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddMatMatElements(std::move(arg1), *arg2, *arg3, std::move(arg4));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_lower_to_upper()
static PyObject* wrapCopyLowerToUpper_as_copy_lower_to_upper(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyLowerToUpper();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// copy_upper_to_lower()
static PyObject* wrapCopyUpperToLower_as_copy_upper_to_lower(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CopyUpperToLower();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// _getitem(r:int, c:int) -> float
static PyObject* wrap_getitem(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("r"),
      C("c"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:_getitem", names, &a[0], &a[1])) return nullptr;
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("_getitem", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("_getitem", names[1], "int", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->operator()(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// sum() -> float
static PyObject* wrapSum_as_sum(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Sum();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// max() -> float
static PyObject* wrapMax_as_max(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Max();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// min() -> float
static PyObject* wrapMin_as_min(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = c->Min();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// trace(check_square:bool=default) -> float
static PyObject* wrapTrace_as_trace(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1]{};
  char* names[] = {
      C("check_square"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:trace", names, &a[0])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 1; nargs > 0; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  bool arg1;
  if (nargs > 0) {
    if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("trace", names[0], "bool", a[0]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  double ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 0:
    ret0 = c->Trace(); break;
  case 1:
    ret0 = c->Trace(std::move(arg1)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// set_randn()
static PyObject* wrapSetRandn_as_set_randn(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandn();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// set_rand_uniform()
static PyObject* wrapSetRandUniform_as_set_rand_uniform(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->SetRandUniform();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// write(os:ostream, binary:bool)
static PyObject* wrapWrite_as_write(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("os"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:write", names, &a[0], &a[1])) return nullptr;
  ::std::basic_ostream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("write", names[0], "::std::basic_ostream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("write", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Write(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// add_elements(alpha:float, input:list<DoubleMatrixElement>)
static PyObject* wrapAddElements_as_add_elements(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("alpha"),
      C("input"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:add_elements", names, &a[0], &a[1])) return nullptr;
  double arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("add_elements", names[0], "double", a[0]);
  ::std::vector< ::MatrixElement<double> > arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("add_elements", names[1], "::std::vector< ::MatrixElement<double> >", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrixBase<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->AddElements(std::move(arg1), std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

PySequenceMethods AsSequence = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // sq_length
  nullptr,                             // sq_concat
  nullptr,                             // sq_repeat
  nullptr,                             // sq_item
  nullptr,                             // was_sq_slice
  nullptr,                             // sq_ass_item
  nullptr,                             // was_sq_ass_slice
  nullptr,                             // sq_contains
  nullptr,                             // sq_inplace_concat
  nullptr,                             // sq_inplace_repeat
};

PyMappingMethods AsMapping = {
  slot::adapter<Py_ssize_t, slot::as_size, wrapNumRows_as___len__>, // mp_length
  nullptr,                             // mp_subscript
  nullptr,                             // mp_ass_subscript
};

static PyMethodDef Methods[] = {
  {C("copy_cols"), (PyCFunction)wrapCopyCols_as_copy_cols, METH_VARARGS | METH_KEYWORDS, C("copy_cols(src:CuDoubleMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyCols(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray<int>)")},
  {C("add_cols"), (PyCFunction)wrapAddCols_as_add_cols, METH_VARARGS | METH_KEYWORDS, C("add_cols(src:CuDoubleMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddCols(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray<int>)")},
  {C("copy_rows"), (PyCFunction)wrapCopyRows_as_copy_rows, METH_VARARGS | METH_KEYWORDS, C("copy_rows(src:CuDoubleMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyRows(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray<int>)")},
  {C("copy_to_rows"), (PyCFunction)wrapCopyToRows_as_copy_to_rows, METH_VARARGS | METH_KEYWORDS, C("copy_to_rows(dst:CuDoublePtrArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyToRows(::kaldi::CuArray<double *>)")},
  {C("add_rows"), (PyCFunction)wrapAddRows_as_add_rows, METH_VARARGS | METH_KEYWORDS, C("add_rows(alpha:float, src:CuDoubleMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddRows(double, ::kaldi::CuMatrixBase<double>, ::kaldi::CuArray<int>)")},
  {C("mul_rows"), (PyCFunction)wrapMulRows_as_mul_rows, METH_VARARGS | METH_KEYWORDS, C("mul_rows(src:CuDoubleMatrixBase, indexes:CuArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::MulRows(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray<int>)")},
  {C("add_to_rows"), (PyCFunction)wrapAddToRows_as_add_to_rows, METH_VARARGS | METH_KEYWORDS, C("add_to_rows(alpha:float, dst:CuDoublePtrArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddToRows(double, ::kaldi::CuArray<double *>)")},
  {C("sum_column_ranges"), (PyCFunction)wrapSumColumnRanges_as_sum_column_ranges, METH_VARARGS | METH_KEYWORDS, C("sum_column_ranges(src:CuDoubleMatrixBase, indexes:CuIntPairArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SumColumnRanges(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray< ::Int32Pair>)")},
  {C("add_row_ranges"), (PyCFunction)wrapAddRowRanges_as_add_row_ranges, METH_VARARGS | METH_KEYWORDS, C("add_row_ranges(src:CuDoubleMatrixBase, indexes:CuIntPairArray)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddRowRanges(::kaldi::CuMatrixBase<double>, ::kaldi::CuArray< ::Int32Pair>)")},
  {C("add_to_diag"), (PyCFunction)wrapAddToDiag_as_add_to_diag, METH_VARARGS | METH_KEYWORDS, C("add_to_diag(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddToDiag(double)")},
  {C("num_rows"), (PyCFunction)wrapNumRows_as_num_rows, METH_NOARGS, C("num_rows() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<double>::NumRows()")},
  {C("num_cols"), (PyCFunction)wrapNumCols_as_num_cols, METH_NOARGS, C("num_cols() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<double>::NumCols()")},
  {C("stride"), (PyCFunction)wrapStride_as_stride, METH_NOARGS, C("stride() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<double>::Stride()")},
  {C("dim"), (PyCFunction)wrapDim_as_dim, METH_NOARGS, C("dim() -> MatrixDim\n  Calls C++ function\n  ::MatrixDim_ ::kaldi::CuMatrixBase<double>::Dim()")},
  {C("frobenius_norm"), (PyCFunction)wrapFrobeniusNorm_as_frobenius_norm, METH_NOARGS, C("frobenius_norm() -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::FrobeniusNorm()")},
  {C("is_unit"), (PyCFunction)wrapIsUnit_as_is_unit, METH_VARARGS | METH_KEYWORDS, C("is_unit(tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::CuMatrixBase<double>::IsUnit(double)")},
  {C("approx_equal"), (PyCFunction)wrapApproxEqual_as_approx_equal, METH_VARARGS | METH_KEYWORDS, C("approx_equal(other:CuDoubleMatrixBase, tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::CuMatrixBase<double>::ApproxEqual(::kaldi::CuMatrixBase<double>, float)")},
  {C("size_in_bytes"), (PyCFunction)wrapSizeInBytes_as_size_in_bytes, METH_NOARGS, C("size_in_bytes() -> int\n  Calls C++ function\n  int ::kaldi::CuMatrixBase<double>::SizeInBytes()")},
  {C("copy_from_mat"), (PyCFunction)wrapCopyFromMat_as_copy_from_mat, METH_VARARGS | METH_KEYWORDS, C("copy_from_mat(src:DoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyFromMat(::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("copy_from_cu_mat"), (PyCFunction)wrapCopyFromMat_as_copy_from_cu_mat, METH_VARARGS | METH_KEYWORDS, C("copy_from_cu_mat(src:CuDoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyFromMat(::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("copy_to_mat"), (PyCFunction)wrapCopyToMat_as_copy_to_mat, METH_VARARGS | METH_KEYWORDS, C("copy_to_mat(dst:DoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyToMat(::kaldi::MatrixBase<double> *, ::kaldi::MatrixTransposeType)")},
  {C("copy_rows_from_cu_vec"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_cu_vec(v:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyRowsFromVec(::kaldi::CuVectorBase<double>)")},
  {C("copy_rows_from_vec"), (PyCFunction)wrapCopyRowsFromVec_as_copy_rows_from_vec, METH_VARARGS | METH_KEYWORDS, C("copy_rows_from_vec(v:DoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyRowsFromVec(::kaldi::VectorBase<double>)")},
  {C("copy_cols_from_cu_vec"), (PyCFunction)wrapCopyColsFromVec_as_copy_cols_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_cols_from_cu_vec(v:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyColsFromVec(::kaldi::CuVectorBase<double>)")},
  {C("copy_col_from_cu_vec"), (PyCFunction)wrapCopyColFromVec_as_copy_col_from_cu_vec, METH_VARARGS | METH_KEYWORDS, C("copy_col_from_cu_vec(v:CuDoubleVectorBase, col:int)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyColFromVec(::kaldi::CuVectorBase<double>, int)")},
  {C("sigmoid"), (PyCFunction)wrapSigmoid_as_sigmoid, METH_VARARGS | METH_KEYWORDS, C("sigmoid(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Sigmoid(::kaldi::CuMatrixBase<double>)")},
  {C("heaviside"), (PyCFunction)wrapHeaviside_as_heaviside, METH_VARARGS | METH_KEYWORDS, C("heaviside(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Heaviside(::kaldi::CuMatrixBase<double>)")},
  {C("soft_hinge"), (PyCFunction)wrapSoftHinge_as_soft_hinge, METH_VARARGS | METH_KEYWORDS, C("soft_hinge(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SoftHinge(::kaldi::CuMatrixBase<double>)")},
  {C("group_pnorm"), (PyCFunction)wrapGroupPnorm_as_group_pnorm, METH_VARARGS | METH_KEYWORDS, C("group_pnorm(src:CuDoubleMatrixBase, pow:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::GroupPnorm(::kaldi::CuMatrixBase<double>, double)")},
  {C("diff_group_pnorm"), (PyCFunction)wrapDiffGroupPnorm_as_diff_group_pnorm, METH_VARARGS | METH_KEYWORDS, C("diff_group_pnorm(in_value:CuDoubleMatrixBase, out_value:CuDoubleMatrixBase, out_deriv:CuDoubleMatrixBase, power:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffGroupPnorm(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, double)")},
  {C("group_max"), (PyCFunction)wrapGroupMax_as_group_max, METH_VARARGS | METH_KEYWORDS, C("group_max(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::GroupMax(::kaldi::CuMatrixBase<double>)")},
  {C("group_max_deriv"), (PyCFunction)wrapGroupMaxDeriv_as_group_max_deriv, METH_VARARGS | METH_KEYWORDS, C("group_max_deriv(input:CuDoubleMatrixBase, output:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::GroupMaxDeriv(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("parametric_relu"), (PyCFunction)wrapParametricRelu_as_parametric_relu, METH_VARARGS | METH_KEYWORDS, C("parametric_relu(src:CuDoubleMatrixBase, alpha:CuDoubleVectorBase, beta:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ParametricRelu(::kaldi::CuMatrixBase<double>, ::kaldi::CuVectorBase<double>, ::kaldi::CuVectorBase<double>)")},
  {C("diff_parametric_relu"), (PyCFunction)wrapDiffParametricRelu_as_diff_parametric_relu, METH_VARARGS | METH_KEYWORDS, C("diff_parametric_relu(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase, alpha:CuDoubleVectorBase, beta:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffParametricRelu(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, ::kaldi::CuVectorBase<double>, ::kaldi::CuVectorBase<double>)")},
  {C("tanh"), (PyCFunction)wrapTanh_as_tanh, METH_VARARGS | METH_KEYWORDS, C("tanh(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Tanh(::kaldi::CuMatrixBase<double>)")},
  {C("diff_sigmoid"), (PyCFunction)wrapDiffSigmoid_as_diff_sigmoid, METH_VARARGS | METH_KEYWORDS, C("diff_sigmoid(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffSigmoid(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("diff_tanh"), (PyCFunction)wrapDiffTanh_as_diff_tanh, METH_VARARGS | METH_KEYWORDS, C("diff_tanh(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffTanh(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("diff_softmax_per_row"), (PyCFunction)wrapDiffSoftmaxPerRow_as_diff_softmax_per_row, METH_VARARGS | METH_KEYWORDS, C("diff_softmax_per_row(value:CuDoubleMatrixBase, diff:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffSoftmaxPerRow(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("diff_log_softmax_per_row"), (PyCFunction)wrapDiffLogSoftmaxPerRow_as_diff_log_softmax_per_row, METH_VARARGS | METH_KEYWORDS, C("diff_log_softmax_per_row(out_value:CuDoubleMatrixBase, out_deriv:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffLogSoftmaxPerRow(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("diff_xent"), (PyCFunction)wrapDiffXent_as_diff_xent, METH_VARARGS | METH_KEYWORDS, C("diff_xent(tgt:CuArray) -> CuDoubleVector\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DiffXent(::kaldi::CuArray<int>, ::kaldi::CuVector<double>*)")},
  {C("cholesky"), (PyCFunction)wrapCholesky_as_cholesky, METH_VARARGS | METH_KEYWORDS, C("cholesky(inv_cholesky:CuDoubleMatrixBase=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Cholesky(::kaldi::CuMatrixBase<double> *)")},
  {C("sym_invert_pos_def"), (PyCFunction)wrapSymInvertPosDef_as_sym_invert_pos_def, METH_NOARGS, C("sym_invert_pos_def()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SymInvertPosDef()")},
  {C("apply_pow"), (PyCFunction)wrapApplyPow_as_apply_pow, METH_VARARGS | METH_KEYWORDS, C("apply_pow(power:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyPow(double)")},
  {C("apply_pow_abs"), (PyCFunction)wrapApplyPowAbs_as_apply_pow_abs, METH_VARARGS | METH_KEYWORDS, C("apply_pow_abs(power:float, include_sign:bool=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyPowAbs(double, bool)")},
  {C("apply_heaviside"), (PyCFunction)wrapApplyHeaviside_as_apply_heaviside, METH_NOARGS, C("apply_heaviside()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyHeaviside()")},
  {C("apply_floor"), (PyCFunction)wrapApplyFloor_as_apply_floor, METH_VARARGS | METH_KEYWORDS, C("apply_floor(floor_val:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyFloor(double)")},
  {C("apply_ceiling"), (PyCFunction)wrapApplyCeiling_as_apply_ceiling, METH_VARARGS | METH_KEYWORDS, C("apply_ceiling(ceiling_val:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyCeiling(double)")},
  {C("apply_exp"), (PyCFunction)wrapApplyExp_as_apply_exp, METH_NOARGS, C("apply_exp()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyExp()")},
  {C("apply_soft_max_per_row"), (PyCFunction)wrapApplySoftMaxPerRow_as_apply_soft_max_per_row, METH_VARARGS | METH_KEYWORDS, C("apply_soft_max_per_row(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplySoftMaxPerRow(::kaldi::CuMatrixBase<double>)")},
  {C("apply_log_soft_max_per_row"), (PyCFunction)wrapApplyLogSoftMaxPerRow_as_apply_log_soft_max_per_row, METH_VARARGS | METH_KEYWORDS, C("apply_log_soft_max_per_row(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyLogSoftMaxPerRow(::kaldi::CuMatrixBase<double>)")},
  {C("find_row_max_id"), (PyCFunction)wrapFindRowMaxId_as_find_row_max_id, METH_NOARGS, C("find_row_max_id() -> CuArray\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::FindRowMaxId(::kaldi::CuArray<int>*)")},
  {C("set_zero"), (PyCFunction)wrapSetZero_as_set_zero, METH_NOARGS, C("set_zero()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SetZero()")},
  {C("set"), (PyCFunction)wrapSet_as_set, METH_VARARGS | METH_KEYWORDS, C("set(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Set(double)")},
  {C("add"), (PyCFunction)wrapAdd_as_add, METH_VARARGS | METH_KEYWORDS, C("add(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Add(double)")},
  {C("set_zero_above_diag"), (PyCFunction)wrapSetZeroAboveDiag_as_set_zero_above_diag, METH_NOARGS, C("set_zero_above_diag()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SetZeroAboveDiag()")},
  {C("scale"), (PyCFunction)wrapScale_as_scale, METH_VARARGS | METH_KEYWORDS, C("scale(value:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Scale(double)")},
  {C("apply_log"), (PyCFunction)wrapApplyLog_as_apply_log, METH_NOARGS, C("apply_log()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::ApplyLog()")},
  {C("mul_elements"), (PyCFunction)wrapMulElements_as_mul_elements, METH_VARARGS | METH_KEYWORDS, C("mul_elements(A:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::MulElements(::kaldi::CuMatrixBase<double>)")},
  {C("div_elements"), (PyCFunction)wrapDivElements_as_div_elements, METH_VARARGS | METH_KEYWORDS, C("div_elements(A:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DivElements(::kaldi::CuMatrixBase<double>)")},
  {C("max_elementwise"), (PyCFunction)wrapMax_as_max_elementwise, METH_VARARGS | METH_KEYWORDS, C("max_elementwise(A:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Max(::kaldi::CuMatrixBase<double>)")},
  {C("min_elementwise"), (PyCFunction)wrapMin_as_min_elementwise, METH_VARARGS | METH_KEYWORDS, C("min_elementwise(A:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Min(::kaldi::CuMatrixBase<double>)")},
  {C("mul_cols_vec"), (PyCFunction)wrapMulColsVec_as_mul_cols_vec, METH_VARARGS | METH_KEYWORDS, C("mul_cols_vec(scale:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::MulColsVec(::kaldi::CuVectorBase<double>)")},
  {C("mul_rows_vec"), (PyCFunction)wrapMulRowsVec_as_mul_rows_vec, METH_VARARGS | METH_KEYWORDS, C("mul_rows_vec(scale:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::MulRowsVec(::kaldi::CuVectorBase<double>)")},
  {C("mul_rows_group_mat"), (PyCFunction)wrapMulRowsGroupMat_as_mul_rows_group_mat, METH_VARARGS | METH_KEYWORDS, C("mul_rows_group_mat(src:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::MulRowsGroupMat(::kaldi::CuMatrixBase<double>)")},
  {C("div_rows_vec"), (PyCFunction)wrapDivRowsVec_as_div_rows_vec, METH_VARARGS | METH_KEYWORDS, C("div_rows_vec(div:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::DivRowsVec(::kaldi::CuVectorBase<double>)")},
  {C("invert_elements"), (PyCFunction)wrapInvertElements_as_invert_elements, METH_NOARGS, C("invert_elements()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::InvertElements()")},
  {C("add_mat"), (PyCFunction)wrapAddMat_as_add_mat, METH_VARARGS | METH_KEYWORDS, C("add_mat(alpha:float, A:CuDoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddMat(double, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("add_mat_blocks"), (PyCFunction)wrapAddMatBlocks_as_add_mat_blocks, METH_VARARGS | METH_KEYWORDS, C("add_mat_blocks(alpha:float, A:CuDoubleMatrixBase, trans:MatrixTransposeType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddMatBlocks(double, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("add_vec_to_cols"), (PyCFunction)wrapAddVecToCols_as_add_vec_to_cols, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_cols(alpha:float, col:CuDoubleVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddVecToCols(double, ::kaldi::CuVectorBase<double>, double)")},
  {C("add_vec_to_rows"), (PyCFunction)wrapAddVecToRows_as_add_vec_to_rows, METH_VARARGS | METH_KEYWORDS, C("add_vec_to_rows(alpha:float, row:CuDoubleVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddVecToRows(double, ::kaldi::CuVectorBase<double>, double)")},
  {C("add_mat_mat"), (PyCFunction)wrapAddMatMat_as_add_mat_mat, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat(alpha:float, A:CuDoubleMatrixBase, transA:MatrixTransposeType, B:CuDoubleMatrixBase, transB:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddMatMat(double, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("add_vec_vec"), (PyCFunction)wrapAddVecVec_as_add_vec_vec, METH_VARARGS | METH_KEYWORDS, C("add_vec_vec(alpha:float, x:CuDoubleVectorBase, y:CuDoubleVectorBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddVecVec(double, ::kaldi::CuVectorBase<double>, ::kaldi::CuVectorBase<double>)")},
  {C("set_mat_mat_div_mat"), (PyCFunction)wrapSetMatMatDivMat_as_set_mat_mat_div_mat, METH_VARARGS | METH_KEYWORDS, C("set_mat_mat_div_mat(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, C:CuDoubleMatrixBase)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SetMatMatDivMat(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("sym_add_mat2"), (PyCFunction)wrapSymAddMat2_as_sym_add_mat2, METH_VARARGS | METH_KEYWORDS, C("sym_add_mat2(alpha:float, M:CuDoubleMatrixBase, transA:MatrixTransposeType, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SymAddMat2(double, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("add_diag_vec_mat"), (PyCFunction)wrapAddDiagVecMat_as_add_diag_vec_mat, METH_VARARGS | METH_KEYWORDS, C("add_diag_vec_mat(alpha:float, v:CuDoubleVectorBase, M:CuDoubleMatrixBase, transM:MatrixTransposeType, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddDiagVecMat(double, ::kaldi::CuVectorBase<double>, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType, double)")},
  {C("add_mat_diag_vec"), (PyCFunction)wrapAddMatDiagVec_as_add_mat_diag_vec, METH_VARARGS | METH_KEYWORDS, C("add_mat_diag_vec(alpha:float, M:CuDoubleMatrixBase, transM:MatrixTransposeType, v:CuDoubleVectorBase, beta:float=default)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddMatDiagVec(double, ::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType, ::kaldi::CuVectorBase<double>, double)")},
  {C("add_mat_mat_elements"), (PyCFunction)wrapAddMatMatElements_as_add_mat_mat_elements, METH_VARARGS | METH_KEYWORDS, C("add_mat_mat_elements(alpha:float, A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, beta:float)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddMatMatElements(double, ::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, double)")},
  {C("copy_lower_to_upper"), (PyCFunction)wrapCopyLowerToUpper_as_copy_lower_to_upper, METH_NOARGS, C("copy_lower_to_upper()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyLowerToUpper()")},
  {C("copy_upper_to_lower"), (PyCFunction)wrapCopyUpperToLower_as_copy_upper_to_lower, METH_NOARGS, C("copy_upper_to_lower()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::CopyUpperToLower()")},
  {C("_getitem"), (PyCFunction)wrap_getitem, METH_VARARGS | METH_KEYWORDS, C("_getitem(r:int, c:int) -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::operator()(int, int)")},
  {C("sum"), (PyCFunction)wrapSum_as_sum, METH_NOARGS, C("sum() -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::Sum()")},
  {C("max"), (PyCFunction)wrapMax_as_max, METH_NOARGS, C("max() -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::Max()")},
  {C("min"), (PyCFunction)wrapMin_as_min, METH_NOARGS, C("min() -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::Min()")},
  {C("trace"), (PyCFunction)wrapTrace_as_trace, METH_VARARGS | METH_KEYWORDS, C("trace(check_square:bool=default) -> float\n  Calls C++ function\n  double ::kaldi::CuMatrixBase<double>::Trace(bool)")},
  {C("set_randn"), (PyCFunction)wrapSetRandn_as_set_randn, METH_NOARGS, C("set_randn()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SetRandn()")},
  {C("set_rand_uniform"), (PyCFunction)wrapSetRandUniform_as_set_rand_uniform, METH_NOARGS, C("set_rand_uniform()\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::SetRandUniform()")},
  {C("write"), (PyCFunction)wrapWrite_as_write, METH_VARARGS | METH_KEYWORDS, C("write(os:ostream, binary:bool)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::Write(::std::basic_ostream<char, ::std::char_traits<char> >, bool)")},
  {C("add_elements"), (PyCFunction)wrapAddElements_as_add_elements, METH_VARARGS | METH_KEYWORDS, C("add_elements(alpha:float, input:list<DoubleMatrixElement>)\n  Calls C++ function\n  void ::kaldi::CuMatrixBase<double>::AddElements(double, ::std::vector< ::MatrixElement<double> >)")},
  {}
};

// CuDoubleMatrixBase __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuDoubleMatrixBase __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuDoubleMatrixBase",     // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  &AsSequence,                         // tp_as_sequence
  &AsMapping,                          // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuMatrixBase<double>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  Clif_PyType_Inconstructible,         // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};


static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuMatrixBase<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuMatrixBase_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuMatrixBase<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuMatrixBase<double>* c = static_cast<::kaldi::CuMatrixBase<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuMatrixBase<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuDoubleMatrixBase

namespace pyCuDoubleMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuMatrix<double>> cpp;
};
static ::kaldi::CuMatrix<double>* ThisPtr(PyObject*);

// @classmethod from_size(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> CuDoubleMatrix
static PyObject* wrapCuMatrix_as_from_size(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:from_size", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_size", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_size", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("from_size", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("from_size", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("from_size", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(std::move(arg1), std::move(arg2)); break;
  case 3:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_other(other:CuDoubleMatrixBase, trans:MatrixTransposeType=default) -> CuDoubleMatrix
static PyObject* wrapCuMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_other", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_other", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// @classmethod from_matrix(other:DoubleMatrixBase, trans:MatrixTransposeType=default) -> CuDoubleMatrix
static PyObject* wrapCuMatrix_as_from_matrix(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[2]{};
  char* names[] = {
      C("other"),
      C("trans"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O|O:from_matrix", names, &a[0], &a[1])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 2; nargs > 1; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::MatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_matrix", names[0], "::kaldi::MatrixBase<double>", a[0]);
  ::kaldi::MatrixTransposeType arg2;
  if (nargs > 1) {
    if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("from_matrix", names[1], "::kaldi::MatrixTransposeType", a[1]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 1:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(*arg1); break;
  case 2:
    ret0 = ::gtl::MakeUnique<::kaldi::CuMatrix<double>>(*arg1, std::move(arg2)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// transpose()
static PyObject* wrapTranspose_as_transpose(PyObject* self) {
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Transpose();
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// resize(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)
static PyObject* wrapResize_as_resize(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[4]{};
  char* names[] = {
      C("rows"),
      C("cols"),
      C("resize_type"),
      C("stride_type"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|OO:resize", names, &a[0], &a[1], &a[2], &a[3])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 4; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  int arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("resize", names[0], "int", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("resize", names[1], "int", a[1]);
  ::kaldi::MatrixResizeType arg3;
  if (nargs > 2) {
    if (!a[2]) return DefaultArgMissedError("resize", names[2]);
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("resize", names[2], "::kaldi::MatrixResizeType", a[2]);
  }
  ::kaldi::MatrixStrideType arg4;
  if (nargs > 3) {
    if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("resize", names[3], "::kaldi::MatrixStrideType", a[3]);
  }
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    c->Resize(std::move(arg1), std::move(arg2)); break;
  case 3:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3)); break;
  case 4:
    c->Resize(std::move(arg1), std::move(arg2), std::move(arg3), std::move(arg4)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap_with_matrix(mat:DoubleMatrix)
static PyObject* wrapSwap_as_swap_with_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap_with_matrix", names, &a[0])) return nullptr;
  ::kaldi::Matrix<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap_with_matrix", names[0], "::kaldi::Matrix<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// swap(mat:CuDoubleMatrix)
static PyObject* wrapSwap_as_swap(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("mat"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:swap", names, &a[0])) return nullptr;
  ::kaldi::CuMatrix<double> * arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("swap", names[0], "::kaldi::CuMatrix<double> *", a[0]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Swap(arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// read(is:istream, binary:bool)
static PyObject* wrapRead_as_read(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("is"),
      C("binary"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:read", names, &a[0], &a[1])) return nullptr;
  ::std::basic_istream<char, ::std::char_traits<char> >* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("read", names[0], "::std::basic_istream<char, ::std::char_traits<char> >", a[0]);
  bool arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("read", names[1], "bool", a[1]);
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->Read(*arg1, std::move(arg2));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// comp_objf_and_deriv(elements:list<DoubleMatrixElement>, A:CuDoubleMatrix) -> (tot_objf:float, tot_weight:float)
static PyObject* wrapCompObjfAndDeriv_as_comp_objf_and_deriv(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("elements"),
      C("A"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:comp_objf_and_deriv", names, &a[0], &a[1])) return nullptr;
  ::std::vector< ::MatrixElement<double> > arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("comp_objf_and_deriv", names[0], "::std::vector< ::MatrixElement<double> >", a[0]);
  ::kaldi::CuMatrix<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("comp_objf_and_deriv", names[1], "::kaldi::CuMatrix<double>", a[1]);
  double ret0{};
  double ret1{};
  // Call actual C++ method.
  ::kaldi::CuMatrix<double>* c = ThisPtr(self);
  if (!c) return nullptr;
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    c->CompObjfAndDeriv(std::move(arg1), *arg2, &ret0, &ret1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  // Convert return values to Python.
  PyObject* p, * result_tuple = PyTuple_New(2);
  if (result_tuple == nullptr) return nullptr;
  if ((p=Clif_PyObjFrom(std::move(ret0), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 0, p);
  if ((p=Clif_PyObjFrom(std::move(ret1), {})) == nullptr) {
    Py_DECREF(result_tuple);
    return nullptr;
  }
  PyTuple_SET_ITEM(result_tuple, 1, p);
  return result_tuple;
}

// Implicit cast this as ::kaldi::CuMatrixBase<double>*
static PyObject* as_kaldi_CuMatrixBase_double(PyObject* self) {
  ::kaldi::CuMatrixBase<double>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::CuMatrixBase<double>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("from_size"), (PyCFunction)wrapCuMatrix_as_from_size, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_size(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default) -> CuDoubleMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<double>> ::kaldi::CuMatrix<double>::CuMatrix(int, int, ::kaldi::MatrixResizeType, ::kaldi::MatrixStrideType)")},
  {C("from_other"), (PyCFunction)wrapCuMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:CuDoubleMatrixBase, trans:MatrixTransposeType=default) -> CuDoubleMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<double>> ::kaldi::CuMatrix<double>::CuMatrix(::kaldi::CuMatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("from_matrix"), (PyCFunction)wrapCuMatrix_as_from_matrix, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_matrix(other:DoubleMatrixBase, trans:MatrixTransposeType=default) -> CuDoubleMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuMatrix<double>> ::kaldi::CuMatrix<double>::CuMatrix(::kaldi::MatrixBase<double>, ::kaldi::MatrixTransposeType)")},
  {C("transpose"), (PyCFunction)wrapTranspose_as_transpose, METH_NOARGS, C("transpose()\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::Transpose()")},
  {C("resize"), (PyCFunction)wrapResize_as_resize, METH_VARARGS | METH_KEYWORDS, C("resize(rows:int, cols:int, resize_type:MatrixResizeType=default, stride_type:MatrixStrideType=default)\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::Resize(int, int, ::kaldi::MatrixResizeType, ::kaldi::MatrixStrideType)")},
  {C("swap_with_matrix"), (PyCFunction)wrapSwap_as_swap_with_matrix, METH_VARARGS | METH_KEYWORDS, C("swap_with_matrix(mat:DoubleMatrix)\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::Swap(::kaldi::Matrix<double> *)")},
  {C("swap"), (PyCFunction)wrapSwap_as_swap, METH_VARARGS | METH_KEYWORDS, C("swap(mat:CuDoubleMatrix)\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::Swap(::kaldi::CuMatrix<double> *)")},
  {C("read"), (PyCFunction)wrapRead_as_read, METH_VARARGS | METH_KEYWORDS, C("read(is:istream, binary:bool)\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::Read(::std::basic_istream<char, ::std::char_traits<char> >, bool)")},
  {C("comp_objf_and_deriv"), (PyCFunction)wrapCompObjfAndDeriv_as_comp_objf_and_deriv, METH_VARARGS | METH_KEYWORDS, C("comp_objf_and_deriv(elements:list<DoubleMatrixElement>, A:CuDoubleMatrix) -> (tot_objf:float, tot_weight:float)\n  Calls C++ function\n  void ::kaldi::CuMatrix<double>::CompObjfAndDeriv(::std::vector< ::MatrixElement<double> >, ::kaldi::CuMatrix<double>, double*, double*)")},
  {C("as_kaldi_CuMatrixBase_double"), (PyCFunction)as_kaldi_CuMatrixBase_double, METH_NOARGS, C("Upcast to ::kaldi::CuMatrixBase<double>*")},
  {}
};

// CuDoubleMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CuDoubleMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuDoubleMatrix __del__
static void _dtor(PyObject* self) {
  Py_BEGIN_ALLOW_THREADS
  reinterpret_cast<wrapper*>(self)->cpp.Destruct();
  Py_END_ALLOW_THREADS
  Py_TYPE(self)->tp_free(self);
}
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuDoubleMatrix",         // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  _dtor,                               // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuMatrix<double>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  if ((args && PyTuple_GET_SIZE(args) != 0) || (kw && PyDict_Size(kw) != 0)) {
    PyErr_SetString(PyExc_TypeError, "CuDoubleMatrix takes no arguments");
    return -1;
  }
  reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::CuMatrix<double>>();
  return 0;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuMatrix<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuMatrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuMatrix<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuMatrix<double>* c = static_cast<::kaldi::CuMatrix<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuMatrix<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuDoubleMatrix

namespace pyCuDoubleSubMatrix {

struct wrapper {
  PyObject_HEAD
  ::clif::Instance<::kaldi::CuSubMatrix<double>> cpp;
};
static ::kaldi::CuSubMatrix<double>* ThisPtr(PyObject*);

// __init__(mat:CuDoubleMatrixBase, row_offset:int, num_rows:int, col_offset:int, num_cols:int)
static PyObject* wrapCuSubMatrix_double_as___init__(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[5];
  char* names[] = {
      C("mat"),
      C("row_offset"),
      C("num_rows"),
      C("col_offset"),
      C("num_cols"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OOOOO:__init__", names, &a[0], &a[1], &a[2], &a[3], &a[4])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("__init__", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  int arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("__init__", names[1], "int", a[1]);
  int arg3;
  if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("__init__", names[2], "int", a[2]);
  int arg4;
  if (!Clif_PyObjAs(a[3], &arg4)) return ArgError("__init__", names[3], "int", a[3]);
  int arg5;
  if (!Clif_PyObjAs(a[4], &arg5)) return ArgError("__init__", names[4], "int", a[4]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    reinterpret_cast<wrapper*>(self)->cpp = ::clif::MakeShared<::kaldi::CuSubMatrix<double>>(*arg1, std::move(arg2), std::move(arg3), std::move(arg4), std::move(arg5));
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// @classmethod from_other(other:CuDoubleSubMatrix) -> CuDoubleSubMatrix
static PyObject* wrapCuSubMatrix_as_from_other(PyObject* cls, PyObject* args, PyObject* kw) {
  PyObject* a[1];
  char* names[] = {
      C("other"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "O:from_other", names, &a[0])) return nullptr;
  ::kaldi::CuSubMatrix<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("from_other", names[0], "::kaldi::CuSubMatrix<double>", a[0]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  std::unique_ptr<::kaldi::CuSubMatrix<double>> ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::gtl::MakeUnique<::kaldi::CuSubMatrix<double>>(*arg1);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// Implicit cast this as ::kaldi::CuMatrixBase<double>*
static PyObject* as_kaldi_CuMatrixBase_double(PyObject* self) {
  ::kaldi::CuMatrixBase<double>* p = ::clif::python::Get(reinterpret_cast<wrapper*>(self)->cpp);
  if (p == nullptr) return nullptr;
  return PyCapsule_New(p, C("::kaldi::CuMatrixBase<double>"), nullptr);
}

static PyMethodDef Methods[] = {
  {C("__init__"), (PyCFunction)wrapCuSubMatrix_double_as___init__, METH_VARARGS | METH_KEYWORDS, C("__init__(mat:CuDoubleMatrixBase, row_offset:int, num_rows:int, col_offset:int, num_cols:int)\n  Calls C++ function\n  void ::kaldi::CuSubMatrix<double>::CuSubMatrix(::kaldi::CuMatrixBase<double>, int, int, int, int)")},
  {C("from_other"), (PyCFunction)wrapCuSubMatrix_as_from_other, METH_VARARGS | METH_KEYWORDS | METH_CLASS, C("from_other(other:CuDoubleSubMatrix) -> CuDoubleSubMatrix\n  Calls C++ function\n  std::unique_ptr<::kaldi::CuSubMatrix<double>> ::kaldi::CuSubMatrix<double>::CuSubMatrix(::kaldi::CuSubMatrix<double>)")},
  {C("as_kaldi_CuMatrixBase_double"), (PyCFunction)as_kaldi_CuMatrixBase_double, METH_NOARGS, C("Upcast to ::kaldi::CuMatrixBase<double>*")},
  {}
};

// CuDoubleSubMatrix __init__
static int _ctor(PyObject* self, PyObject* args, PyObject* kw);

// CuDoubleSubMatrix __new__
static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems);

// CuDoubleSubMatrix __del__
static void _del(void* self) {
  delete reinterpret_cast<wrapper*>(self);
}

PyTypeObject wrapper_Type = {
  PyVarObject_HEAD_INIT(&PyType_Type, 0)
  "_cu_matrix.CuDoubleSubMatrix",      // tp_name
  sizeof(wrapper),                     // tp_basicsize
  0,                                   // tp_itemsize
  nullptr,                             // tp_dealloc
  nullptr,                             // tp_print
  nullptr,                             // tp_getattr
  nullptr,                             // tp_setattr
  nullptr,                             // tp_compare
  nullptr,                             // tp_repr
  nullptr,                             // tp_as_number
  nullptr,                             // tp_as_sequence
  nullptr,                             // tp_as_mapping
  nullptr,                             // tp_hash
  nullptr,                             // tp_call
  nullptr,                             // tp_str
  nullptr,                             // tp_getattro
  nullptr,                             // tp_setattro
  nullptr,                             // tp_as_buffer
  Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, // tp_flags
  "CLIF wrapper for ::kaldi::CuSubMatrix<double>", // tp_doc
  nullptr,                             // tp_traverse
  nullptr,                             // tp_clear
  nullptr,                             // tp_richcompare
  0,                                   // tp_weaklistoffset
  nullptr,                             // tp_iter
  nullptr,                             // tp_iternext
  Methods,                             // tp_methods
  nullptr,                             // tp_members
  nullptr,                             // tp_getset
  nullptr,                             // tp_base
  nullptr,                             // tp_dict
  nullptr,                             // tp_descr_get
  nullptr,                             // tp_descr_set
  0,                                   // tp_dictoffset
  _ctor,                               // tp_init
  _new,                                // tp_alloc
  PyType_GenericNew,                   // tp_new
  _del,                                // tp_free
  nullptr,                             // tp_is_gc
  nullptr,                             // tp_bases
  nullptr,                             // tp_mro
  nullptr,                             // tp_cache
  nullptr,                             // tp_subclasses
  nullptr,                             // tp_weaklist
  nullptr,                             // tp_del
  0,                                   // tp_version_tag
};

static int _ctor(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* init = wrapCuSubMatrix_double_as___init__(self, args, kw);
  Py_XDECREF(init);
  return init? 0: -1;
}

static PyObject* _new(PyTypeObject* type, Py_ssize_t nitems) {
  assert(nitems == 0);
  PyObject* self = reinterpret_cast<PyObject*>(new wrapper);
  return PyObject_Init(self, &wrapper_Type);
}

static ::kaldi::CuSubMatrix<double>* ThisPtr(PyObject* py) {
  if (Py_TYPE(py) == &wrapper_Type) {
    return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
  }
  PyObject* base = PyObject_CallMethod(py, C("as_kaldi_CuSubMatrix_double"), nullptr);
  if (base) {
    if (PyCapsule_CheckExact(base)) {
      void* p = PyCapsule_GetPointer(base, C("::kaldi::CuSubMatrix<double>"));
      if (!PyErr_Occurred()) {
        ::kaldi::CuSubMatrix<double>* c = static_cast<::kaldi::CuSubMatrix<double>*>(p);
        Py_DECREF(base);
        return c;
      }
    }
    Py_DECREF(base);
  }
  if (PyObject_IsInstance(py, reinterpret_cast<PyObject*>(&wrapper_Type))) {
    if (!base) {
      PyErr_Clear();
      return ::clif::python::Get(reinterpret_cast<wrapper*>(py)->cpp);
    }
    PyErr_Format(PyExc_ValueError, "can't convert %s %s to ::kaldi::CuSubMatrix<double>*", ClassName(py), ClassType(py));
  } else {
    PyErr_Format(PyExc_TypeError, "expecting %s instance, got %s %s", wrapper_Type.tp_name, ClassName(py), ClassType(py));
  }
  return nullptr;
}
}  // namespace pyCuDoubleSubMatrix

// approx_equal_cu_double_matrix(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, tol:float=default) -> bool
static PyObject* wrapApproxEqual_as_approx_equal_cu_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:approx_equal_cu_double_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("approx_equal_cu_double_matrix", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("approx_equal_cu_double_matrix", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  double arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("approx_equal_cu_double_matrix", names[2], "double", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2); break;
  case 3:
    ret0 = ::kaldi::ApproxEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// assert_equal_cu_double_matrix(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, tol:float=default)
static PyObject* wrapAssertEqual_as_assert_equal_cu_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[3]{};
  char* names[] = {
      C("A"),
      C("B"),
      C("tol"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO|O:assert_equal_cu_double_matrix", names, &a[0], &a[1], &a[2])) return nullptr;
  int nargs;  // Find how many args actually passed in.
  for (nargs = 3; nargs > 2; --nargs) {
    if (a[nargs-1] != nullptr) break;
  }
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("assert_equal_cu_double_matrix", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("assert_equal_cu_double_matrix", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  float arg3;
  if (nargs > 2) {
    if (!Clif_PyObjAs(a[2], &arg3)) return ArgError("assert_equal_cu_double_matrix", names[2], "float", a[2]);
  }
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
  switch (nargs) {
  case 2:
    ::kaldi::AssertEqual(*arg1, *arg2); break;
  case 3:
    ::kaldi::AssertEqual(*arg1, *arg2, std::move(arg3)); break;
  }
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  Py_RETURN_NONE;
}

// same_dim_cu_double_matrix(M:CuDoubleMatrixBase, N:CuDoubleMatrixBase) -> bool
static PyObject* wrapSameDim_as_same_dim_cu_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:same_dim_cu_double_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("same_dim_cu_double_matrix", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("same_dim_cu_double_matrix", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDim(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}

// same_dim_and_stride_cu_double_matrix(M:CuDoubleMatrixBase, N:CuDoubleMatrixBase) -> bool
static PyObject* wrapSameDimAndStride_as_same_dim_and_stride_cu_double_matrix(PyObject* self, PyObject* args, PyObject* kw) {
  PyObject* a[2];
  char* names[] = {
      C("M"),
      C("N"),
      nullptr
  };
  if (!PyArg_ParseTupleAndKeywords(args, kw, "OO:same_dim_and_stride_cu_double_matrix", names, &a[0], &a[1])) return nullptr;
  ::kaldi::CuMatrixBase<double>* arg1;
  if (!Clif_PyObjAs(a[0], &arg1)) return ArgError("same_dim_and_stride_cu_double_matrix", names[0], "::kaldi::CuMatrixBase<double>", a[0]);
  ::kaldi::CuMatrixBase<double>* arg2;
  if (!Clif_PyObjAs(a[1], &arg2)) return ArgError("same_dim_and_stride_cu_double_matrix", names[1], "::kaldi::CuMatrixBase<double>", a[1]);
  // Call actual C++ method.
  Py_INCREF(args);
  Py_XINCREF(kw);
  PyThreadState* _save;
  Py_UNBLOCK_THREADS
  bool ret0;
  PyObject* err_type = nullptr;
  string err_msg{"C++ exception"};
  try {
    ret0 = ::kaldi::SameDimAndStride(*arg1, *arg2);
  } catch(const std::exception& e) {
    err_type = PyExc_RuntimeError;
    err_msg += string(": ") + e.what();
  } catch (...) {
    err_type = PyExc_RuntimeError;
  }
  Py_BLOCK_THREADS
  Py_DECREF(args);
  Py_XDECREF(kw);
  if (err_type) {
    PyErr_SetString(err_type, err_msg.c_str());
    return nullptr;
  }
  return Clif_PyObjFrom(std::move(ret0), {});
}


// Initialize module

static PyMethodDef Methods[] = {
  {C("approx_equal_cu_matrix"), (PyCFunction)wrapApproxEqual_as_approx_equal_cu_matrix, METH_VARARGS | METH_KEYWORDS, C("approx_equal_cu_matrix(A:CuMatrixBase, B:CuMatrixBase, tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::ApproxEqual(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, float)")},
  {C("assert_equal_cu_matrix"), (PyCFunction)wrapAssertEqual_as_assert_equal_cu_matrix, METH_VARARGS | METH_KEYWORDS, C("assert_equal_cu_matrix(A:CuMatrixBase, B:CuMatrixBase, tol:float=default)\n  Calls C++ function\n  void ::kaldi::AssertEqual(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>, float)")},
  {C("same_dim_cu_matrix"), (PyCFunction)wrapSameDim_as_same_dim_cu_matrix, METH_VARARGS | METH_KEYWORDS, C("same_dim_cu_matrix(M:CuMatrixBase, N:CuMatrixBase) -> bool\n  Calls C++ function\n  bool ::kaldi::SameDim(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("same_dim_and_stride_cu_matrix"), (PyCFunction)wrapSameDimAndStride_as_same_dim_and_stride_cu_matrix, METH_VARARGS | METH_KEYWORDS, C("same_dim_and_stride_cu_matrix(M:CuMatrixBase, N:CuMatrixBase) -> bool\n  Calls C++ function\n  bool ::kaldi::SameDimAndStride(::kaldi::CuMatrixBase<float>, ::kaldi::CuMatrixBase<float>)")},
  {C("approx_equal_cu_double_matrix"), (PyCFunction)wrapApproxEqual_as_approx_equal_cu_double_matrix, METH_VARARGS | METH_KEYWORDS, C("approx_equal_cu_double_matrix(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, tol:float=default) -> bool\n  Calls C++ function\n  bool ::kaldi::ApproxEqual(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, double)")},
  {C("assert_equal_cu_double_matrix"), (PyCFunction)wrapAssertEqual_as_assert_equal_cu_double_matrix, METH_VARARGS | METH_KEYWORDS, C("assert_equal_cu_double_matrix(A:CuDoubleMatrixBase, B:CuDoubleMatrixBase, tol:float=default)\n  Calls C++ function\n  void ::kaldi::AssertEqual(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>, float)")},
  {C("same_dim_cu_double_matrix"), (PyCFunction)wrapSameDim_as_same_dim_cu_double_matrix, METH_VARARGS | METH_KEYWORDS, C("same_dim_cu_double_matrix(M:CuDoubleMatrixBase, N:CuDoubleMatrixBase) -> bool\n  Calls C++ function\n  bool ::kaldi::SameDim(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {C("same_dim_and_stride_cu_double_matrix"), (PyCFunction)wrapSameDimAndStride_as_same_dim_and_stride_cu_double_matrix, METH_VARARGS | METH_KEYWORDS, C("same_dim_and_stride_cu_double_matrix(M:CuDoubleMatrixBase, N:CuDoubleMatrixBase) -> bool\n  Calls C++ function\n  bool ::kaldi::SameDimAndStride(::kaldi::CuMatrixBase<double>, ::kaldi::CuMatrixBase<double>)")},
  {}
};

bool Ready() {
  if (PyType_Ready(&pyCuMatrixBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuMatrixBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyCuMatrix::wrapper_Type.tp_base = &pyCuMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyCuMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  pyCuSubMatrix::wrapper_Type.tp_base = &pyCuMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyCuSubMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuSubMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  if (PyType_Ready(&pyCuDoubleMatrixBase::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuDoubleMatrixBase::wrapper_Type);  // For PyModule_AddObject to steal.
  pyCuDoubleMatrix::wrapper_Type.tp_base = &pyCuDoubleMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyCuDoubleMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuDoubleMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  pyCuDoubleSubMatrix::wrapper_Type.tp_base = &pyCuDoubleMatrixBase::wrapper_Type;
  if (PyType_Ready(&pyCuDoubleSubMatrix::wrapper_Type) < 0) return false;
  Py_INCREF(&pyCuDoubleSubMatrix::wrapper_Type);  // For PyModule_AddObject to steal.
  return true;
}

static struct PyModuleDef Module = {
  PyModuleDef_HEAD_INIT,
  "_cu_matrix",  // module name
  "CLIF-generated module for cudamatrix/cu-matrix.h", // module doc
  -1,  // module keeps state in global variables
  Methods
};

PyObject* Init() {
  PyObject* module = PyModule_Create(&Module);
  if (!module) return nullptr;
  if (PyObject* m = PyImport_ImportModule("_iostream")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_matrix_common")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_vector")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_kaldi_matrix")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_matrixdim")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_array")) Py_DECREF(m);
  else goto err;
  if (PyObject* m = PyImport_ImportModule("_cu_vector")) Py_DECREF(m);
  else goto err;
  PyEval_InitThreads();
  if (PyModule_AddObject(module, "CuMatrixBase", reinterpret_cast<PyObject*>(&pyCuMatrixBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuMatrix", reinterpret_cast<PyObject*>(&pyCuMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuSubMatrix", reinterpret_cast<PyObject*>(&pyCuSubMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuDoubleMatrixBase", reinterpret_cast<PyObject*>(&pyCuDoubleMatrixBase::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuDoubleMatrix", reinterpret_cast<PyObject*>(&pyCuDoubleMatrix::wrapper_Type)) < 0) goto err;
  if (PyModule_AddObject(module, "CuDoubleSubMatrix", reinterpret_cast<PyObject*>(&pyCuDoubleSubMatrix::wrapper_Type)) < 0) goto err;
  return module;
err:
  Py_DECREF(module);
  return nullptr;
}

}  // namespace __cu__matrix_clifwrap

namespace kaldi {
using namespace ::clif;
using ::clif::Clif_PyObjAs;
using ::clif::Clif_PyObjFrom;

// CuDoubleMatrix to/from ::kaldi::CuMatrix<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrix<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuDoubleMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrix<double>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::CuMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuMatrix<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<double>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::CuMatrix<double>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::CuMatrix<double>>(c);
  return py;
}

// CuDoubleMatrixBase to/from ::kaldi::CuMatrixBase<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrixBase<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuMatrixBase<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuMatrixBase<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrixBase<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuMatrixBase<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrixBase<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuDoubleMatrixBase instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuMatrixBase<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuMatrixBase<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuMatrixBase<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<double>>(std::move(c));
  return py;
}

// CuDoubleSubMatrix to/from ::kaldi::CuSubMatrix<double> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuSubMatrix<double>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuSubMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuSubMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuSubMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuSubMatrix<double>>* c) {
  assert(c != nullptr);
  ::kaldi::CuSubMatrix<double>* cpp = __cu__matrix_clifwrap::pyCuDoubleSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuDoubleSubMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuSubMatrix<double>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<double>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuSubMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<double>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuSubMatrix<double>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuDoubleSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<double>>(std::move(c));
  return py;
}

// CuMatrix to/from ::kaldi::CuMatrix<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrix<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrix<float>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, ::gtl::optional<::kaldi::CuMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = *cpp;
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuMatrix<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrix<float>>(std::move(c));
  return py;
}

PyObject* Clif_PyObjFrom(const ::kaldi::CuMatrix<float>& c, py::PostConv unused) {
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrix::wrapper*>(py)->cpp = ::clif::MakeShared<::kaldi::CuMatrix<float>>(c);
  return py;
}

// CuMatrixBase to/from ::kaldi::CuMatrixBase<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuMatrixBase<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuMatrixBase<float>* cpp = __cu__matrix_clifwrap::pyCuMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuMatrixBase<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrixBase<float>* cpp = __cu__matrix_clifwrap::pyCuMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrixBase::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuMatrixBase<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuMatrixBase<float>* cpp = __cu__matrix_clifwrap::pyCuMatrixBase::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrixBase::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuMatrixBase instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuMatrixBase<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuMatrixBase<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuMatrixBase<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuMatrixBase::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuMatrixBase::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuMatrixBase<float>>(std::move(c));
  return py;
}

// CuSubMatrix to/from ::kaldi::CuSubMatrix<float> conversion

bool Clif_PyObjAs(PyObject* py, ::kaldi::CuSubMatrix<float>** c) {
  assert(c != nullptr);
  if (Py_None == py) {
    *c = nullptr;
    return true;
  }
  ::kaldi::CuSubMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = cpp;
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::shared_ptr<::kaldi::CuSubMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuSubMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  *c = ::clif::MakeStdShared(reinterpret_cast<__cu__matrix_clifwrap::pyCuSubMatrix::wrapper*>(py)->cpp, cpp);
  return true;
}

bool Clif_PyObjAs(PyObject* py, std::unique_ptr<::kaldi::CuSubMatrix<float>>* c) {
  assert(c != nullptr);
  ::kaldi::CuSubMatrix<float>* cpp = __cu__matrix_clifwrap::pyCuSubMatrix::ThisPtr(py);
  if (cpp == nullptr) return false;
  if (!reinterpret_cast<__cu__matrix_clifwrap::pyCuSubMatrix::wrapper*>(py)->cpp.Detach()) {
    PyErr_SetString(PyExc_ValueError, "Cannot convert CuSubMatrix instance to std::unique_ptr.");
    return false;
  }
  c->reset(cpp);
  return true;
}

PyObject* Clif_PyObjFrom(::kaldi::CuSubMatrix<float>* c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<float>>(c, ::clif::UnOwnedResource());
  return py;
}

PyObject* Clif_PyObjFrom(std::shared_ptr<::kaldi::CuSubMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<float>>(c);
  return py;
}

PyObject* Clif_PyObjFrom(std::unique_ptr<::kaldi::CuSubMatrix<float>> c, py::PostConv unused) {
  if (c == nullptr) Py_RETURN_NONE;
  PyObject* py = PyType_GenericNew(&__cu__matrix_clifwrap::pyCuSubMatrix::wrapper_Type, NULL, NULL);
  reinterpret_cast<__cu__matrix_clifwrap::pyCuSubMatrix::wrapper*>(py)->cpp = ::clif::Instance<::kaldi::CuSubMatrix<float>>(std::move(c));
  return py;
}

}  // namespace kaldi
